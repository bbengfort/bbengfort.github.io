<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Go Closures & Interfaces | Libelli</title>
<meta name=keywords content><meta name=description content="Strict typing in the Go programming language provides safety and performance that is valuable even if it does increase the verbosity of code. If there is a drawback to be found with strict typing, it is usually felt by library developers who require flexibility to cover different use cases, and most often appears as a suite of type-named functions such as lib.HandleString, lib.HandleUint64, lib.HandleBool and so on. Go does provide two important language tools that do provide a lot of flexibility in library development: closures and interfaces, which we will explore in this post."><meta name=author content="Benjamin Bengfort"><link rel=canonical href=https://bbengfort.github.io/2021/02/go-closures-interfaces/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://bbengfort.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://bbengfort.github.io/icon.png><link rel=icon type=image/png sizes=32x32 href=https://bbengfort.github.io/icon.png><link rel=apple-touch-icon href=https://bbengfort.github.io/apple-touch-icon-precomposed.png><link rel=mask-icon href=https://bbengfort.github.io/icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://bbengfort.github.io/2021/02/go-closures-interfaces/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-D3BE7EHHVP"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-D3BE7EHHVP")}</script><meta property="og:title" content="Go Closures & Interfaces"><meta property="og:description" content="Strict typing in the Go programming language provides safety and performance that is valuable even if it does increase the verbosity of code. If there is a drawback to be found with strict typing, it is usually felt by library developers who require flexibility to cover different use cases, and most often appears as a suite of type-named functions such as lib.HandleString, lib.HandleUint64, lib.HandleBool and so on. Go does provide two important language tools that do provide a lot of flexibility in library development: closures and interfaces, which we will explore in this post."><meta property="og:type" content="article"><meta property="og:url" content="https://bbengfort.github.io/2021/02/go-closures-interfaces/"><meta property="og:image" content="https://bbengfort.github.io/bear.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-02-23T08:28:22-05:00"><meta property="article:modified_time" content="2021-02-23T08:28:22-05:00"><meta property="og:site_name" content="Libelli"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://bbengfort.github.io/bear.png"><meta name=twitter:title content="Go Closures & Interfaces"><meta name=twitter:description content="Strict typing in the Go programming language provides safety and performance that is valuable even if it does increase the verbosity of code. If there is a drawback to be found with strict typing, it is usually felt by library developers who require flexibility to cover different use cases, and most often appears as a suite of type-named functions such as lib.HandleString, lib.HandleUint64, lib.HandleBool and so on. Go does provide two important language tools that do provide a lot of flexibility in library development: closures and interfaces, which we will explore in this post."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://bbengfort.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Go Closures \u0026 Interfaces","item":"https://bbengfort.github.io/2021/02/go-closures-interfaces/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Go Closures \u0026 Interfaces","name":"Go Closures \u0026 Interfaces","description":"Strict typing in the Go programming language provides safety and performance that is valuable even if it does increase the verbosity of code. If there is a drawback to be found with strict typing, it is usually felt by library developers who require flexibility to cover different use cases, and most often appears as a suite of type-named functions such as lib.HandleString, lib.HandleUint64, lib.HandleBool and so on. Go does provide two important language tools that do provide a lot of flexibility in library development: closures and interfaces, which we will explore in this post.\n","keywords":[],"articleBody":"Strict typing in the Go programming language provides safety and performance that is valuable even if it does increase the verbosity of code. If there is a drawback to be found with strict typing, it is usually felt by library developers who require flexibility to cover different use cases, and most often appears as a suite of type-named functions such as lib.HandleString, lib.HandleUint64, lib.HandleBool and so on. Go does provide two important language tools that do provide a lot of flexibility in library development: closures and interfaces, which we will explore in this post.\nClosures Closures may be one of the most misunderstood concepts in computer science because the term is rooted in language-specific constructs such as scope, stack vs heap allocation, and anonymous functions. Perhaps the most precise definition of a closure is:\nThe combination of a function with an environment where the environment is a mapping of all free variables available to the function to the value or reference of those variables at the time the closure was created.\nSaid a bit more simply, closures can be thought of as a packaging of specific state with a specific function in an isolated (closed) bundle. If this sounds similar to object-oriented programming, then you’d be right - in fact, programming languages that allow closures typically implement them with a special data structure analogous to an object or by implementing function objects. This has implications for stack vs heap allocation and defines what kinds of programming languages could support closures (not all can). Note that languages that natively support closures also tend to use garbage collection.\nSo why would you use a closure instead of an object? One very common answer is simplicity - compare the following code that implements a closure with code that implements a struct with a method:\npackage main import \"fmt\" func Counter() func () int { var i int return func() int { i++ return i } } func main() { counter := Counter() fmt.Println(counter()) fmt.Println(counter()) other := Counter() fmt.Println(other()) fmt.Println(counter()) } In the closure code, the Counter function returns the closure, the func() int, whose environment is the variable i. When the closure is called, it increments its state variable i and maintains that state across multiple calls. If a new closure, other, is created its state is separate from the state of the original counter.\npackage main import \"fmt\" type Counter struct { i int } func (c *Counter) Incr() int { c.i++ return c.i } func main() { counter := new(Counter) fmt.Println(counter.Incr()) fmt.Println(counter.Incr()) other := new(Counter) fmt.Println(other.Incr()) fmt.Println(counter.Incr()) } The struct code defines a Counter struct with an internal int i as its state, then provides a method Incr to modify and return that state in a similar way to the closure code.\nThe simplicity argument is that the counter only uses a single definition instead of two (e.g. a definition for the closure function instead of one each for the struct and method definitions) and reduces the lexical complexity - e.g. removing the need for creating and initializing a new struct and the dotted method call. However, they are the same number of lines of code and in my opinion the struct code is more flexible. More importantly, the struct code is more performant:\nBenchmarkCounterStruct-8 1000000000\t0.278 ns/op BenchmarkCounterClosure-8 27671817\t39.6 ns/op These benchmarks test the allocation/creation of either the struct or the closure and one call to increment. The closure is 142x slower likely because of the overhead of creating the additional closure structure and the allocations required to add the environment and mapping to the stack.\nA better argument for the use of closures is to allow flexibility in code.\nUnlike a struct, the state of a closure need not be defined prior to its use since its state is all variables in the enclosing scope. This is why anonymous or lambda functions are inextricably tied with closures, since in Go an anonymous function is required to create a closure. Anonymous functions are not necessarily closures, however, they’re simply functions that are not bound to a name. Still, it’s tough to come up with a use case in Go where an anonymous function is not a closure.\nCapturing variables in the enclosing scope in the environment of the closure brings us to the primary use case for closures in Golang: kicking off go routines to do work. Consider the following example that creates and calls 11 closures as go routines:\npackage main import ( \"fmt\" \"log\" ) func main() { // Create the done and errc channels in the scope of the main function. These // channels are the primary local variables that we're going to enclose in the // environment of all 11 closures created in this function. errc := make(chan error, 1) done := make(chan int, 1) // Instantiate 10 worker closures that uses the errc and done channels. for i := 0; i \u003c 10; i++ { // Note that this closure takes as input an integer j, and the for loop // variable, i, is passed to this function as an argument rather than the // closure accessing the enclosed i. More on this later. go func(j int) { if err := doWork(); err != nil { errc \u003c- err } done \u003c- j }(i) } // The 11th closure reads off of the done channel and marks progress, closing // the error channel when all work is complete to signal to the main routine // that the work is finished. go func() { for i := 0; i \u003c 10; i++ { j := \u003c-done fmt.Printf(\"worker %d done in %d position\\n\", j, i+1) } // When done, close the error channel close(errc) }() // The main routine continues, blocking on the error channel to allow the // workers to do their thing rather than simply exiting. If it receives an // error, the program is terminated early. for err := range errc { if err != nil { log.Fatal(err) } } // When the error channel is closed by the 11th closure, we get to this point // and exit the program with a success message! fmt.Println(\"done successfully!\") } In this snippet of code the calls to go func() {}() are the simultaneous definition of an anonymous function, the creation of a closure, and the execution of a go routine. In this context, the anonymous function is what is allowing the closure to be created. Consider the valid execution of a named function with a similar function body, go doWork(i), to kick off the go routine; in this case the compiler would error with undefined: errc or undefined: done since the named function is not a closure and the two channels would have to be passed explicitly to the function.\nThis also brings us to the major gotcha with closures - the state that they enclose is a shared state that is readable and writable by all routines. Note that all routines in the snippet above could easily send on or read from any of the channels in the enclosing state. This is precisely why it is so important to use channels or lower level atomics/mutexes for synchronization across go routines. One key place that is a common error for Go programmers is the for loop that creates the 10 workers. Although the closure has access to the variable i, as the loop changes, so does the variable. Therefore if it were to done \u003c- i rather than j, then it’s likely only 9 would be printed to the console. By creating an argument j and passing i into the function, the variable is escaped out of the outer scope and placed into the inner scope of the closure function.\nAnd finally, a last comment on closures in Go - they can be typed. One common pattern is to create a factory function that has an outer scope to do some work and returns a closure to do the handling. For example, the go routines from above could be refactored as follows:\n// Specify the type of the worker function, that is a function that takes an int type worker func(i int) // Worker factory creates a new worker function enclosing the outer scope that // contains the done and errc channels. Note that the directionality is now // specified, the worker can only send on the channel, not recv. func workerFactory(done chan\u003c- int, errc chan\u003c- error) (worker, err) { // Check to make sure the worker can be created, otherwise return error // Create the closure and return it return func(i int) { if err := doWork(); err != nil { errc \u003c- err } done \u003c- i }, nil } func main() { errc := make(chan error, 1) done := make(chan int, 1) // Instantiate 10 workers to do the work, first checking to ensure the worker // can be created by the factory. for i := 0; i \u003c 10; i++ { worker, err := workerFactory(done, errc) if err != nil { log.Fatal(err) } go worker(i) } ... } Although it appears that there is no closure created here, in fact there is. Instead of the enclosing the scope of the main function, it is the scope of workerFactory that is enclosed in the closure. This also gives us the opportunity to specify the directionality of the channels so that the worker can only send and not recv on the done and errc channels. This pattern is useful when some work needs to be done to set up the worker(s) (e.g. connect to a database) or check to make sure other constraints are satisfied (e.g. “only launch 100 workers”).\nClosures and function types are one of the two primary ways Go provides flexibility for library code, the other is interfaces.\nInterfaces Interfaces are types in programming that specify the behavior of an entity.\nI’ve chosen this definition carefully because interfaces are commonly used in object-oriented programming languages such as Java and may have flexible interpretations for duck-typed languages, e.g. “if it looks like a duck, it quacks like a duck, it walks like a duck - then it’s a duck”. In a strictly typed language like Go, an interface must be a type. More specifically in Go, an interface is “a named collection of method signatures”.\nThe most common interface that we use in go is the error interface, which is defined as follows:\ntype error interface { Error() string } When we declare a function that returns an error, we are actually specifying that the function returns a struct that implements the error interface, e.g. it has an Error method that returns a string. The two most common ways we create errors in Go are via fmt.Errorf and errors.New - both of these functions actually return a *errors.errorString type (use fmt.Printf(\"%T\\n\", err) to print the type of an object or an error). We could just as easily do the following (which is also very common):\ntype Error struct { code uint32 msg string } func (e *Error) Error() string { return fmt.Errorf(\"[%d] %s\", e.code, e.msg) } func myfunc() error { return \u0026Error{code: 32, msg: \"it didn't work\"} } Interfaces therefore give us the opportunity to pass around different base types to different functions even in a strictly typed environment, because the function will know what method it can call using that type. One of the best examples in the Go standard library of the flexibility of types is the io library and the io.Reader and io.Writer interfaces:\ntype Reader interface { Read(p []byte) (n int, err error) } type Writer interface { Write(p []byte) (n int, err error) } These interfaces mean that you can create a function that accepts an either an *os.File or a *bytes.Buffer or some other socket connection, etc. and read or write to it using the same interface. You can also compile interfaces into a single interface, e.g.\ntype ReadWriter interface { io.Reader io.Writer io.Closer } This interface requires objects to have all of the Read([]byte) (int, error), Write([]byte) (int, error), and Close() error methods. In fact, the io.ReadCloser interface is such a compiled interface in the standard library. The best practice for flexbility with interfaces is to define the minimum number of methods required for a single interface, and to build them up into larger interfaces as needed (without letting it get out of hand). For example:\ntype Worker interface { Handle(Task) error Name() string } type Preparer interface { Before() error } type Janitor interface { Cleanup() error } type Workflow interface { Preparer Worker Janitor } Library code might have a single method that does all of the workflow using a Worfklow object, but can be made more flexbile by calling individual functions for the other interfaces. By requiring only the interface that is needed for the input of the function, the testing becomes easier and the library more robust.\nLet’s get into some common gotchas. Consider the following interface:\ntype Handler interface { Handle() error } First, arguments to functions that accept Handler types are defined as follows:\nfunc Do(h Handler) error { return h.Handle() } This can be confusing because you might be passing a pointer to a struct that implements Handler, but if you create the following definition:\nfunc Do(h *Handler) error {} You’ll receive the following error:\ncannot use valueHandler literal (type valueHandler) as type *Handler in argument to Do: *Handler is pointer to interface, not interface That’s because Handler is an interface, and the struct that implements Handler could be either a value or a pointer. Whether it is a value or pointer depends on how the method is implemented:\ntype pointerHandler struct {} func (*pointerHandler) Handle() error { return nil } type valueHandler struct {} func (valueHandler) Handle() error { return nil } Given these methods the following are valid:\nDo(\u0026pointerHandler{}) Do(valueHandler) But the following is not valid:\nDo(pointerHandler{}) Which will cause the following error to be raised:\ncannot use pointerHandler literal (type pointerHandler) as type Handler in argument to Do: pointerHandler does not implement Handler (Handle method has pointer receiver) Somewhat confusingly, Do(\u0026valueHandler{}) is allowed, but when h.Handle is called it will be called with a copy of the value passed in which means that the handler will not be able to change the data on the original referenced struct. I tend to try to avoid this situation because of the confusion it might cause.\nThis leads us finally to interface{} and nil. The empty interface, interface{} is an interface type that specifies no methods. Because it specifies no methods, it may hold values of any type since every type implements at least no methods. Practically speaking interface{} is used as a catchall as a preliminary to custom type checking, for example:\nfunc serialize(v interface{}) string { switch t := v.(type) { case int: return fmt.Sprintf(\"%X\", v) case bool: if t { return \"true\" } else { return \"false\" } case string: return t case error: return t.Error() default: return fmt.Sprintf(\"unknown type %T\", v) } } Here, a type switch is used to test the type of the value v, the case statements must use types to test and the assigned value t is a variable of the type matched with the value of v. Using type assertions also allows unpack the base type of an interface. Using our Error example from earlier:\nif e, ok := err.(*Error); ok { // e is an *Error from our code, so we can access it as needed. if e.code == 32 { ... } } This kind of type assertion is only able to be performed on an interface type; otherwise the type assertion would be irrelevant.\nThe final question we should ask ourselves is why we can use nil as a value for an interface, e.g. return nil instead of an error. All types in Go have a “zero value” since there is no None or null in Go. The zero value for an int is 0, for a bool is false, for a string is \"\". If you define a struct value without a pointer, e.g. when you do time.Now() you get back a time.Time not a *time.Time, then the zero value is an empty struct, e.g. time.Time{}, whose internal values are all zero values for their types. The zero value for maps, slices, channels, and pointers is nil.\nConsider the following code:\nvar ( i int s string t time.Time m map[string]string ) These variables are declared but not assigned to, therefore they will all be allocated with their zero value, 0, \"\", time.Time{}, and nil respectively. Because nil is the zero value for all pointers, and because pointers can be used with interface types, passing nil in for an interface is effectively the same as saying “pass the zero value of the interface”. E.g. return nil is pass the zero value of an error. This also means that the nil type check can work directly with interfaces:\ntype Handler interface { Handle() error } func Do(h Handler) error { if h == nil { return errors.New(\"nil handler\") } return h.Handle() } Be careful with this type of check, however, as non-nil zero value types can also be used for an interface:\ntype IntHandler int func (IntHandler) Handle() error { return nil } func main() { fmt.Println(Do(nil)) fmt.Println(Do(IntHandler(0))) } In this case, only the Do(nil) is correctly handled, whereas the zero-valued IntHandler is not nil and therefore its handle method is called.\nnet/http Example Closures and Interfaces might not seem like a natural pairing for discussion, however they are both essential to effective and flexible library development. One of the best examples of this is in Go’s standard library net/http package which allows Go developers to quickly and easily spin up an http server.\nThe documentation describes how to get a simple server going with the DefaultServeMux using http.Handle and http.HandleFunc. A “mux” (short for “multiplexer”) passes incoming requests to the correct handler based on information from the request. By default, the path of the URL is used to determine which handler to use. In the following example the mux ensures that requests to http://localhost:8080/foo are handled by the fooHandler and to http://localhost:8080/bar are handled by the function passed to http.HandleFunc. Here is the example from the documentation:\nhttp.Handle(\"/foo\", fooHandler) http.HandleFunc(\"/bar\", func(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, \"Hello, %q\", html.EscapeString(r.URL.Path)) }) log.Fatal(http.ListenAndServe(\":8080\", nil)) This example shows both the interface and closure use cases for setting up an http server. In the first line of code, the http.Handle function takes a struct that implements the http.Handler interface as its second argument. In the second, the http.HandleFunc takes as its second argument a function of type http.HandlerFunc, which is a perfect use case for a closure. Finally the http.ListenAndServe method is called to serve requests on the localhost on port :8080; if it returns an error, it will be passed to log.Fatal. Let’s break this down:\nThe http.Handler interface is defined as follows:\ntype Handler interface { ServeHTTP(http.ResponseWriter, *http.Request) } Therefore, to implement the fooHandler we might do something as follows:\ntype FooContext struct { ID int Name string } type Foo struct { content *template.Template } func (f *Foo) ServeHTTP(w http.ResponseWriter, r *http.Request) { context := FooContext{ID: 1, Name: \"Lydia\"} f.content.Execute(w, context) } func main() { // Create a new Foo handler with the specified template loaded from disk. fooHandler := \u0026Foo{ content: template.New(\"foo.html\"), } fooHandler.content = template.Must(fooHandler.content.ParseFiles(\"foo.html\")) http.Handle(\"/foo\", fooHandler) } Here, the Foo struct implements Handler with its ServeHTTP method. In this case, it maintains state with an HTML template that is loaded from a file and that template is executed with a context and written into the response body. You could see how the ServeHTTP method might use the request to look up information in a database to use for the context or do other processing on behalf of the user.\nThe http.HandlerFunc type is defined as follows:\ntype HanderFunc func(http.ResponseWriter, *http.Request) The function signature is identical to the method signature in the interface. In both cases the library expects the user to handle the incoming request and write the response into the response writer. Using http.HandleFunc provides the opportunity to create a closure to maintain simple state. One very common use case for this is to create a chain of middleware functions that wrap other handlers. Consider the following middleware stub code:\nfunc middleware(next http.HandlerFunc) http.HandlerFunc { // One-time setup/initialization of the middleware coded here. ... // Create the closure to return as the handler function return func(w http.ResponseWriter, r *http.Request) { // Before the next request is handled, e.g. handle the incoming request // If this function returns before the next handler is called, then it short // circuits the request and no downstream handlers will be called. ... // Execute the next handler in the change next(w, r) // After the request has been handled, e.g. handle the outgoing response ... } } This allows you to create a flow of control such that the outer middleware are handled first until some final middleware, then the response goes back out through the layers until the response is returned to the user. Common middleware steps for an http server include tracing, logging, authentication, content negotation, and more! This might look something as follows:\nfunc logging(next http.Handler) http.Handler { log := logger.New() return func(w http.ResponseWriter, r *http.Request) { next(w, r) log.Info(\"request handled\") } } func authentication(username, password string, next http.Handler) http.Handler { token := fmt.Sprintf(\"%s:%s\", username, password) return func(w http.ResponseWriter, r *http.Request) { header := r.Header.Get(\"Authorization\") if header != token { http.Error(w, \"username/password not recognized\", http.StatusForbidden) return } next(w, r) } } func final(w http.ResponseWriter, r *http.Request) { w.Write([]byte(\"Hello World!\")) } func main() { // Create middleware handler := logging(authenticate(username, password, final)) } The closures allow us to easily construct handler-specific chains of http request handling that are intuitive and easily adaptible!\nWrap-Up Strict typing helps programmers write safe and highly-performant code and language constructs like interfaces and closures help them write flexible code even with strict typing. Careful consideration of how to define interfaces and libraries that use closures can make working with Go libraries more productive and enjoyable!\n","wordCount":"3688","inLanguage":"en","image":"https://bbengfort.github.io/bear.png","datePublished":"2021-02-23T08:28:22-05:00","dateModified":"2021-02-23T08:28:22-05:00","author":{"@type":"Person","name":"Benjamin Bengfort"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://bbengfort.github.io/2021/02/go-closures-interfaces/"},"publisher":{"@type":"Organization","name":"Libelli","logo":{"@type":"ImageObject","url":"https://bbengfort.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bbengfort.github.io/ accesskey=h title="Libelli (Alt + H)"><img src=https://bbengfort.github.io/icon.png alt aria-label=logo height=35>Libelli</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://bbengfort.github.io/archive/ title=archive><span>archive</span></a></li><li><a href=https://bbengfort.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://bbengfort.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://bbengfort.github.io/about/ title=about><span>about</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://bbengfort.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://bbengfort.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Go Closures & Interfaces</h1><div class=post-meta><span title='2021-02-23 08:28:22 -0500 -0500'>February 23, 2021</span>&nbsp;·&nbsp;18 min&nbsp;·&nbsp;3688 words&nbsp;·&nbsp;Benjamin Bengfort&nbsp;|&nbsp;<a href=https://github.com/bbengfort/bbengfort.github.io/tree/main/content/posts/2021-02-23-closures-interfaces.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#closures>Closures</a></li><li><a href=#interfaces>Interfaces</a></li><li><a href=#nethttp-example>net/http Example</a></li><li><a href=#wrap-up>Wrap-Up</a></li></ul></nav></div></details></div><div class=post-content><p>Strict typing in the Go programming language provides safety and performance that is valuable even if it does increase the verbosity of code. If there is a drawback to be found with strict typing, it is usually felt by library developers who require flexibility to cover different use cases, and most often appears as a suite of type-named functions such as <code>lib.HandleString</code>, <code>lib.HandleUint64</code>, <code>lib.HandleBool</code> and so on. Go does provide two important language tools that do provide a lot of flexibility in library development: <em>closures</em> and <em>interfaces</em>, which we will explore in this post.</p><h2 id=closures>Closures<a hidden class=anchor aria-hidden=true href=#closures>#</a></h2><p>Closures may be one of the most misunderstood concepts in computer science because the term is rooted in language-specific constructs such as scope, stack vs heap allocation, and anonymous functions. Perhaps the most precise definition of a closure is:</p><blockquote><p>The combination of a <em>function</em> with an <em>environment</em> where the environment is a mapping of all free variables available to the function to the value or reference of those variables at the time the closure was created.</p></blockquote><p>Said a bit more simply, closures can be thought of as a packaging of specific state with a specific function in an isolated (closed) bundle. If this sounds similar to object-oriented programming, then you&rsquo;d be right - in fact, programming languages that allow closures typically implement them with a special data structure analogous to an object or by implementing function objects. This has implications for stack vs heap allocation and defines what kinds of programming languages could support closures (not all can). Note that languages that natively support closures also tend to use garbage collection.</p><p>So why would you use a closure instead of an object? One very common answer is simplicity - compare the following code that implements a closure with code that implements a struct with a method:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Counter</span><span class=p>()</span> <span class=kd>func</span> <span class=p>()</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>i</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kd>func</span><span class=p>()</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>i</span><span class=o>++</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>i</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>counter</span> <span class=o>:=</span> <span class=nf>Counter</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nf>counter</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nf>counter</span><span class=p>())</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>other</span> <span class=o>:=</span> <span class=nf>Counter</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nf>other</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nf>counter</span><span class=p>())</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>In the closure code, the <code>Counter</code> function returns the closure, the <code>func() int</code>, whose environment is the variable <code>i</code>. When the closure is called, it increments its state variable <code>i</code> and maintains that state across multiple calls. If a new closure, <code>other</code>, is created its state is separate from the state of the original counter.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Counter</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>i</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>Counter</span><span class=p>)</span> <span class=nf>Incr</span><span class=p>()</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>c</span><span class=p>.</span><span class=nx>i</span><span class=o>++</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>c</span><span class=p>.</span><span class=nx>i</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>counter</span> <span class=o>:=</span> <span class=nb>new</span><span class=p>(</span><span class=nx>Counter</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>counter</span><span class=p>.</span><span class=nf>Incr</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>counter</span><span class=p>.</span><span class=nf>Incr</span><span class=p>())</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>other</span> <span class=o>:=</span> <span class=nb>new</span><span class=p>(</span><span class=nx>Counter</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>other</span><span class=p>.</span><span class=nf>Incr</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>counter</span><span class=p>.</span><span class=nf>Incr</span><span class=p>())</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The struct code defines a <code>Counter</code> struct with an internal int <code>i</code> as its state, then provides a method <code>Incr</code> to modify and return that state in a similar way to the closure code.</p><p>The simplicity argument is that the counter only uses a single definition instead of two (e.g. a definition for the closure function instead of one each for the struct and method definitions) and reduces the lexical complexity - e.g. removing the need for creating and initializing a new struct and the dotted method call. However, they are the same number of lines of code and in my opinion the <code>struct</code> code is more flexible. More importantly, the struct code is more performant:</p><pre tabindex=0><code>BenchmarkCounterStruct-8    	1000000000	         0.278 ns/op
BenchmarkCounterClosure-8   	27671817	        39.6   ns/op
</code></pre><p>These benchmarks test the allocation/creation of either the struct or the closure and one call to increment. The closure is 142x slower likely because of the overhead of creating the additional closure structure and the allocations required to add the environment and mapping to the stack.</p><p>A better argument for the use of closures is to allow flexibility in code.</p><p>Unlike a struct, the state of a closure need not be defined prior to its use since its state is <em>all variables in the enclosing scope</em>. This is why <em>anonymous</em> or <em>lambda</em> functions are inextricably tied with closures, since in Go an anonymous function is required to create a closure. Anonymous functions are not necessarily closures, however, they&rsquo;re simply functions that are not bound to a name. Still, it&rsquo;s tough to come up with a use case in Go where an anonymous function is not a closure.</p><p>Capturing variables in the enclosing scope in the environment of the closure brings us to the primary use case for closures in Golang: kicking off go routines to do work. Consider the following example that creates and calls 11 closures as go routines:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;log&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Create the done and errc channels in the scope of the main function. These
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// channels are the primary local variables that we&#39;re going to enclose in the
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// environment of all 11 closures created in this function.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>errc</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>error</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>done</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Instantiate 10 worker closures that uses the errc and done channels.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>10</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Note that this closure takes as input an integer j, and the for loop
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// variable, i, is passed to this function as an argument rather than the
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// closure accessing the enclosed i. More on this later.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=nx>j</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nf>doWork</span><span class=p>();</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nx>errc</span> <span class=o>&lt;-</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=nx>done</span> <span class=o>&lt;-</span> <span class=nx>j</span>
</span></span><span class=line><span class=cl>        <span class=p>}(</span><span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// The 11th closure reads off of the done channel and marks progress, closing
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// the error channel when all work is complete to signal to the main routine
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// that the work is finished.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>10</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>j</span> <span class=o>:=</span> <span class=o>&lt;-</span><span class=nx>done</span>
</span></span><span class=line><span class=cl>            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;worker %d done in %d position\n&#34;</span><span class=p>,</span> <span class=nx>j</span><span class=p>,</span> <span class=nx>i</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// When done, close the error channel
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nb>close</span><span class=p>(</span><span class=nx>errc</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// The main routine continues, blocking on the error channel to allow the
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// workers to do their thing rather than simply exiting. If it receives an
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// error, the program is terminated early.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=nx>err</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>errc</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>log</span><span class=p>.</span><span class=nf>Fatal</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// When the error channel is closed by the 11th closure, we get to this point
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// and exit the program with a success message!
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;done successfully!&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>In this snippet of code the calls to <code>go func() {}()</code> are the simultaneous definition of an anonymous function, the creation of a closure, and the execution of a go routine. In this context, the anonymous function is what is allowing the closure to be created. Consider the valid execution of a named function with a similar function body, <code>go doWork(i)</code>, to kick off the go routine; in this case the compiler would error with <code>undefined: errc</code> or <code>undefined: done</code> since the named function is not a closure and the two channels would have to be passed explicitly to the function.</p><p>This also brings us to the major gotcha with closures - the state that they enclose is a <em>shared</em> state that is readable and writable by all routines. Note that all routines in the snippet above could easily send on or read from any of the channels in the enclosing state. This is precisely why it is so important to use channels or lower level atomics/mutexes for synchronization across go routines. One key place that is a common error for Go programmers is the <code>for</code> loop that creates the 10 workers. Although the closure has access to the variable <code>i</code>, as the loop changes, so does the variable. Therefore if it were to <code>done &lt;- i</code> rather than <code>j</code>, then it&rsquo;s likely only <code>9</code> would be printed to the console. By creating an argument <code>j</code> and passing <code>i</code> into the function, the variable is escaped out of the outer scope and placed into the inner scope of the closure function.</p><p>And finally, a last comment on closures in Go - they can be typed. One common pattern is to create a factory function that has an outer scope to do some work and returns a closure to do the handling. For example, the go routines from above could be refactored as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Specify the type of the worker function, that is a function that takes an int
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>worker</span> <span class=kd>func</span><span class=p>(</span><span class=nx>i</span> <span class=kt>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Worker factory creates a new worker function enclosing the outer scope that
</span></span></span><span class=line><span class=cl><span class=c1>// contains the done and errc channels. Note that the directionality is now
</span></span></span><span class=line><span class=cl><span class=c1>// specified, the worker can only send on the channel, not recv.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>workerFactory</span><span class=p>(</span><span class=nx>done</span> <span class=kd>chan</span><span class=o>&lt;-</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>errc</span> <span class=kd>chan</span><span class=o>&lt;-</span> <span class=kt>error</span><span class=p>)</span> <span class=p>(</span><span class=nx>worker</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Check to make sure the worker can be created, otherwise return error
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>// Create the closure and return it
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=kd>func</span><span class=p>(</span><span class=nx>i</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nf>doWork</span><span class=p>();</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>errc</span> <span class=o>&lt;-</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nx>done</span> <span class=o>&lt;-</span> <span class=nx>i</span>
</span></span><span class=line><span class=cl>    <span class=p>},</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>errc</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>error</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>done</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Instantiate 10 workers to do the work, first checking to ensure the worker
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// can be created by the factory.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>10</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>worker</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nf>workerFactory</span><span class=p>(</span><span class=nx>done</span><span class=p>,</span> <span class=nx>errc</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>log</span><span class=p>.</span><span class=nf>Fatal</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>go</span> <span class=nf>worker</span><span class=p>(</span><span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Although it appears that there is no closure created here, in fact there is. Instead of the enclosing the scope of the <code>main</code> function, it is the scope of <code>workerFactory</code> that is enclosed in the closure. This also gives us the opportunity to specify the directionality of the channels so that the worker can only send and not recv on the <code>done</code> and <code>errc</code> channels. This pattern is useful when some work needs to be done to set up the worker(s) (e.g. connect to a database) or check to make sure other constraints are satisfied (e.g. &ldquo;only launch 100 workers&rdquo;).</p><p>Closures and function types are one of the two primary ways Go provides flexibility for library code, the other is interfaces.</p><h2 id=interfaces>Interfaces<a hidden class=anchor aria-hidden=true href=#interfaces>#</a></h2><p>Interfaces are types in programming that specify the <em>behavior</em> of an entity.</p><p>I&rsquo;ve chosen this definition carefully because interfaces are commonly used in object-oriented programming languages such as Java and may have flexible interpretations for duck-typed languages, e.g. &ldquo;if it looks like a duck, it quacks like a duck, it walks like a duck - then it&rsquo;s a duck&rdquo;. In a strictly typed language like Go, an interface must be a type. More specifically in Go, an interface is &ldquo;a named collection of method signatures&rdquo;.</p><p>The most common interface that we use in go is the <code>error</code> interface, which is defined as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=kt>error</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>Error</span><span class=p>()</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>When we declare a function that returns an error, we are actually specifying that the function returns a struct that <em>implements</em> the <code>error</code> interface, e.g. it has an <code>Error</code> method that returns a string. The two most common ways we create errors in Go are via <code>fmt.Errorf</code> and <code>errors.New</code> - both of these functions actually return a <code>*errors.errorString</code> type (use <code>fmt.Printf("%T\n", err)</code> to print the type of an object or an error). We could just as easily do the following (which is also very common):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Error</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>code</span> <span class=kt>uint32</span>
</span></span><span class=line><span class=cl>    <span class=nx>msg</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>e</span> <span class=o>*</span><span class=nx>Error</span><span class=p>)</span> <span class=nf>Error</span><span class=p>()</span> <span class=kt>string</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;[%d] %s&#34;</span><span class=p>,</span> <span class=nx>e</span><span class=p>.</span><span class=nx>code</span><span class=p>,</span> <span class=nx>e</span><span class=p>.</span><span class=nx>msg</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>myfunc</span><span class=p>()</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>&amp;</span><span class=nx>Error</span><span class=p>{</span><span class=nx>code</span><span class=p>:</span> <span class=mi>32</span><span class=p>,</span> <span class=nx>msg</span><span class=p>:</span> <span class=s>&#34;it didn&#39;t work&#34;</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Interfaces therefore give us the opportunity to pass around different base types to different functions even in a strictly typed environment, because the function will know what method it can call using that type. One of the best examples in the Go standard library of the flexibility of types is the <code>io</code> library and the <code>io.Reader</code> and <code>io.Writer</code> interfaces:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Reader</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>Read</span><span class=p>(</span><span class=nx>p</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Writer</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>Write</span><span class=p>(</span><span class=nx>p</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>These interfaces mean that you can create a function that accepts an either an <code>*os.File</code> or a <code>*bytes.Buffer</code> or some other socket connection, etc. and read or write to it using the same interface. You can also compile interfaces into a single interface, e.g.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>ReadWriter</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>io</span><span class=p>.</span><span class=nx>Reader</span>
</span></span><span class=line><span class=cl>    <span class=nx>io</span><span class=p>.</span><span class=nx>Writer</span>
</span></span><span class=line><span class=cl>    <span class=nx>io</span><span class=p>.</span><span class=nx>Closer</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This interface requires objects to have all of the <code>Read([]byte) (int, error)</code>, <code>Write([]byte) (int, error)</code>, and <code>Close() error</code> methods. In fact, the <code>io.ReadCloser</code> interface is such a compiled interface in the standard library. The best practice for flexbility with interfaces is to define the minimum number of methods required for a single interface, and to build them up into larger interfaces as needed (without letting it get out of hand). For example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Worker</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>Handle</span><span class=p>(</span><span class=nx>Task</span><span class=p>)</span> <span class=kt>error</span>
</span></span><span class=line><span class=cl>    <span class=nf>Name</span><span class=p>()</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Preparer</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>Before</span><span class=p>()</span> <span class=kt>error</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Janitor</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>Cleanup</span><span class=p>()</span> <span class=kt>error</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Workflow</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>Preparer</span>
</span></span><span class=line><span class=cl>    <span class=nx>Worker</span>
</span></span><span class=line><span class=cl>    <span class=nx>Janitor</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Library code might have a single method that does all of the workflow using a <code>Worfklow</code> object, but can be made more flexbile by calling individual functions for the other interfaces. By requiring only the interface that is needed for the input of the function, the testing becomes easier and the library more robust.</p><p>Let&rsquo;s get into some common gotchas. Consider the following interface:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Handler</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>Handle</span><span class=p>()</span> <span class=kt>error</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>First, arguments to functions that accept <code>Handler</code> types are defined as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Do</span><span class=p>(</span><span class=nx>h</span> <span class=nx>Handler</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>h</span><span class=p>.</span><span class=nf>Handle</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This can be confusing because you might be passing a pointer to a struct that implements <code>Handler</code>, but if you create the following definition:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Do</span><span class=p>(</span><span class=nx>h</span> <span class=o>*</span><span class=nx>Handler</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{}</span>
</span></span></code></pre></div><p>You&rsquo;ll receive the following error:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>cannot use valueHandler literal (type valueHandler) as type *Handler in argument to Do:
</span></span><span class=line><span class=cl>	*Handler is pointer to interface, not interface
</span></span></code></pre></div><p>That&rsquo;s because <code>Handler</code> is an interface, and the struct that implements <code>Handler</code> could be either a value or a pointer. Whether it is a value or pointer depends on how the method is implemented:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>pointerHandler</span> <span class=kd>struct</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=o>*</span><span class=nx>pointerHandler</span><span class=p>)</span> <span class=nf>Handle</span><span class=p>()</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>valueHandler</span> <span class=kd>struct</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>valueHandler</span><span class=p>)</span> <span class=nf>Handle</span><span class=p>()</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Given these methods the following are valid:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nf>Do</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>pointerHandler</span><span class=p>{})</span>
</span></span><span class=line><span class=cl><span class=nf>Do</span><span class=p>(</span><span class=nx>valueHandler</span><span class=p>)</span>
</span></span></code></pre></div><p>But the following is not valid:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nf>Do</span><span class=p>(</span><span class=nx>pointerHandler</span><span class=p>{})</span>
</span></span></code></pre></div><p>Which will cause the following error to be raised:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>cannot use pointerHandler literal (type pointerHandler) as type Handler in argument to Do:
</span></span><span class=line><span class=cl>	pointerHandler does not implement Handler (Handle method has pointer receiver)
</span></span></code></pre></div><p>Somewhat confusingly, <code>Do(&amp;valueHandler{})</code> is allowed, but when <code>h.Handle</code> is called it will be called with a copy of the value passed in which means that the handler will not be able to change the data on the original referenced struct. I tend to try to avoid this situation because of the confusion it might cause.</p><p>This leads us finally to <code>interface{}</code> and <code>nil</code>. The empty interface, <code>interface{}</code> is an interface type that specifies no methods. Because it specifies no methods, it may hold values of any type since every type implements at least no methods. Practically speaking <code>interface{}</code> is used as a catchall as a preliminary to custom type checking, for example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>serialize</span><span class=p>(</span><span class=nx>v</span> <span class=kd>interface</span><span class=p>{})</span> <span class=kt>string</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>switch</span> <span class=nx>t</span> <span class=o>:=</span> <span class=nx>v</span><span class=p>.(</span><span class=kd>type</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=kt>int</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Sprintf</span><span class=p>(</span><span class=s>&#34;%X&#34;</span><span class=p>,</span> <span class=nx>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=kt>bool</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>t</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=s>&#34;true&#34;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=s>&#34;false&#34;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=kt>string</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>t</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=kt>error</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>t</span><span class=p>.</span><span class=nf>Error</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>default</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Sprintf</span><span class=p>(</span><span class=s>&#34;unknown type %T&#34;</span><span class=p>,</span> <span class=nx>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Here, a <em>type switch</em> is used to test the type of the value <code>v</code>, the <code>case</code> statements must use types to test and the assigned value <code>t</code> is a variable of the type matched with the value of <code>v</code>. Using type assertions also allows unpack the base type of an interface. Using our <code>Error</code> example from earlier:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=k>if</span> <span class=nx>e</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>err</span><span class=p>.(</span><span class=o>*</span><span class=nx>Error</span><span class=p>);</span> <span class=nx>ok</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// e is an *Error from our code, so we can access it as needed.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=nx>e</span><span class=p>.</span><span class=nx>code</span> <span class=o>==</span> <span class=mi>32</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=o>...</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This kind of type assertion is only able to be performed on an interface type; otherwise the type assertion would be irrelevant.</p><p>The final question we should ask ourselves is why we can use <code>nil</code> as a value for an interface, e.g. <code>return nil</code> instead of an error. All types in Go have a &ldquo;zero value&rdquo; since there is no <code>None</code> or <code>null</code> in Go. The zero value for an int is <code>0</code>, for a bool is <code>false</code>, for a string is <code>""</code>. If you define a struct value without a pointer, e.g. when you do <code>time.Now()</code> you get back a <code>time.Time</code> not a <code>*time.Time</code>, then the zero value is an empty struct, e.g. <code>time.Time{}</code>, whose internal values are all zero values for their types. The zero value for maps, slices, channels, and pointers is <code>nil</code>.</p><p>Consider the following code:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=nx>i</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>    <span class=nx>s</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl>    <span class=nx>t</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Time</span>
</span></span><span class=line><span class=cl>    <span class=nx>m</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>string</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span></code></pre></div><p>These variables are declared but not assigned to, therefore they will all be allocated with their zero value, <code>0</code>, <code>""</code>, <code>time.Time{}</code>, and <code>nil</code> respectively. Because <code>nil</code> is the zero value for all pointers, and because pointers can be used with interface types, passing <code>nil</code> in for an interface is effectively the same as saying &ldquo;pass the zero value of the interface&rdquo;. E.g. <code>return nil</code> is pass the zero value of an <code>error</code>. This also means that the nil type check can work directly with interfaces:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Handler</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>Handle</span><span class=p>()</span> <span class=kt>error</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Do</span><span class=p>(</span><span class=nx>h</span> <span class=nx>Handler</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>h</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=s>&#34;nil handler&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>h</span><span class=p>.</span><span class=nf>Handle</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Be careful with this type of check, however, as non-nil zero value types can also be used for an interface:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>IntHandler</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>IntHandler</span><span class=p>)</span> <span class=nf>Handle</span><span class=p>()</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nf>Do</span><span class=p>(</span><span class=kc>nil</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nf>Do</span><span class=p>(</span><span class=nf>IntHandler</span><span class=p>(</span><span class=mi>0</span><span class=p>)))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>In this case, only the <code>Do(nil)</code> is correctly handled, whereas the zero-valued <code>IntHandler</code> is not <code>nil</code> and therefore its handle method is called.</p><h2 id=nethttp-example>net/http Example<a hidden class=anchor aria-hidden=true href=#nethttp-example>#</a></h2><p>Closures and Interfaces might not seem like a natural pairing for discussion, however they are both essential to effective and flexible library development. One of the best examples of this is in Go&rsquo;s standard library <code>net/http</code> package which allows Go developers to quickly and easily spin up an http server.</p><p>The <a href=https://golang.org/pkg/net/http/>documentation</a> describes how to get a simple server going with the <code>DefaultServeMux</code> using <code>http.Handle</code> and <code>http.HandleFunc</code>. A &ldquo;mux&rdquo; (short for &ldquo;multiplexer&rdquo;) passes incoming requests to the correct handler based on information from the request. By default, the path of the URL is used to determine which handler to use. In the following example the mux ensures that requests to <code>http://localhost:8080/foo</code> are handled by the <code>fooHandler</code> and to <code>http://localhost:8080/bar</code> are handled by the function passed to <code>http.HandleFunc</code>. Here is the example from the documentation:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>http</span><span class=p>.</span><span class=nf>Handle</span><span class=p>(</span><span class=s>&#34;/foo&#34;</span><span class=p>,</span> <span class=nx>fooHandler</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>http</span><span class=p>.</span><span class=nf>HandleFunc</span><span class=p>(</span><span class=s>&#34;/bar&#34;</span><span class=p>,</span> <span class=kd>func</span><span class=p>(</span><span class=nx>w</span> <span class=nx>http</span><span class=p>.</span><span class=nx>ResponseWriter</span><span class=p>,</span> <span class=nx>r</span> <span class=o>*</span><span class=nx>http</span><span class=p>.</span><span class=nx>Request</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Fprintf</span><span class=p>(</span><span class=nx>w</span><span class=p>,</span> <span class=s>&#34;Hello, %q&#34;</span><span class=p>,</span> <span class=nx>html</span><span class=p>.</span><span class=nf>EscapeString</span><span class=p>(</span><span class=nx>r</span><span class=p>.</span><span class=nx>URL</span><span class=p>.</span><span class=nx>Path</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>})</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>log</span><span class=p>.</span><span class=nf>Fatal</span><span class=p>(</span><span class=nx>http</span><span class=p>.</span><span class=nf>ListenAndServe</span><span class=p>(</span><span class=s>&#34;:8080&#34;</span><span class=p>,</span> <span class=kc>nil</span><span class=p>))</span>
</span></span></code></pre></div><p>This example shows both the interface and closure use cases for setting up an http server. In the first line of code, the <code>http.Handle</code> function takes a struct that implements the <code>http.Handler</code> interface as its second argument. In the second, the <code>http.HandleFunc</code> takes as its second argument a function of type <code>http.HandlerFunc</code>, which is a perfect use case for a closure. Finally the <code>http.ListenAndServe</code> method is called to serve requests on the localhost on port :8080; if it returns an error, it will be passed to <code>log.Fatal</code>. Let&rsquo;s break this down:</p><p>The <code>http.Handler</code> interface is defined as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Handler</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>ServeHTTP</span><span class=p>(</span><span class=nx>http</span><span class=p>.</span><span class=nx>ResponseWriter</span><span class=p>,</span> <span class=o>*</span><span class=nx>http</span><span class=p>.</span><span class=nx>Request</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Therefore, to implement the <code>fooHandler</code> we might do something as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>FooContext</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>ID</span>   <span class=kt>int</span>
</span></span><span class=line><span class=cl>	<span class=nx>Name</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Foo</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>content</span> <span class=o>*</span><span class=nx>template</span><span class=p>.</span><span class=nx>Template</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>f</span> <span class=o>*</span><span class=nx>Foo</span><span class=p>)</span> <span class=nf>ServeHTTP</span><span class=p>(</span><span class=nx>w</span> <span class=nx>http</span><span class=p>.</span><span class=nx>ResponseWriter</span><span class=p>,</span> <span class=nx>r</span> <span class=o>*</span><span class=nx>http</span><span class=p>.</span><span class=nx>Request</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>context</span> <span class=o>:=</span> <span class=nx>FooContext</span><span class=p>{</span><span class=nx>ID</span><span class=p>:</span> <span class=mi>1</span><span class=p>,</span> <span class=nx>Name</span><span class=p>:</span> <span class=s>&#34;Lydia&#34;</span><span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>f</span><span class=p>.</span><span class=nx>content</span><span class=p>.</span><span class=nf>Execute</span><span class=p>(</span><span class=nx>w</span><span class=p>,</span> <span class=nx>context</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// Create a new Foo handler with the specified template loaded from disk.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>fooHandler</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>Foo</span><span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>content</span><span class=p>:</span> <span class=nx>template</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=s>&#34;foo.html&#34;</span><span class=p>),</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>fooHandler</span><span class=p>.</span><span class=nx>content</span> <span class=p>=</span> <span class=nx>template</span><span class=p>.</span><span class=nf>Must</span><span class=p>(</span><span class=nx>fooHandler</span><span class=p>.</span><span class=nx>content</span><span class=p>.</span><span class=nf>ParseFiles</span><span class=p>(</span><span class=s>&#34;foo.html&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>http</span><span class=p>.</span><span class=nf>Handle</span><span class=p>(</span><span class=s>&#34;/foo&#34;</span><span class=p>,</span> <span class=nx>fooHandler</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Here, the <code>Foo</code> struct implements <code>Handler</code> with its <code>ServeHTTP</code> method. In this case, it maintains state with an HTML template that is loaded from a file and that template is executed with a context and written into the response body. You could see how the <code>ServeHTTP</code> method might use the request to look up information in a database to use for the context or do other processing on behalf of the user.</p><p>The <code>http.HandlerFunc</code> type is defined as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>HanderFunc</span> <span class=kd>func</span><span class=p>(</span><span class=nx>http</span><span class=p>.</span><span class=nx>ResponseWriter</span><span class=p>,</span> <span class=o>*</span><span class=nx>http</span><span class=p>.</span><span class=nx>Request</span><span class=p>)</span>
</span></span></code></pre></div><p>The function signature is identical to the method signature in the interface. In both cases the library expects the user to handle the incoming request and write the response into the response writer. Using <code>http.HandleFunc</code> provides the opportunity to create a closure to maintain simple state. One very common use case for this is to create a chain of middleware functions that wrap other handlers. Consider the following middleware stub code:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>middleware</span><span class=p>(</span><span class=nx>next</span> <span class=nx>http</span><span class=p>.</span><span class=nx>HandlerFunc</span><span class=p>)</span> <span class=nx>http</span><span class=p>.</span><span class=nx>HandlerFunc</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// One-time setup/initialization of the middleware coded here.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Create the closure to return as the handler function
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=kd>func</span><span class=p>(</span><span class=nx>w</span> <span class=nx>http</span><span class=p>.</span><span class=nx>ResponseWriter</span><span class=p>,</span> <span class=nx>r</span> <span class=o>*</span><span class=nx>http</span><span class=p>.</span><span class=nx>Request</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Before the next request is handled, e.g. handle the incoming request
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// If this function returns before the next handler is called, then it short
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// circuits the request and no downstream handlers will be called.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=o>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// Execute the next handler in the change
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>next</span><span class=p>(</span><span class=nx>w</span><span class=p>,</span> <span class=nx>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// After the request has been handled, e.g. handle the outgoing response
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=o>...</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This allows you to create a flow of control such that the outer middleware are handled first until some final middleware, then the response goes back out through the layers until the response is returned to the user. Common middleware steps for an http server include tracing, logging, authentication, content negotation, and more! This might look something as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>logging</span><span class=p>(</span><span class=nx>next</span> <span class=nx>http</span><span class=p>.</span><span class=nx>Handler</span><span class=p>)</span> <span class=nx>http</span><span class=p>.</span><span class=nx>Handler</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>log</span> <span class=o>:=</span> <span class=nx>logger</span><span class=p>.</span><span class=nf>New</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kd>func</span><span class=p>(</span><span class=nx>w</span> <span class=nx>http</span><span class=p>.</span><span class=nx>ResponseWriter</span><span class=p>,</span> <span class=nx>r</span> <span class=o>*</span><span class=nx>http</span><span class=p>.</span><span class=nx>Request</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>next</span><span class=p>(</span><span class=nx>w</span><span class=p>,</span> <span class=nx>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nx>log</span><span class=p>.</span><span class=nf>Info</span><span class=p>(</span><span class=s>&#34;request handled&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>authentication</span><span class=p>(</span><span class=nx>username</span><span class=p>,</span> <span class=nx>password</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>next</span> <span class=nx>http</span><span class=p>.</span><span class=nx>Handler</span><span class=p>)</span> <span class=nx>http</span><span class=p>.</span><span class=nx>Handler</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>token</span> <span class=o>:=</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Sprintf</span><span class=p>(</span><span class=s>&#34;%s:%s&#34;</span><span class=p>,</span> <span class=nx>username</span><span class=p>,</span> <span class=nx>password</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kd>func</span><span class=p>(</span><span class=nx>w</span> <span class=nx>http</span><span class=p>.</span><span class=nx>ResponseWriter</span><span class=p>,</span> <span class=nx>r</span> <span class=o>*</span><span class=nx>http</span><span class=p>.</span><span class=nx>Request</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>header</span> <span class=o>:=</span> <span class=nx>r</span><span class=p>.</span><span class=nx>Header</span><span class=p>.</span><span class=nf>Get</span><span class=p>(</span><span class=s>&#34;Authorization&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>header</span> <span class=o>!=</span> <span class=nx>token</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>http</span><span class=p>.</span><span class=nf>Error</span><span class=p>(</span><span class=nx>w</span><span class=p>,</span> <span class=s>&#34;username/password not recognized&#34;</span><span class=p>,</span> <span class=nx>http</span><span class=p>.</span><span class=nx>StatusForbidden</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=nf>next</span><span class=p>(</span><span class=nx>w</span><span class=p>,</span> <span class=nx>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>final</span><span class=p>(</span><span class=nx>w</span> <span class=nx>http</span><span class=p>.</span><span class=nx>ResponseWriter</span><span class=p>,</span> <span class=nx>r</span> <span class=o>*</span><span class=nx>http</span><span class=p>.</span><span class=nx>Request</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>w</span><span class=p>.</span><span class=nf>Write</span><span class=p>([]</span><span class=nb>byte</span><span class=p>(</span><span class=s>&#34;Hello World!&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Create middleware
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>handler</span> <span class=o>:=</span> <span class=nf>logging</span><span class=p>(</span><span class=nf>authenticate</span><span class=p>(</span><span class=nx>username</span><span class=p>,</span> <span class=nx>password</span><span class=p>,</span> <span class=nx>final</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The closures allow us to easily construct handler-specific chains of http request handling that are intuitive and easily adaptible!</p><h2 id=wrap-up>Wrap-Up<a hidden class=anchor aria-hidden=true href=#wrap-up>#</a></h2><p>Strict typing helps programmers write safe and highly-performant code and language constructs like interfaces and closures help them write flexible code even with strict typing. Careful consideration of how to define interfaces and libraries that use closures can make working with Go libraries more productive and enjoyable!</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://bbengfort.github.io/2021/03/nonlinear-workflow-planning-software-projects/><span class=title>« Prev</span><br><span>Nonlinear Workflow for Planning Software Projects</span>
</a><a class=next href=https://bbengfort.github.io/2021/01/new-hugo-theme/><span class=title>Next »</span><br><span>New Hugo Theme</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://bbengfort.github.io/>Libelli</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>