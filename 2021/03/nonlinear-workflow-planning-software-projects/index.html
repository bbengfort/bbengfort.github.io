<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Nonlinear Workflow for Planning Software Projects | Libelli</title><meta name=keywords content><meta name=description content="Good software development achieves complexity by describing the interactions between simpler components. Although we tend to think of software processes as step-by-step &ldquo;wizards&rdquo;, design and decoupling of components often means that the interactions are non-linear. So why should our software project planning be defined in a linear progression of steps with time estimates? Can we plan projects using a non-linear workflow that mirrors how we think about component design?
The figure above is an experiment in task planning that I recently used to try to describe the complex dependencies between different tasks in a project."><meta name=author content="Benjamin Bengfort"><link rel=canonical href=https://bbengfort.github.io/2021/03/nonlinear-workflow-planning-software-projects/><link crossorigin=anonymous href=/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe+FVUFzPh7U=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://bbengfort.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://bbengfort.github.io/icon.png><link rel=icon type=image/png sizes=32x32 href=https://bbengfort.github.io/icon.png><link rel=apple-touch-icon href=https://bbengfort.github.io/apple-touch-icon-precomposed.png><link rel=mask-icon href=https://bbengfort.github.io/icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-8096804-11","auto"),ga("send","pageview"))</script><meta property="og:title" content="Nonlinear Workflow for Planning Software Projects"><meta property="og:description" content="Good software development achieves complexity by describing the interactions between simpler components. Although we tend to think of software processes as step-by-step &ldquo;wizards&rdquo;, design and decoupling of components often means that the interactions are non-linear. So why should our software project planning be defined in a linear progression of steps with time estimates? Can we plan projects using a non-linear workflow that mirrors how we think about component design?
The figure above is an experiment in task planning that I recently used to try to describe the complex dependencies between different tasks in a project."><meta property="og:type" content="article"><meta property="og:url" content="https://bbengfort.github.io/2021/03/nonlinear-workflow-planning-software-projects/"><meta property="og:image" content="https://bbengfort.github.io/bear.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-03-14T09:53:49-04:00"><meta property="article:modified_time" content="2021-03-14T09:53:49-04:00"><meta property="og:site_name" content="Libelli"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://bbengfort.github.io/bear.png"><meta name=twitter:title content="Nonlinear Workflow for Planning Software Projects"><meta name=twitter:description content="Good software development achieves complexity by describing the interactions between simpler components. Although we tend to think of software processes as step-by-step &ldquo;wizards&rdquo;, design and decoupling of components often means that the interactions are non-linear. So why should our software project planning be defined in a linear progression of steps with time estimates? Can we plan projects using a non-linear workflow that mirrors how we think about component design?
The figure above is an experiment in task planning that I recently used to try to describe the complex dependencies between different tasks in a project."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://bbengfort.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Nonlinear Workflow for Planning Software Projects","item":"https://bbengfort.github.io/2021/03/nonlinear-workflow-planning-software-projects/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Nonlinear Workflow for Planning Software Projects","name":"Nonlinear Workflow for Planning Software Projects","description":"Good software development achieves complexity by describing the interactions between simpler components. Although we tend to think of software processes as step-by-step \u0026ldquo;wizards\u0026rdquo;, design and decoupling of components often means that the interactions are non-linear. So why should our software project planning be defined in a linear progression of steps with time estimates? Can we plan projects using a non-linear workflow that mirrors how we think about component design?\nThe figure above is an experiment in task planning that I recently used to try to describe the complex dependencies between different tasks in a project.","keywords":[],"articleBody":"Good software development achieves complexity by describing the interactions between simpler components. Although we tend to think of software processes as step-by-step “wizards”, design and decoupling of components often means that the interactions are non-linear. So why should our software project planning be defined in a linear progression of steps with time estimates? Can we plan projects using a non-linear workflow that mirrors how we think about component design?\nThe figure above is an experiment in task planning that I recently used to try to describe the complex dependencies between different tasks in a project. On the left are a 2-level hierarchy of tasks that represent decomposition in the planning process - first major tasks are described, then subtasks for each major task can be planned out. Each task is assigned a level of work estimate - in this case using Fibonacci numbers, though I think t-shirt sizes would also work well. So far, so normal - the novelty comes from the Gantt-esque chart on the right.\nThe temporal chart shows blocks of time that corresponds to one unit of estimated work. If a task is estimated at 3 points, then it takes three blocks in the temporal chart. Unlike Gantt charts, however, the blocks of time do not represent clock or calendar time, but instead represent “happens before” relationships. E.g. in the green section, “Create schema for PostgreSQL database” and “Create manifests and deploy DB to staging” must be completed before “Add test data to the db (unblocks service implementation)”. Tasks that are coupled or related are also shown by overlapping time, e.g. “Create schema” and “Create manifests” are overlapping tasks - there is work that can be done in parallel between the schema and the manifests, but at some point the manifests need the schema in order to be complete.\nBy describing the relationships between tasks in this way, dependencies between tasks become quickly apparent without specifying a DAG or other relationship diagram. Tasks that can be completed in parallel allow team members to collaborate effectively, while overlapping tasks need the more focused effort of an individual contributor. Although this temporal chart seems to describe a waterfall of development effort - I believe that it’s flexibility lends itself to agile development workflows since these dependencies can make sprint planning simpler.\nConsider that in an agile software development workflow, requirements and tasks are added to a backlog, then during sprint planning, those tasks are prioritized and added to a discrete sprint. Dependencies between tasks are often described by “blockers”. This process works well for more mature projects where each task tends to be self-contained. However, I’ve observed two issues with this process: first, team-members tend to focus on their own projects and second, it’s very difficult to plan projects beyond a single sprint, particularly right at the beginning of a project. Instead, I envision more focused sprint planning where the only tasks that are considered are the tasks that are available at the point in the temporal flow chart at the time of the sprint, and as many tasks as there are points available in the sprint are collected into it.\nThere are some issues: dependencies between subtasks are easy to describe, but dependencies across subtasks in different major tasks are more difficult. To show this I’ve added “x” marks to dependent subtasks in across major tasks, but it would be better if the relationships across major tasks could be trusted. Also, if used in sprint planning, this temporal flow chart would have to be dynamic; showing the actual vs predicted relationships and able to add new major tasks and subtasks as the project continued.\nI think it would be interesting to prototype a planning tool that allowed you to easily add major tasks and subtasks with time estimates. Then by simply clicking on a block the time would be filled in. The major task would automatically be updated with the full estimate and the time window it’s in. Groups of tasks could be moved left or right together. This level of interactivity would make planning much more effective!\n","wordCount":"680","inLanguage":"en","datePublished":"2021-03-14T09:53:49-04:00","dateModified":"2021-03-14T09:53:49-04:00","author":{"@type":"Person","name":"Benjamin Bengfort"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://bbengfort.github.io/2021/03/nonlinear-workflow-planning-software-projects/"},"publisher":{"@type":"Organization","name":"Libelli","logo":{"@type":"ImageObject","url":"https://bbengfort.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bbengfort.github.io accesskey=h title="Libelli (Alt + H)"><img src=https://bbengfort.github.io/icon.png alt aria-label=logo height=35>Libelli</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://bbengfort.github.io/archive/ title=archive><span>archive</span></a></li><li><a href=https://bbengfort.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://bbengfort.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://bbengfort.github.io/about/ title=about><span>about</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://bbengfort.github.io>Home</a>&nbsp;»&nbsp;<a href=https://bbengfort.github.io/posts/>Posts</a></div><h1 class=post-title>Nonlinear Workflow for Planning Software Projects</h1><div class=post-meta><span title='2021-03-14 09:53:49 -0400 -0400'>March 14, 2021</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;680 words&nbsp;·&nbsp;Benjamin Bengfort&nbsp;|&nbsp;<a href=https://github.com/bbengfort/bbengfort.github.io/tree/main/content/posts/2021-03-14-nonlinear-workflow-planning.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>Good software development achieves complexity by describing the interactions between simpler components. Although we tend to think of software processes as step-by-step &ldquo;wizards&rdquo;, design and decoupling of components often means that the interactions are non-linear. So why should our software project planning be defined in a linear progression of steps with time estimates? Can we plan projects using a non-linear workflow that mirrors how we think about component design?</p><p><img loading=lazy src=/images/2021-03-14-blocks-dependencies.png alt="Blocks and Dependencies"></p><p>The figure above is an experiment in task planning that I recently used to try to describe the complex dependencies between different tasks in a project. On the left are a 2-level hierarchy of tasks that represent decomposition in the planning process - first major tasks are described, then subtasks for each major task can be planned out. Each task is assigned a level of work estimate - in this case using <a href=https://www.mountaingoatsoftware.com/blog/why-the-fibonacci-sequence-works-well-for-estimating>Fibonacci numbers</a>, though I think <a href=https://medium.com/serious-scrum/how-i-use-t-shirt-sizing-as-a-product-owner-to-estimate-delivery-4b24634d22a6>t-shirt sizes</a> would also work well. So far, so normal - the novelty comes from the Gantt-esque chart on the right.</p><p>The temporal chart shows blocks of time that corresponds to one unit of estimated work. If a task is estimated at 3 points, then it takes three blocks in the temporal chart. Unlike Gantt charts, however, the blocks of time do not represent clock or calendar time, but instead represent &ldquo;happens before&rdquo; relationships. E.g. in the green section, &ldquo;Create schema for PostgreSQL database&rdquo; and &ldquo;Create manifests and deploy DB to staging&rdquo; must be completed before &ldquo;Add test data to the db (unblocks service implementation)&rdquo;. Tasks that are coupled or related are also shown by overlapping time, e.g. &ldquo;Create schema&rdquo; and &ldquo;Create manifests&rdquo; are overlapping tasks - there is work that can be done in parallel between the schema and the manifests, but at some point the manifests need the schema in order to be complete.</p><p>By describing the relationships between tasks in this way, dependencies between tasks become quickly apparent without specifying a DAG or other relationship diagram. Tasks that can be completed in parallel allow team members to collaborate effectively, while overlapping tasks need the more focused effort of an individual contributor. Although this temporal chart seems to describe a waterfall of development effort - I believe that it&rsquo;s flexibility lends itself to agile development workflows since these dependencies can make sprint planning simpler.</p><p>Consider that in an agile software development workflow, requirements and tasks are added to a backlog, then during sprint planning, those tasks are prioritized and added to a discrete sprint. Dependencies between tasks are often described by &ldquo;blockers&rdquo;. This process works well for more mature projects where each task tends to be self-contained. However, I&rsquo;ve observed two issues with this process: first, team-members tend to focus on their own projects and second, it&rsquo;s very difficult to plan projects beyond a single sprint, particularly right at the beginning of a project. Instead, I envision more focused sprint planning where the only tasks that are considered are the tasks that are available at the point in the temporal flow chart at the time of the sprint, and as many tasks as there are points available in the sprint are collected into it.</p><p>There are some issues: dependencies between subtasks are easy to describe, but dependencies across subtasks in different major tasks are more difficult. To show this I&rsquo;ve added &ldquo;x&rdquo; marks to dependent subtasks in across major tasks, but it would be better if the relationships across major tasks could be trusted. Also, if used in sprint planning, this temporal flow chart would have to be dynamic; showing the actual vs predicted relationships and able to add new major tasks and subtasks as the project continued.</p><p>I think it would be interesting to prototype a planning tool that allowed you to easily add major tasks and subtasks with time estimates. Then by simply clicking on a block the time would be filled in. The major task would automatically be updated with the full estimate and the time window it&rsquo;s in. Groups of tasks could be moved left or right together. This level of interactivity would make planning much more effective!</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://bbengfort.github.io/2022/11/atomic-vs-mutex/><span class=title>« Prev</span><br><span>Atomic vs Mutex</span></a>
<a class=next href=https://bbengfort.github.io/2021/02/go-closures-interfaces/><span class=title>Next »</span><br><span>Go Closures & Interfaces</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://bbengfort.github.io>Libelli</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>