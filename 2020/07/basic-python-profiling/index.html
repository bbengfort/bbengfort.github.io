<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Basic Python Profiling | Libelli</title><meta name=keywords content><meta name=description content="I&rsquo;m getting started on some projects that will make use of extensive Python performance profiling, unfortunately Python doesn&rsquo;t focus on performance and so doesn&rsquo;t have benchmark tools like I might find in Go. I&rsquo;ve noticed that the two most important usages I&rsquo;m looking at when profiling are speed and memory usage. For the latter, I simply use memory_profiler from the command line - which is pretty straight forward. However for speed usage, I did find a snippet that I thought would be useful to include and update depending on how my usage changes."><meta name=author content="Benjamin Bengfort"><link rel=canonical href=https://bbengfort.github.io/2020/07/basic-python-profiling/><link crossorigin=anonymous href=/assets/css/stylesheet.min.d0c0348c2d0cff14148d0e347258519d8df2ce53ce5ac32c7bd9a549182cb8ae.css integrity="sha256-0MA0jC0M/xQUjQ40clhRnY3yzlPOWsMse9mlSRgsuK4=" rel="preload stylesheet" as=style><link rel=preload href=/icon.png as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><link rel=icon href=https://bbengfort.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://bbengfort.github.io/icon.png><link rel=icon type=image/png sizes=32x32 href=https://bbengfort.github.io/icon.png><link rel=apple-touch-icon href=https://bbengfort.github.io/apple-touch-icon-precomposed.png><link rel=mask-icon href=https://bbengfort.github.io/icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.79.0"><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-8096804-11','auto');ga('send','pageview');}</script><meta property="og:title" content="Basic Python Profiling"><meta property="og:description" content="I&rsquo;m getting started on some projects that will make use of extensive Python performance profiling, unfortunately Python doesn&rsquo;t focus on performance and so doesn&rsquo;t have benchmark tools like I might find in Go. I&rsquo;ve noticed that the two most important usages I&rsquo;m looking at when profiling are speed and memory usage. For the latter, I simply use memory_profiler from the command line - which is pretty straight forward. However for speed usage, I did find a snippet that I thought would be useful to include and update depending on how my usage changes."><meta property="og:type" content="article"><meta property="og:url" content="https://bbengfort.github.io/2020/07/basic-python-profiling/"><meta property="og:image" content="https://bbengfort.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-07-14T18:01:08+00:00"><meta property="article:modified_time" content="2020-07-14T18:01:08+00:00"><meta property="og:site_name" content="Libelli"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://bbengfort.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Basic Python Profiling"><meta name=twitter:description content="I&rsquo;m getting started on some projects that will make use of extensive Python performance profiling, unfortunately Python doesn&rsquo;t focus on performance and so doesn&rsquo;t have benchmark tools like I might find in Go. I&rsquo;ve noticed that the two most important usages I&rsquo;m looking at when profiling are speed and memory usage. For the latter, I simply use memory_profiler from the command line - which is pretty straight forward. However for speed usage, I did find a snippet that I thought would be useful to include and update depending on how my usage changes."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://bbengfort.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Basic Python Profiling","item":"https://bbengfort.github.io/2020/07/basic-python-profiling/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Basic Python Profiling","name":"Basic Python Profiling","description":"I\u0026rsquo;m getting started on some projects that will make use of extensive Python performance profiling, unfortunately Python doesn\u0026rsquo;t focus on performance and so doesn\u0026rsquo;t have benchmark tools like I might find in Go. I\u0026rsquo;ve noticed that the two most important usages I\u0026rsquo;m looking at when profiling are speed and memory usage. For the latter, I simply use memory_profiler from the command line - which is pretty straight forward. However for speed usage, I did find a snippet that I thought would be useful to include and update depending on how my usage changes.","keywords":[],"articleBody":"I’m getting started on some projects that will make use of extensive Python performance profiling, unfortunately Python doesn’t focus on performance and so doesn’t have benchmark tools like I might find in Go. I’ve noticed that the two most important usages I’m looking at when profiling are speed and memory usage. For the latter, I simply use memory_profiler from the command line - which is pretty straight forward. However for speed usage, I did find a snippet that I thought would be useful to include and update depending on how my usage changes.\nimport cProfile from pstats import Stats from functools import wraps def sprofile(func): @wraps(func) def wrapper(*args, **kwargs): pr = cProfile.Profile() pr.enable() result = func(*args, **kwargs) pr.disable() Stats(pr).strip_dirs().sort_stats('cumulative').print_stats(20) return result return wrapper This decorator allows you to profile the speed performance of functions on the stack below the function being decorated. It uses standard library dependencies, which is great, and you can change the way the stats are printed out to suit your needs (e.g. this is formatted well for my analysis style).\nThe report it prints out is as follows:\n 7636523 function calls (7636479 primitive calls) in 14.669 seconds Ordered by: cumulative time List reduced from 306 to 20 due to restriction  ncalls tottime percall cumtime percall filename:lineno(function) 1 0.000 0.000 14.669 14.669 sequential.py:107(run) 150 2.584 0.017 14.633 0.098 sequential.py:75(step) 843750 10.228 0.000 10.335 0.000 grid.py:72(neighborhood_sum) 843750 0.765 0.000 0.988 0.000 grid.py:129(__setitem__) 843750 0.529 0.000 0.726 0.000 grid.py:124(__getitem__) 2531454 0.275 0.000 0.275 0.000 {built-in method builtins.isinstance} 1687783 0.145 0.000 0.145 0.000 {built-in method builtins.len} 843750 0.107 0.000 0.107 0.000 grid.py:57(adjacency) 151 0.001 0.000 0.020 0.000 std.py:1099(__iter__) 82 0.000 0.000 0.019 0.000 std.py:1317(refresh) 83 0.000 0.000 0.017 0.000 std.py:1447(display) 83 0.000 0.000 0.015 0.000 std.py:1089(__repr__) 9/4 0.000 0.000 0.014 0.004 :978(_find_and_load) 9/4 0.000 0.000 0.014 0.004 :948(_find_and_load_unlocked) 83 0.002 0.000 0.014 0.000 std.py:310(format_meter) 9/4 0.000 0.000 0.013 0.003 :663(_load_unlocked) 17/6 0.000 0.000 0.011 0.002 :211(_call_with_frames_removed) 1 0.000 0.000 0.010 0.010 std.py:511(__new__) 1 0.000 0.000 0.009 0.009 std.py:623(get_lock) 1 0.000 0.000 0.009 0.009 std.py:79(__init__) You can see in this report that the majority of time is being spent in the neighborhood_sum function from line 3 and that the step function calls it nearly 5,625 times!\n","wordCount":"370","inLanguage":"en","datePublished":"2020-07-14T18:01:08Z","dateModified":"2020-07-14T18:01:08Z","author":{"@type":"Person","name":"Benjamin Bengfort"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://bbengfort.github.io/2020/07/basic-python-profiling/"},"publisher":{"@type":"Organization","name":"Libelli","logo":{"@type":"ImageObject","url":"https://bbengfort.github.io/favicon.ico"}}}</script></head><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme: #1d1e20;--entry: #2e2e33;--primary: rgba(255, 255, 255, 0.84);--secondary: rgba(255, 255, 255, 0.56);--tertiary: rgba(255, 255, 255, 0.16);--content: rgba(255, 255, 255, 0.74);--hljs-bg: #2e2e33;--code-bg: #37383e;--border: #333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://bbengfort.github.io accesskey=h title="Libelli (Alt + H)"><img src=/icon.png alt=logo aria-label=logo height=35>Libelli</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://bbengfort.github.io/archive/ title=archive><span>archive</span></a></li><li><a href=https://bbengfort.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://bbengfort.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://bbengfort.github.io/about/ title=about><span>about</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Basic Python Profiling</h1><div class=post-meta>July 14, 2020&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Benjamin Bengfort</div></header><div class=post-content><p>I&rsquo;m getting started on some projects that will make use of extensive Python performance profiling, unfortunately Python doesn&rsquo;t focus on performance and so doesn&rsquo;t have benchmark tools like I might find in Go. I&rsquo;ve noticed that the two most important usages I&rsquo;m looking at when profiling are speed and memory usage. For the latter, I simply use <a href=https://pypi.org/project/memory-profiler/><code>memory_profiler</code></a> from the command line - which is pretty straight forward. However for speed usage, I did find a snippet that I thought would be useful to include and update depending on how my usage changes.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#f92672>import</span> cProfile

<span style=color:#f92672>from</span> pstats <span style=color:#f92672>import</span> Stats
<span style=color:#f92672>from</span> functools <span style=color:#f92672>import</span> wraps


<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>sprofile</span>(func):
    <span style=color:#a6e22e>@wraps</span>(func)
    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>wrapper</span>(<span style=color:#f92672>*</span>args, <span style=color:#f92672>**</span>kwargs):
        pr <span style=color:#f92672>=</span> cProfile<span style=color:#f92672>.</span>Profile()
        pr<span style=color:#f92672>.</span>enable()

        result <span style=color:#f92672>=</span> func(<span style=color:#f92672>*</span>args, <span style=color:#f92672>**</span>kwargs)

        pr<span style=color:#f92672>.</span>disable()
        Stats(pr)<span style=color:#f92672>.</span>strip_dirs()<span style=color:#f92672>.</span>sort_stats(<span style=color:#e6db74>&#39;cumulative&#39;</span>)<span style=color:#f92672>.</span>print_stats(<span style=color:#ae81ff>20</span>)
        <span style=color:#66d9ef>return</span> result

    <span style=color:#66d9ef>return</span> wrapper
</code></pre></div><p>This decorator allows you to profile the speed performance of functions on the stack below the function being decorated. It uses standard library dependencies, which is great, and you can <a href=https://docs.python.org/3.7/library/profile.html#module-pstats>change the way the stats are printed out</a> to suit your needs (e.g. this is formatted well for my analysis style).</p><p>The report it prints out is as follows:</p><pre><code>        7636523 function calls (7636479 primitive calls) in 14.669 seconds

   Ordered by: cumulative time
   List reduced from 306 to 20 due to restriction &lt;20&gt;

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.000    0.000   14.669   14.669 sequential.py:107(run)
      150    2.584    0.017   14.633    0.098 sequential.py:75(step)
   843750   10.228    0.000   10.335    0.000 grid.py:72(neighborhood_sum)
   843750    0.765    0.000    0.988    0.000 grid.py:129(__setitem__)
   843750    0.529    0.000    0.726    0.000 grid.py:124(__getitem__)
  2531454    0.275    0.000    0.275    0.000 {built-in method builtins.isinstance}
  1687783    0.145    0.000    0.145    0.000 {built-in method builtins.len}
   843750    0.107    0.000    0.107    0.000 grid.py:57(adjacency)
      151    0.001    0.000    0.020    0.000 std.py:1099(__iter__)
       82    0.000    0.000    0.019    0.000 std.py:1317(refresh)
       83    0.000    0.000    0.017    0.000 std.py:1447(display)
       83    0.000    0.000    0.015    0.000 std.py:1089(__repr__)
      9/4    0.000    0.000    0.014    0.004 &lt;frozen importlib._bootstrap&gt;:978(_find_and_load)
      9/4    0.000    0.000    0.014    0.004 &lt;frozen importlib._bootstrap&gt;:948(_find_and_load_unlocked)
       83    0.002    0.000    0.014    0.000 std.py:310(format_meter)
      9/4    0.000    0.000    0.013    0.003 &lt;frozen importlib._bootstrap&gt;:663(_load_unlocked)
     17/6    0.000    0.000    0.011    0.002 &lt;frozen importlib._bootstrap&gt;:211(_call_with_frames_removed)
        1    0.000    0.000    0.010    0.010 std.py:511(__new__)
        1    0.000    0.000    0.009    0.009 std.py:623(get_lock)
        1    0.000    0.000    0.009    0.009 std.py:79(__init__)
</code></pre><p>You can see in this report that the majority of time is being spent in the <code>neighborhood_sum</code> function from line 3 and that the <code>step</code> function calls it nearly 5,625 times!</p></div><footer class=post-footer></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://bbengfort.github.io>Libelli</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById('menu')
menu.scrollLeft=localStorage.getItem("menu-scroll-position");menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft);}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);if(!window.matchMedia('(prefers-reduced-motion: reduce)').matches){document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});}else{document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();}
if(id==="top"){history.replaceState(null,null," ");}else{history.pushState(null,null,`#${id}`);}});});</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script></body></html>