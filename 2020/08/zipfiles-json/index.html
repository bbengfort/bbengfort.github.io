<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Writing JSON into a Zip file with Python | Libelli</title><meta name=keywords content><meta name=description content="For scientific reproducibility, it has become common for me to output experimental results as zip files that contain both configurations and inputs as well as one or more output results files. This is similar to .epub or .docx formats which are just specialized zip files - and allows me to easily rerun experiments for comparison purposes. Recently I tried to dump some json data into a zip file using Python 3."><meta name=author content="Benjamin Bengfort"><link rel=canonical href=https://bbengfort.github.io/2020/08/zipfiles-json/><link crossorigin=anonymous href=/assets/css/stylesheet.min.d0c0348c2d0cff14148d0e347258519d8df2ce53ce5ac32c7bd9a549182cb8ae.css integrity="sha256-0MA0jC0M/xQUjQ40clhRnY3yzlPOWsMse9mlSRgsuK4=" rel="preload stylesheet" as=style><link rel=preload href=/icon.png as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><link rel=icon href=https://bbengfort.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://bbengfort.github.io/icon.png><link rel=icon type=image/png sizes=32x32 href=https://bbengfort.github.io/icon.png><link rel=apple-touch-icon href=https://bbengfort.github.io/apple-touch-icon-precomposed.png><link rel=mask-icon href=https://bbengfort.github.io/icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.79.0"><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-8096804-11','auto');ga('send','pageview');}</script><meta property="og:title" content="Writing JSON into a Zip file with Python"><meta property="og:description" content="For scientific reproducibility, it has become common for me to output experimental results as zip files that contain both configurations and inputs as well as one or more output results files. This is similar to .epub or .docx formats which are just specialized zip files - and allows me to easily rerun experiments for comparison purposes. Recently I tried to dump some json data into a zip file using Python 3."><meta property="og:type" content="article"><meta property="og:url" content="https://bbengfort.github.io/2020/08/zipfiles-json/"><meta property="og:image" content="https://bbengfort.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-08-20T11:41:14+00:00"><meta property="article:modified_time" content="2020-08-20T11:41:14+00:00"><meta property="og:site_name" content="Libelli"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://bbengfort.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Writing JSON into a Zip file with Python"><meta name=twitter:description content="For scientific reproducibility, it has become common for me to output experimental results as zip files that contain both configurations and inputs as well as one or more output results files. This is similar to .epub or .docx formats which are just specialized zip files - and allows me to easily rerun experiments for comparison purposes. Recently I tried to dump some json data into a zip file using Python 3."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://bbengfort.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Writing JSON into a Zip file with Python","item":"https://bbengfort.github.io/2020/08/zipfiles-json/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Writing JSON into a Zip file with Python","name":"Writing JSON into a Zip file with Python","description":"For scientific reproducibility, it has become common for me to output experimental results as zip files that contain both configurations and inputs as well as one or more output results files. This is similar to .epub or .docx formats which are just specialized zip files - and allows me to easily rerun experiments for comparison purposes. Recently I tried to dump some json data into a zip file using Python 3.","keywords":[],"articleBody":"For scientific reproducibility, it has become common for me to output experimental results as zip files that contain both configurations and inputs as well as one or more output results files. This is similar to .epub or .docx formats which are just specialized zip files - and allows me to easily rerun experiments for comparison purposes. Recently I tried to dump some json data into a zip file using Python 3.8 and was surprised when the code errored as it seemed pretty standard. This is the story of the crazy loophole that I had to go into as a result.\nFirst off, here is the code that didn’t work:\ndef make_archive_bad(path=\"test.zip\"): with zipfile.ZipFile(path, \"x\") as z: with z.open(\"config.json\", \"w\") as c: # This doesn't work json.dump(config, c, indent=2) with z.open(\"data.json\", \"w\") as d: for row in data(config): # This doesn't work d.write(json.dumps(row)) d.write(\"\\n\") The exception is located in the interaction between json.dump and zipfile._ZipWriteFile.write as you can see in the traceback below.\n File \"./zipr.py\", line 144, in  make_archive_bad() File \"./zipr.py\", line 32, in make_archive_bad json.dump(config, c, indent=2) File \"3.7/lib/python3.7/json/__init__.py\", line 180, in dump fp.write(chunk) File \"3.7/lib/python3.7/zipfile.py\", line 1094, in write self._crc = crc32(data, self._crc) TypeError: a bytes-like object is required, not 'str'  The json module always produces str objects, not bytes objects. Therefore, fp.write() must support str input.\n— json documentation\n So the issue is really with the zipfile library and to make it work, you’ll have to json.dumps and then encode your data yourself. Which is annoying:\ndef make_archive_annoying(path=\"test.zip\"): # This does work but is annoying # Also note, this will write to the root of the archive, and when unzipped will not # unzip to a directory but rather into the same directory as the zip file with zipfile.ZipFile(path, \"x\") as z: with z.open(\"config.json\", \"w\") as c: c.write(json.dumps(config, indent=2).encode(\"utf-8\")) with z.open(\"data.json\", \"w\") as d: for row in data(config): d.write(json.dumps(row).encode(\"utf-8\")) d.write(\"\\n\".encode(\"utf-8\")) For 99% of people, the above solution is the way to go. However, as soon as I realized that this was also going to write into the root of the zip file so that when you extract the contents they are in the same directory as the zip file instead of a subdirectory … I went a little overboard. So here is a solution that is not annoying but requires some wrapper utility code in your library.\nI’m sorry.\nclass Zipr(object): def __enter__(self): # Makes this thing a context manager return self def __exit__(self, exc_type, exc_value, traceback): # Makes this thing a context manager self.close() def close(self): self.zobj.close() class ZipArchive(Zipr): def __init__(self, path, mode=\"r\"): self.zobj = zipfile.ZipFile( path, mode, compression=zipfile.ZIP_STORED, allowZip64=True, compresslevel=None ) self.root, _ = os.path.splitext(os.path.basename(path)) def open(self, path, mode='r'): # Write into a directory instead of the root of the zip file path = os.path.join(self.root, path) return ZipArchiveFile(self.zobj.open(path, mode)) class ZipArchiveFile(Zipr): def __init__(self, zobj, encoding=\"utf-8\"): self.zobj = zobj self.encoding = encoding def write(self, data): if isinstance(data, str): data = data.encode(self.encoding) self.zobj.write(data) These classes are essentially just wrappers for ZipFile and _ZipWriteFile, so potentially it would just be easier to subclass these files and and override the open and write methods - but I’ll leave that to the reader to make a decision. This is enough to have less annoying code:\ndef make_archive(path=\"test.zip\"): # Less annoying make archive with workaround classes with ZipArchive(path, \"x\") as z: with z.open(\"config.json\", \"w\") as c: json.dump(config, c, indent=2) with z.open(\"data.json\", \"w\") as d: for row in data(config): d.write(json.dumps(row)) d.write(\"\\n\") There are still issues, however. For example append ('a') mode does not work with _ZipWriteFile, so if you try to stream data by opening for appending, you’ll run into issues. See below:\ndef make_archive_stream(path=\"test.zip\"): # Attempts to open the internal zip file for appending, to stream data in. # But this doesn't work because you can't open an internal zip object for appending with ZipArchive(path, \"x\") as z: with z.open(\"config.json\", \"w\") as c: json.dump(config, c, indent=2) cache = [] for i, row in enumerate(data(config)): cache.append(json.dumps(row)) # dump cache every 5 rows if i%5 == 0: with z.open(\"data.json\", \"a\") as d: for row in cache: d.write(row+\"\\n\") cache = [] if len(cache)  0: with z.open(\"data.json\", \"a\") as d: for row in cache: d.write(row+\"\\n\") The full code can be found on this gist.\n","wordCount":"700","inLanguage":"en","datePublished":"2020-08-20T11:41:14Z","dateModified":"2020-08-20T11:41:14Z","author":{"@type":"Person","name":"Benjamin Bengfort"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://bbengfort.github.io/2020/08/zipfiles-json/"},"publisher":{"@type":"Organization","name":"Libelli","logo":{"@type":"ImageObject","url":"https://bbengfort.github.io/favicon.ico"}}}</script></head><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme: #1d1e20;--entry: #2e2e33;--primary: rgba(255, 255, 255, 0.84);--secondary: rgba(255, 255, 255, 0.56);--tertiary: rgba(255, 255, 255, 0.16);--content: rgba(255, 255, 255, 0.74);--hljs-bg: #2e2e33;--code-bg: #37383e;--border: #333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://bbengfort.github.io accesskey=h title="Libelli (Alt + H)"><img src=/icon.png alt=logo aria-label=logo height=35>Libelli</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://bbengfort.github.io/archive/ title=archive><span>archive</span></a></li><li><a href=https://bbengfort.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://bbengfort.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://bbengfort.github.io/about/ title=about><span>about</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Writing JSON into a Zip file with Python</h1><div class=post-meta>August 20, 2020&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Benjamin Bengfort</div></header><div class=post-content><p>For scientific reproducibility, it has become common for me to output experimental results as zip files that contain both configurations and inputs as well as one or more output results files. This is similar to .epub or .docx formats which are just specialized zip files - and allows me to easily rerun experiments for comparison purposes. Recently I tried to dump some json data into a zip file using Python 3.8 and was surprised when the code errored as it seemed pretty standard. This is the story of the crazy loophole that I had to go into as a result.</p><p>First off, here is the code that didn&rsquo;t work:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>make_archive_bad</span>(path<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;test.zip&#34;</span>):
    <span style=color:#66d9ef>with</span> zipfile<span style=color:#f92672>.</span>ZipFile(path, <span style=color:#e6db74>&#34;x&#34;</span>) <span style=color:#66d9ef>as</span> z:
        <span style=color:#66d9ef>with</span> z<span style=color:#f92672>.</span>open(<span style=color:#e6db74>&#34;config.json&#34;</span>, <span style=color:#e6db74>&#34;w&#34;</span>) <span style=color:#66d9ef>as</span> c:
            <span style=color:#75715e># This doesn&#39;t work</span>
            json<span style=color:#f92672>.</span>dump(config, c, indent<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>)

        <span style=color:#66d9ef>with</span> z<span style=color:#f92672>.</span>open(<span style=color:#e6db74>&#34;data.json&#34;</span>, <span style=color:#e6db74>&#34;w&#34;</span>) <span style=color:#66d9ef>as</span> d:
            <span style=color:#66d9ef>for</span> row <span style=color:#f92672>in</span> data(config):
                <span style=color:#75715e># This doesn&#39;t work</span>
                d<span style=color:#f92672>.</span>write(json<span style=color:#f92672>.</span>dumps(row))
                d<span style=color:#f92672>.</span>write(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>)
</code></pre></div><p>The exception is located in the interaction between <code>json.dump</code> and <code>zipfile._ZipWriteFile.write</code> as you can see in the traceback below.</p><pre><code>  File &quot;./zipr.py&quot;, line 144, in &lt;module&gt;
    make_archive_bad()
  File &quot;./zipr.py&quot;, line 32, in make_archive_bad
    json.dump(config, c, indent=2)
  File &quot;3.7/lib/python3.7/json/__init__.py&quot;, line 180, in dump
    fp.write(chunk)
  File &quot;3.7/lib/python3.7/zipfile.py&quot;, line 1094, in write
    self._crc = crc32(data, self._crc)
TypeError: a bytes-like object is required, not 'str'
</code></pre><blockquote><p>The json module always produces str objects, not bytes objects. Therefore, fp.write() must support str input.</p><p>— <a href=https://docs.python.org/3/library/json.html#basic-usage>json documentation</a></p></blockquote><p>So the issue is really with the zipfile library and to make it work, you&rsquo;ll have to <code>json.dumps</code> and then encode your data yourself. Which is annoying:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>make_archive_annoying</span>(path<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;test.zip&#34;</span>):
    <span style=color:#75715e># This does work but is annoying</span>
    <span style=color:#75715e># Also note, this will write to the root of the archive, and when unzipped will not</span>
    <span style=color:#75715e># unzip to a directory but rather into the same directory as the zip file</span>
    <span style=color:#66d9ef>with</span> zipfile<span style=color:#f92672>.</span>ZipFile(path, <span style=color:#e6db74>&#34;x&#34;</span>) <span style=color:#66d9ef>as</span> z:
        <span style=color:#66d9ef>with</span> z<span style=color:#f92672>.</span>open(<span style=color:#e6db74>&#34;config.json&#34;</span>, <span style=color:#e6db74>&#34;w&#34;</span>) <span style=color:#66d9ef>as</span> c:
            c<span style=color:#f92672>.</span>write(json<span style=color:#f92672>.</span>dumps(config, indent<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>)<span style=color:#f92672>.</span>encode(<span style=color:#e6db74>&#34;utf-8&#34;</span>))

        <span style=color:#66d9ef>with</span> z<span style=color:#f92672>.</span>open(<span style=color:#e6db74>&#34;data.json&#34;</span>, <span style=color:#e6db74>&#34;w&#34;</span>) <span style=color:#66d9ef>as</span> d:
            <span style=color:#66d9ef>for</span> row <span style=color:#f92672>in</span> data(config):
                d<span style=color:#f92672>.</span>write(json<span style=color:#f92672>.</span>dumps(row)<span style=color:#f92672>.</span>encode(<span style=color:#e6db74>&#34;utf-8&#34;</span>))
                d<span style=color:#f92672>.</span>write(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span><span style=color:#f92672>.</span>encode(<span style=color:#e6db74>&#34;utf-8&#34;</span>))
</code></pre></div><p>For 99% of people, the above solution is the way to go. However, as soon as I realized that this was also going to write into the root of the zip file so that when you extract the contents they are in the same directory as the zip file instead of a subdirectory &mldr; I went a little overboard. So here is a solution that is not annoying but requires some wrapper utility code in your library.</p><p>I&rsquo;m sorry.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Zipr</span>(object):

    <span style=color:#66d9ef>def</span> __enter__(self):
        <span style=color:#75715e># Makes this thing a context manager</span>
        <span style=color:#66d9ef>return</span> self

    <span style=color:#66d9ef>def</span> __exit__(self, exc_type, exc_value, traceback):
        <span style=color:#75715e># Makes this thing a context manager</span>
        self<span style=color:#f92672>.</span>close()

    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>close</span>(self):
        self<span style=color:#f92672>.</span>zobj<span style=color:#f92672>.</span>close()


<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ZipArchive</span>(Zipr):

    <span style=color:#66d9ef>def</span> __init__(self, path, mode<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;r&#34;</span>):
        self<span style=color:#f92672>.</span>zobj <span style=color:#f92672>=</span> zipfile<span style=color:#f92672>.</span>ZipFile(
            path, mode, compression<span style=color:#f92672>=</span>zipfile<span style=color:#f92672>.</span>ZIP_STORED,
            allowZip64<span style=color:#f92672>=</span>True, compresslevel<span style=color:#f92672>=</span>None
        )
        self<span style=color:#f92672>.</span>root, _ <span style=color:#f92672>=</span> os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>splitext(os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>basename(path))

    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>open</span>(self, path, mode<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;r&#39;</span>):
        <span style=color:#75715e># Write into a directory instead of the root of the zip file</span>
        path <span style=color:#f92672>=</span> os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>join(self<span style=color:#f92672>.</span>root, path)
        <span style=color:#66d9ef>return</span> ZipArchiveFile(self<span style=color:#f92672>.</span>zobj<span style=color:#f92672>.</span>open(path, mode))


<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ZipArchiveFile</span>(Zipr):

    <span style=color:#66d9ef>def</span> __init__(self, zobj, encoding<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;utf-8&#34;</span>):
        self<span style=color:#f92672>.</span>zobj <span style=color:#f92672>=</span> zobj
        self<span style=color:#f92672>.</span>encoding <span style=color:#f92672>=</span> encoding

    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>write</span>(self, data):
        <span style=color:#66d9ef>if</span> isinstance(data, str):
            data <span style=color:#f92672>=</span> data<span style=color:#f92672>.</span>encode(self<span style=color:#f92672>.</span>encoding)
        self<span style=color:#f92672>.</span>zobj<span style=color:#f92672>.</span>write(data)
</code></pre></div><p>These classes are essentially just wrappers for <code>ZipFile</code> and <code>_ZipWriteFile</code>, so potentially it would just be easier to subclass these files and and override the <code>open</code> and <code>write</code> methods - but I&rsquo;ll leave that to the reader to make a decision. This is enough to have less annoying code:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>make_archive</span>(path<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;test.zip&#34;</span>):
    <span style=color:#75715e># Less annoying make archive with workaround classes</span>
    <span style=color:#66d9ef>with</span> ZipArchive(path, <span style=color:#e6db74>&#34;x&#34;</span>) <span style=color:#66d9ef>as</span> z:
        <span style=color:#66d9ef>with</span> z<span style=color:#f92672>.</span>open(<span style=color:#e6db74>&#34;config.json&#34;</span>, <span style=color:#e6db74>&#34;w&#34;</span>) <span style=color:#66d9ef>as</span> c:
            json<span style=color:#f92672>.</span>dump(config, c, indent<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>)

        <span style=color:#66d9ef>with</span> z<span style=color:#f92672>.</span>open(<span style=color:#e6db74>&#34;data.json&#34;</span>, <span style=color:#e6db74>&#34;w&#34;</span>) <span style=color:#66d9ef>as</span> d:
            <span style=color:#66d9ef>for</span> row <span style=color:#f92672>in</span> data(config):
                d<span style=color:#f92672>.</span>write(json<span style=color:#f92672>.</span>dumps(row))
                d<span style=color:#f92672>.</span>write(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>)
</code></pre></div><p>There are still issues, however. For example append (<code>'a'</code>) mode does not work with <code>_ZipWriteFile</code>, so if you try to stream data by opening for appending, you&rsquo;ll run into issues. See below:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>make_archive_stream</span>(path<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;test.zip&#34;</span>):
    <span style=color:#75715e># Attempts to open the internal zip file for appending, to stream data in.</span>
    <span style=color:#75715e># But this doesn&#39;t work because you can&#39;t open an internal zip object for appending</span>
    <span style=color:#66d9ef>with</span> ZipArchive(path, <span style=color:#e6db74>&#34;x&#34;</span>) <span style=color:#66d9ef>as</span> z:
        <span style=color:#66d9ef>with</span> z<span style=color:#f92672>.</span>open(<span style=color:#e6db74>&#34;config.json&#34;</span>, <span style=color:#e6db74>&#34;w&#34;</span>) <span style=color:#66d9ef>as</span> c:
            json<span style=color:#f92672>.</span>dump(config, c, indent<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>)

        cache <span style=color:#f92672>=</span> []
        <span style=color:#66d9ef>for</span> i, row <span style=color:#f92672>in</span> enumerate(data(config)):
            cache<span style=color:#f92672>.</span>append(json<span style=color:#f92672>.</span>dumps(row))

            <span style=color:#75715e># dump cache every 5 rows</span>
            <span style=color:#66d9ef>if</span> i<span style=color:#f92672>%</span><span style=color:#ae81ff>5</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
                <span style=color:#66d9ef>with</span> z<span style=color:#f92672>.</span>open(<span style=color:#e6db74>&#34;data.json&#34;</span>, <span style=color:#e6db74>&#34;a&#34;</span>) <span style=color:#66d9ef>as</span> d:
                    <span style=color:#66d9ef>for</span> row <span style=color:#f92672>in</span> cache:
                        d<span style=color:#f92672>.</span>write(row<span style=color:#f92672>+</span><span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>)
                cache <span style=color:#f92672>=</span> []

        <span style=color:#66d9ef>if</span> len(cache) <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>:
            <span style=color:#66d9ef>with</span> z<span style=color:#f92672>.</span>open(<span style=color:#e6db74>&#34;data.json&#34;</span>, <span style=color:#e6db74>&#34;a&#34;</span>) <span style=color:#66d9ef>as</span> d:
                <span style=color:#66d9ef>for</span> row <span style=color:#f92672>in</span> cache:
                    d<span style=color:#f92672>.</span>write(row<span style=color:#f92672>+</span><span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>)
</code></pre></div><p>The full code can be found on <a href=https://gist.github.com/bbengfort/73c142188085e6b417b49d3897fa7d24>this gist</a>.</p></div><footer class=post-footer></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://bbengfort.github.io>Libelli</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById('menu')
menu.scrollLeft=localStorage.getItem("menu-scroll-position");menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft);}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);if(!window.matchMedia('(prefers-reduced-motion: reduce)').matches){document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});}else{document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();}
if(id==="top"){history.replaceState(null,null," ");}else{history.pushState(null,null,`#${id}`);}});});</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script></body></html>