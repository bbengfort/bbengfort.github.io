<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Managing Multi-Errors in Go | Libelli</title>
<meta name=keywords content><meta name=description content="This post is a response to Go: Multiple Errors Management. I&rsquo;ve dealt with a multiple error contexts in a few places in my Go code but never created a subpackage for it in github.com/bbengfort/x and so I thought this post was a good motivation to explore it in slightly more detail. I&rsquo;d also like to make error contexts for routine cancellation a part of my standard programming practice, so this post also investigates multiple error handling in a single routine or multiple routines like the original post."><meta name=author content="Benjamin Bengfort"><link rel=canonical href=https://bbengfort.github.io/2020/10/go-multiple-errors/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://bbengfort.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://bbengfort.github.io/icon.png><link rel=icon type=image/png sizes=32x32 href=https://bbengfort.github.io/icon.png><link rel=apple-touch-icon href=https://bbengfort.github.io/apple-touch-icon-precomposed.png><link rel=mask-icon href=https://bbengfort.github.io/icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://bbengfort.github.io/2020/10/go-multiple-errors/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-D3BE7EHHVP"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-D3BE7EHHVP")}</script><meta property="og:title" content="Managing Multi-Errors in Go"><meta property="og:description" content="This post is a response to Go: Multiple Errors Management. I&rsquo;ve dealt with a multiple error contexts in a few places in my Go code but never created a subpackage for it in github.com/bbengfort/x and so I thought this post was a good motivation to explore it in slightly more detail. I&rsquo;d also like to make error contexts for routine cancellation a part of my standard programming practice, so this post also investigates multiple error handling in a single routine or multiple routines like the original post."><meta property="og:type" content="article"><meta property="og:url" content="https://bbengfort.github.io/2020/10/go-multiple-errors/"><meta property="og:image" content="https://bbengfort.github.io/bear.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-10-22T11:45:41+00:00"><meta property="article:modified_time" content="2020-10-22T11:45:41+00:00"><meta property="og:site_name" content="Libelli"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://bbengfort.github.io/bear.png"><meta name=twitter:title content="Managing Multi-Errors in Go"><meta name=twitter:description content="This post is a response to Go: Multiple Errors Management. I&rsquo;ve dealt with a multiple error contexts in a few places in my Go code but never created a subpackage for it in github.com/bbengfort/x and so I thought this post was a good motivation to explore it in slightly more detail. I&rsquo;d also like to make error contexts for routine cancellation a part of my standard programming practice, so this post also investigates multiple error handling in a single routine or multiple routines like the original post."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://bbengfort.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Managing Multi-Errors in Go","item":"https://bbengfort.github.io/2020/10/go-multiple-errors/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Managing Multi-Errors in Go","name":"Managing Multi-Errors in Go","description":"This post is a response to Go: Multiple Errors Management. I\u0026rsquo;ve dealt with a multiple error contexts in a few places in my Go code but never created a subpackage for it in github.com/bbengfort/x and so I thought this post was a good motivation to explore it in slightly more detail. I\u0026rsquo;d also like to make error contexts for routine cancellation a part of my standard programming practice, so this post also investigates multiple error handling in a single routine or multiple routines like the original post.\n","keywords":[],"articleBody":"This post is a response to Go: Multiple Errors Management. I’ve dealt with a multiple error contexts in a few places in my Go code but never created a subpackage for it in github.com/bbengfort/x and so I thought this post was a good motivation to explore it in slightly more detail. I’d also like to make error contexts for routine cancellation a part of my standard programming practice, so this post also investigates multiple error handling in a single routine or multiple routines like the original post.\nMulti-error management for me usually comes in the form of a Shutdown or Close method where I’m cleaning up a lot of things and would like to do everything before I handle errors:\nfunc (s *Server) Shutdown() (err error) { errs = make([]error, 0, 4) if err = s.router.GracefulStop(); err != nil { errs = append(errs, err) } if err = s.db.Close(); err != nil { errs = append(errs, err) } if err = s.meta.Flush(); err != nil { errs = append(errs, err) } if err = s.meta.Close(); err != nil { errs = append(Errs, err) } // Best case scenario first if len(errs) == 0 { return nil } if len(errs) == 1 { return errs[0] } return fmt.Errorf(\"%d errors occurred during shutdown\", len(errs)) } Obviously this is less than ideal in a lot of ways and using go-multierror by HashiCorp or multierr by Uber cleans things up nicely. Better yet, we could implement a simple type to handle reporting and appending:\n// MultiError implements the Error interface so it can be used as an error while also // wrapping multiple errors and easily appending them during execution. type MultiError struct { errors []error } // Error prints a semicolon separated list of the errors that occurred. The Report // method returns an error with a newline separated bulleted list if that's better. func (m *MultiError) Error() string { report := make([]string, 0, len(m)+1) report = append(report, fmt.Sprintf(\"%d errors occurred\", len(m))) for _, err := range m { report = append(report, err.Error()) } return strings.Join(report, \"; \") } // Appends more errors onto a MultiError, ignoring nil errors for ease of use. If the // MultiError hasn't been initialized, it is in this function. If any of the errs are // MultiErrors themselves, they are flattened into the top-level multi error. func (m *MultiError) Append(errs ...error) { if m.errors == nil { m.errors = make([]error, 0, len(errs)) } for _, err := range errs { // ignore nil errors for quick appends. if err == nil { continue } switch err.(type) { // flatten multi-error to the top level. case *MultiError: if len(err.errors) \u003e 0 { m.errors = append(m.errors, err.errors...) } default: m.errors = append(m.errors, err) } } } // Get returns nil if no errors have been added, the unique error if only one error // has been added, or the multi-error if multiple errors have been added. func (m MultiError) Get() error { switch len(m) { case 0: return nil case 1: return m[0] default: return m } } This code simplifies the process a bit and adds more helper functionality, but I haven’t benchmarked it yet. New usage would be as follows:\nfunc (s *Server) Shutdown() (err error) { var merr MultiError merr.Append(s.router.GracefulStop()) merr.Append(s.db.Close()) merr.Append(s.meta.Flush()) merr.Append(s.meta.Close()) return merr.Get() } In real code, though, I think I might prefer to use go-multierror as it has a lot more functionality and a slightly more intuitive implementation. This code was mostly for commentary purposes.\nThe real thing I need to remember is goroutine cancellation contexts using errgroup:\nfunc action(ctx context.Context) (err error) { // Note that the action must listen for the cancellation! timer := time.NewTimer(time.Duration(rand.Int63n(4000)) * time.Millisecond) select { case \u003c-timer.C: if rand.Float64() \u003c 0.2 { return errors.New(\"something bad happened\") } case \u003c-ctx.Done(): return nil } return nil } func main() { g, ctx := errgroup.WithContext(context.Background()) for i := 0; i \u003c 3; i++ { g.Go(func() (err error) { for j := 0; j \u003c 3; j++ { if err = action(ctx); err != nil { return err } } return nil }) } if err := g.Wait(); err != nil { log.Fatal(err) } } The thing the blog post forgot to mention is that the go routine must be able to actively cancel its operation by listening on the ctx.Done() channel in addition to a channel that signals the operation is done (in the above example, the timer channel that is just causing the routine to sleep). If the action function does not listen to the ctx.Done() channel, even though the error propagates to the g.Wait() and returns, and cancel() for the context is called; the program will not terminate “early” because no action is waiting for the cancellation signal.\n","wordCount":"790","inLanguage":"en","image":"https://bbengfort.github.io/bear.png","datePublished":"2020-10-22T11:45:41Z","dateModified":"2020-10-22T11:45:41Z","author":{"@type":"Person","name":"Benjamin Bengfort"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://bbengfort.github.io/2020/10/go-multiple-errors/"},"publisher":{"@type":"Organization","name":"Libelli","logo":{"@type":"ImageObject","url":"https://bbengfort.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bbengfort.github.io/ accesskey=h title="Libelli (Alt + H)"><img src=https://bbengfort.github.io/icon.png alt aria-label=logo height=35>Libelli</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://bbengfort.github.io/archive/ title=archive><span>archive</span></a></li><li><a href=https://bbengfort.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://bbengfort.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://bbengfort.github.io/about/ title=about><span>about</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://bbengfort.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://bbengfort.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Managing Multi-Errors in Go</h1><div class=post-meta><span title='2020-10-22 11:45:41 +0000 UTC'>October 22, 2020</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;790 words&nbsp;·&nbsp;Benjamin Bengfort&nbsp;|&nbsp;<a href=https://github.com/bbengfort/bbengfort.github.io/tree/main/content/posts/2020-10-22-go-multiple-errors.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>This post is a response to <a href=https://medium.com/a-journey-with-go/go-multiple-errors-management-a67477628cf1>Go: Multiple Errors Management</a>. I&rsquo;ve dealt with a multiple error contexts in a few places in my Go code but never created a subpackage for it in <code>github.com/bbengfort/x</code> and so I thought this post was a good motivation to explore it in slightly more detail. I&rsquo;d also like to make error contexts for routine cancellation a part of my standard programming practice, so this post also investigates multiple error handling in a single routine or multiple routines like the original post.</p><p>Multi-error management for me usually comes in the form of a <code>Shutdown</code> or <code>Close</code> method where I&rsquo;m cleaning up a lot of things and would like to do everything before I handle errors:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=nx>Server</span><span class=p>)</span> <span class=nf>Shutdown</span><span class=p>()</span> <span class=p>(</span><span class=nx>err</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>errs</span> <span class=p>=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>error</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>4</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=p>=</span> <span class=nx>s</span><span class=p>.</span><span class=nx>router</span><span class=p>.</span><span class=nf>GracefulStop</span><span class=p>();</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>errs</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>errs</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=p>=</span> <span class=nx>s</span><span class=p>.</span><span class=nx>db</span><span class=p>.</span><span class=nf>Close</span><span class=p>();</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>errs</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>errs</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=p>=</span> <span class=nx>s</span><span class=p>.</span><span class=nx>meta</span><span class=p>.</span><span class=nf>Flush</span><span class=p>();</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>errs</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>errs</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=p>=</span> <span class=nx>s</span><span class=p>.</span><span class=nx>meta</span><span class=p>.</span><span class=nf>Close</span><span class=p>();</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>errs</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>Errs</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Best case scenario first
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>errs</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>errs</span><span class=p>)</span> <span class=o>==</span> <span class=mi>1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>errs</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;%d errors occurred during shutdown&#34;</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>errs</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Obviously this is less than ideal in a lot of ways and using <a href=https://github.com/hashicorp/go-multierror><code>go-multierror</code></a> by HashiCorp or <a href=https://github.com/uber-go/multierr><code>multierr</code></a> by Uber cleans things up nicely. Better yet, we could implement a simple type to handle reporting and appending:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// MultiError implements the Error interface so it can be used as an error while also
</span></span></span><span class=line><span class=cl><span class=c1>// wrapping multiple errors and easily appending them during execution.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>MultiError</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>errors</span> <span class=p>[]</span><span class=kt>error</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Error prints a semicolon separated list of the errors that occurred. The Report
</span></span></span><span class=line><span class=cl><span class=c1>// method returns an error with a newline separated bulleted list if that&#39;s better.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>MultiError</span><span class=p>)</span> <span class=nf>Error</span><span class=p>()</span> <span class=kt>string</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>report</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>string</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>m</span><span class=p>)</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>report</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>report</span><span class=p>,</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Sprintf</span><span class=p>(</span><span class=s>&#34;%d errors occurred&#34;</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>m</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>m</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>report</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>report</span><span class=p>,</span> <span class=nx>err</span><span class=p>.</span><span class=nf>Error</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>strings</span><span class=p>.</span><span class=nf>Join</span><span class=p>(</span><span class=nx>report</span><span class=p>,</span> <span class=s>&#34;; &#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Appends more errors onto a MultiError, ignoring nil errors for ease of use. If the
</span></span></span><span class=line><span class=cl><span class=c1>// MultiError hasn&#39;t been initialized, it is in this function. If any of the errs are
</span></span></span><span class=line><span class=cl><span class=c1>// MultiErrors themselves, they are flattened into the top-level multi error.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>MultiError</span><span class=p>)</span> <span class=nf>Append</span><span class=p>(</span><span class=nx>errs</span> <span class=o>...</span><span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>m</span><span class=p>.</span><span class=nx>errors</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>m</span><span class=p>.</span><span class=nx>errors</span> <span class=p>=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>error</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>errs</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>errs</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// ignore nil errors for quick appends.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=nx>err</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>continue</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>switch</span> <span class=nx>err</span><span class=p>.(</span><span class=kd>type</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// flatten multi-error to the top level.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>case</span> <span class=o>*</span><span class=nx>MultiError</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>err</span><span class=p>.</span><span class=nx>errors</span><span class=p>)</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nx>m</span><span class=p>.</span><span class=nx>errors</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>m</span><span class=p>.</span><span class=nx>errors</span><span class=p>,</span> <span class=nx>err</span><span class=p>.</span><span class=nx>errors</span><span class=o>...</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>default</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=nx>m</span><span class=p>.</span><span class=nx>errors</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>m</span><span class=p>.</span><span class=nx>errors</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Get returns nil if no errors have been added, the unique error if only one error
</span></span></span><span class=line><span class=cl><span class=c1>// has been added, or the multi-error if multiple errors have been added.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=nx>MultiError</span><span class=p>)</span> <span class=nf>Get</span><span class=p>()</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>switch</span> <span class=nb>len</span><span class=p>(</span><span class=nx>m</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>m</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=k>default</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>m</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This code simplifies the process a bit and adds more helper functionality, but I haven&rsquo;t benchmarked it yet. New usage would be as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=nx>Server</span><span class=p>)</span> <span class=nf>Shutdown</span><span class=p>()</span> <span class=p>(</span><span class=nx>err</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>merr</span> <span class=nx>MultiError</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>merr</span><span class=p>.</span><span class=nf>Append</span><span class=p>(</span><span class=nx>s</span><span class=p>.</span><span class=nx>router</span><span class=p>.</span><span class=nf>GracefulStop</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=nx>merr</span><span class=p>.</span><span class=nf>Append</span><span class=p>(</span><span class=nx>s</span><span class=p>.</span><span class=nx>db</span><span class=p>.</span><span class=nf>Close</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=nx>merr</span><span class=p>.</span><span class=nf>Append</span><span class=p>(</span><span class=nx>s</span><span class=p>.</span><span class=nx>meta</span><span class=p>.</span><span class=nf>Flush</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=nx>merr</span><span class=p>.</span><span class=nf>Append</span><span class=p>(</span><span class=nx>s</span><span class=p>.</span><span class=nx>meta</span><span class=p>.</span><span class=nf>Close</span><span class=p>())</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>merr</span><span class=p>.</span><span class=nf>Get</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>In real code, though, I think I might prefer to use <code>go-multierror</code> as it has a lot more functionality and a slightly more intuitive implementation. This code was mostly for commentary purposes.</p><p>The real thing I need to remember is goroutine cancellation contexts using <code>errgroup</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>action</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>)</span> <span class=p>(</span><span class=nx>err</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// Note that the action must listen for the cancellation!
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>timer</span> <span class=o>:=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>NewTimer</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nf>Duration</span><span class=p>(</span><span class=nx>rand</span><span class=p>.</span><span class=nf>Int63n</span><span class=p>(</span><span class=mi>4000</span><span class=p>))</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Millisecond</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=o>&lt;-</span><span class=nx>timer</span><span class=p>.</span><span class=nx>C</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>rand</span><span class=p>.</span><span class=nf>Float64</span><span class=p>()</span> <span class=p>&lt;</span> <span class=mf>0.2</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=s>&#34;something bad happened&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=o>&lt;-</span><span class=nx>ctx</span><span class=p>.</span><span class=nf>Done</span><span class=p>():</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>g</span><span class=p>,</span> <span class=nx>ctx</span> <span class=o>:=</span> <span class=nx>errgroup</span><span class=p>.</span><span class=nf>WithContext</span><span class=p>(</span><span class=nx>context</span><span class=p>.</span><span class=nf>Background</span><span class=p>())</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>3</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>g</span><span class=p>.</span><span class=nf>Go</span><span class=p>(</span><span class=kd>func</span><span class=p>()</span> <span class=p>(</span><span class=nx>err</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>for</span> <span class=nx>j</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>j</span> <span class=p>&lt;</span> <span class=mi>3</span><span class=p>;</span> <span class=nx>j</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=k>if</span> <span class=nx>err</span> <span class=p>=</span> <span class=nf>action</span><span class=p>(</span><span class=nx>ctx</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>					<span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>				<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>		<span class=p>})</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>g</span><span class=p>.</span><span class=nf>Wait</span><span class=p>();</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>log</span><span class=p>.</span><span class=nf>Fatal</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The thing the blog post forgot to mention is that the go routine must be able to actively cancel its operation by listening on the <code>ctx.Done()</code> channel in addition to a channel that signals the operation is done (in the above example, the timer channel that is just causing the routine to sleep). If the <code>action</code> function does not listen to the <code>ctx.Done()</code> channel, even though the <em>error propagates</em> to the <code>g.Wait()</code> and returns, and <code>cancel()</code> for the context is called; the program will not terminate &ldquo;early&rdquo; because no action is waiting for the cancellation signal.</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://bbengfort.github.io/2020/11/mac-cleanup/><span class=title>« Prev</span><br><span>OS X Cleanup</span>
</a><a class=next href=https://bbengfort.github.io/2020/08/zipfiles-json/><span class=title>Next »</span><br><span>Writing JSON into a Zip file with Python</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://bbengfort.github.io/>Libelli</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>