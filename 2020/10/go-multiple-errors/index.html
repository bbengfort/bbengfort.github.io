<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Managing Multi-Errors in Go | Libelli</title><meta name=keywords content><meta name=description content="This post is a response to Go: Multiple Errors Management. I&rsquo;ve dealt with a multiple error contexts in a few places in my Go code but never created a subpackage for it in github.com/bbengfort/x and so I thought this post was a good motivation to explore it in slightly more detail. I&rsquo;d also like to make error contexts for routine cancellation a part of my standard programming practice, so this post also investigates multiple error handling in a single routine or multiple routines like the original post."><meta name=author content="Benjamin Bengfort"><link rel=canonical href=https://bbengfort.github.io/2020/10/go-multiple-errors/><link crossorigin=anonymous href=/assets/css/stylesheet.min.d0c0348c2d0cff14148d0e347258519d8df2ce53ce5ac32c7bd9a549182cb8ae.css integrity="sha256-0MA0jC0M/xQUjQ40clhRnY3yzlPOWsMse9mlSRgsuK4=" rel="preload stylesheet" as=style><link rel=preload href=/icon.png as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><link rel=icon href=https://bbengfort.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://bbengfort.github.io/icon.png><link rel=icon type=image/png sizes=32x32 href=https://bbengfort.github.io/icon.png><link rel=apple-touch-icon href=https://bbengfort.github.io/apple-touch-icon-precomposed.png><link rel=mask-icon href=https://bbengfort.github.io/icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.79.0"><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-8096804-11','auto');ga('send','pageview');}</script><meta property="og:title" content="Managing Multi-Errors in Go"><meta property="og:description" content="This post is a response to Go: Multiple Errors Management. I&rsquo;ve dealt with a multiple error contexts in a few places in my Go code but never created a subpackage for it in github.com/bbengfort/x and so I thought this post was a good motivation to explore it in slightly more detail. I&rsquo;d also like to make error contexts for routine cancellation a part of my standard programming practice, so this post also investigates multiple error handling in a single routine or multiple routines like the original post."><meta property="og:type" content="article"><meta property="og:url" content="https://bbengfort.github.io/2020/10/go-multiple-errors/"><meta property="og:image" content="https://bbengfort.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-10-22T11:45:41+00:00"><meta property="article:modified_time" content="2020-10-22T11:45:41+00:00"><meta property="og:site_name" content="Libelli"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://bbengfort.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Managing Multi-Errors in Go"><meta name=twitter:description content="This post is a response to Go: Multiple Errors Management. I&rsquo;ve dealt with a multiple error contexts in a few places in my Go code but never created a subpackage for it in github.com/bbengfort/x and so I thought this post was a good motivation to explore it in slightly more detail. I&rsquo;d also like to make error contexts for routine cancellation a part of my standard programming practice, so this post also investigates multiple error handling in a single routine or multiple routines like the original post."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://bbengfort.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Managing Multi-Errors in Go","item":"https://bbengfort.github.io/2020/10/go-multiple-errors/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Managing Multi-Errors in Go","name":"Managing Multi-Errors in Go","description":"This post is a response to Go: Multiple Errors Management. I\u0026rsquo;ve dealt with a multiple error contexts in a few places in my Go code but never created a subpackage for it in github.com/bbengfort/x and so I thought this post was a good motivation to explore it in slightly more detail. I\u0026rsquo;d also like to make error contexts for routine cancellation a part of my standard programming practice, so this post also investigates multiple error handling in a single routine or multiple routines like the original post.","keywords":[],"articleBody":"This post is a response to Go: Multiple Errors Management. I’ve dealt with a multiple error contexts in a few places in my Go code but never created a subpackage for it in github.com/bbengfort/x and so I thought this post was a good motivation to explore it in slightly more detail. I’d also like to make error contexts for routine cancellation a part of my standard programming practice, so this post also investigates multiple error handling in a single routine or multiple routines like the original post.\nMulti-error management for me usually comes in the form of a Shutdown or Close method where I’m cleaning up a lot of things and would like to do everything before I handle errors:\nfunc (s *Server) Shutdown() (err error) { errs = make([]error, 0, 4) if err = s.router.GracefulStop(); err != nil { errs = append(errs, err) } if err = s.db.Close(); err != nil { errs = append(errs, err) } if err = s.meta.Flush(); err != nil { errs = append(errs, err) } if err = s.meta.Close(); err != nil { errs = append(Errs, err) } // Best case scenario first  if len(errs) == 0 { return nil } if len(errs) == 1 { return errs[0] } return fmt.Errorf(\"%d errors occurred during shutdown\", len(errs)) } Obviously this is less than ideal in a lot of ways and using go-multierror by HashiCorp or multierr by Uber cleans things up nicely. Better yet, we could implement a simple type to handle reporting and appending:\n// MultiError implements the Error interface so it can be used as an error while also // wrapping multiple errors and easily appending them during execution. type MultiError struct { errors []error } // Error prints a semicolon separated list of the errors that occurred. The Report // method returns an error with a newline separated bulleted list if that's better. func (m *MultiError) Error() string { report := make([]string, 0, len(m)+1) report = append(report, fmt.Sprintf(\"%d errors occurred\", len(m))) for _, err := range m { report = append(report, err.Error()) } return strings.Join(report, \"; \") } // Appends more errors onto a MultiError, ignoring nil errors for ease of use. If the // MultiError hasn't been initialized, it is in this function. If any of the errs are // MultiErrors themselves, they are flattened into the top-level multi error. func (m *MultiError) Append(errs ...error) { if m.errors == nil { m.errors = make([]error, 0, len(errs)) } for _, err := range errs { // ignore nil errors for quick appends.  if err == nil { continue } switch err.(type) { // flatten multi-error to the top level.  case *MultiError: if len(err.errors)  0 { m.errors = append(m.errors, err.errors...) } default: m.errors = append(m.errors, err) } } } // Get returns nil if no errors have been added, the unique error if only one error // has been added, or the multi-error if multiple errors have been added. func (m MultiError) Get() error { switch len(m) { case 0: return nil case 1: return m[0] default: return m } } This code simplifies the process a bit and adds more helper functionality, but I haven’t benchmarked it yet. New usage would be as follows:\nfunc (s *Server) Shutdown() (err error) { var merr MultiError merr.Append(s.router.GracefulStop()) merr.Append(s.db.Close()) merr.Append(s.meta.Flush()) merr.Append(s.meta.Close()) return merr.Get() } In real code, though, I think I might prefer to use go-multierror as it has a lot more functionality and a slightly more intuitive implementation. This code was mostly for commentary purposes.\nThe real thing I need to remember is goroutine cancellation contexts using errgroup:\nfunc action(ctx context.Context) (err error) { // Note that the action must listen for the cancellation! \ttimer := time.NewTimer(time.Duration(rand.Int63n(4000)) * time.Millisecond) select { case timer.C: if rand.Float64() 0.2 { return errors.New(\"something bad happened\") } case ctx.Done(): return nil } return nil } func main() { g, ctx := errgroup.WithContext(context.Background()) for i := 0; i 3; i++ { g.Go(func() (err error) { for j := 0; j 3; j++ { if err = action(ctx); err != nil { return err } } return nil }) } if err := g.Wait(); err != nil { log.Fatal(err) } } The thing the blog post forgot to mention is that the go routine must be able to actively cancel its operation by listening on the ctx.Done() channel in addition to a channel that signals the operation is done (in the above example, the timer channel that is just causing the routine to sleep). If the action function does not listen to the ctx.Done() channel, even though the error propagates to the g.Wait() and returns, and cancel() for the context is called; the program will not terminate “early” because no action is waiting for the cancellation signal.\n","wordCount":"790","inLanguage":"en","datePublished":"2020-10-22T11:45:41Z","dateModified":"2020-10-22T11:45:41Z","author":{"@type":"Person","name":"Benjamin Bengfort"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://bbengfort.github.io/2020/10/go-multiple-errors/"},"publisher":{"@type":"Organization","name":"Libelli","logo":{"@type":"ImageObject","url":"https://bbengfort.github.io/favicon.ico"}}}</script></head><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme: #1d1e20;--entry: #2e2e33;--primary: rgba(255, 255, 255, 0.84);--secondary: rgba(255, 255, 255, 0.56);--tertiary: rgba(255, 255, 255, 0.16);--content: rgba(255, 255, 255, 0.74);--hljs-bg: #2e2e33;--code-bg: #37383e;--border: #333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://bbengfort.github.io accesskey=h title="Libelli (Alt + H)"><img src=/icon.png alt=logo aria-label=logo height=35>Libelli</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://bbengfort.github.io/archive/ title=archive><span>archive</span></a></li><li><a href=https://bbengfort.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://bbengfort.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://bbengfort.github.io/about/ title=about><span>about</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Managing Multi-Errors in Go</h1><div class=post-meta>October 22, 2020&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Benjamin Bengfort</div></header><div class=post-content><p>This post is a response to <a href=https://medium.com/a-journey-with-go/go-multiple-errors-management-a67477628cf1>Go: Multiple Errors Management</a>. I&rsquo;ve dealt with a multiple error contexts in a few places in my Go code but never created a subpackage for it in <code>github.com/bbengfort/x</code> and so I thought this post was a good motivation to explore it in slightly more detail. I&rsquo;d also like to make error contexts for routine cancellation a part of my standard programming practice, so this post also investigates multiple error handling in a single routine or multiple routines like the original post.</p><p>Multi-error management for me usually comes in the form of a <code>Shutdown</code> or <code>Close</code> method where I&rsquo;m cleaning up a lot of things and would like to do everything before I handle errors:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Server</span>) <span style=color:#a6e22e>Shutdown</span>() (<span style=color:#a6e22e>err</span> <span style=color:#66d9ef>error</span>) {
    <span style=color:#a6e22e>errs</span> = make([]<span style=color:#66d9ef>error</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>4</span>)

    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>router</span>.<span style=color:#a6e22e>GracefulStop</span>(); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
        <span style=color:#a6e22e>errs</span> = append(<span style=color:#a6e22e>errs</span>, <span style=color:#a6e22e>err</span>)
    }

    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>Close</span>(); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
        <span style=color:#a6e22e>errs</span> = append(<span style=color:#a6e22e>errs</span>, <span style=color:#a6e22e>err</span>)
    }

    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>meta</span>.<span style=color:#a6e22e>Flush</span>(); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
        <span style=color:#a6e22e>errs</span> = append(<span style=color:#a6e22e>errs</span>, <span style=color:#a6e22e>err</span>)
    }

    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>meta</span>.<span style=color:#a6e22e>Close</span>(); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
        <span style=color:#a6e22e>errs</span> = append(<span style=color:#a6e22e>Errs</span>, <span style=color:#a6e22e>err</span>)
    }

    <span style=color:#75715e>// Best case scenario first
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>errs</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
    }

    <span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>errs</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span> {
        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>errs</span>[<span style=color:#ae81ff>0</span>]
    }
    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;%d errors occurred during shutdown&#34;</span>, len(<span style=color:#a6e22e>errs</span>))
}
</code></pre></div><p>Obviously this is less than ideal in a lot of ways and using <a href=https://github.com/hashicorp/go-multierror><code>go-multierror</code></a> by HashiCorp or <a href=https://github.com/uber-go/multierr><code>multierr</code></a> by Uber cleans things up nicely. Better yet, we could implement a simple type to handle reporting and appending:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// MultiError implements the Error interface so it can be used as an error while also
</span><span style=color:#75715e>// wrapping multiple errors and easily appending them during execution.
</span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>MultiError</span> <span style=color:#66d9ef>struct</span> {
    <span style=color:#a6e22e>errors</span> []<span style=color:#66d9ef>error</span>
}

<span style=color:#75715e>// Error prints a semicolon separated list of the errors that occurred. The Report
</span><span style=color:#75715e>// method returns an error with a newline separated bulleted list if that&#39;s better.
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>m</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>MultiError</span>) <span style=color:#a6e22e>Error</span>() <span style=color:#66d9ef>string</span> {
    <span style=color:#a6e22e>report</span> <span style=color:#f92672>:=</span> make([]<span style=color:#66d9ef>string</span>, <span style=color:#ae81ff>0</span>, len(<span style=color:#a6e22e>m</span>)<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>)
    <span style=color:#a6e22e>report</span> = append(<span style=color:#a6e22e>report</span>, <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Sprintf</span>(<span style=color:#e6db74>&#34;%d errors occurred&#34;</span>, len(<span style=color:#a6e22e>m</span>)))
    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>m</span> {
        <span style=color:#a6e22e>report</span> = append(<span style=color:#a6e22e>report</span>, <span style=color:#a6e22e>err</span>.<span style=color:#a6e22e>Error</span>())
    }
    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>strings</span>.<span style=color:#a6e22e>Join</span>(<span style=color:#a6e22e>report</span>, <span style=color:#e6db74>&#34;; &#34;</span>)
}

<span style=color:#75715e>// Appends more errors onto a MultiError, ignoring nil errors for ease of use. If the
</span><span style=color:#75715e>// MultiError hasn&#39;t been initialized, it is in this function. If any of the errs are
</span><span style=color:#75715e>// MultiErrors themselves, they are flattened into the top-level multi error.
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>m</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>MultiError</span>) <span style=color:#a6e22e>Append</span>(<span style=color:#a6e22e>errs</span> <span style=color:#f92672>...</span><span style=color:#66d9ef>error</span>) {
    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>errors</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
        <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>errors</span> = make([]<span style=color:#66d9ef>error</span>, <span style=color:#ae81ff>0</span>, len(<span style=color:#a6e22e>errs</span>))
    }

    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>errs</span> {
        <span style=color:#75715e>// ignore nil errors for quick appends.
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
            <span style=color:#66d9ef>continue</span>
        }

        <span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>err</span>.(<span style=color:#66d9ef>type</span>) {
        <span style=color:#75715e>// flatten multi-error to the top level.
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>case</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>MultiError</span>:
            <span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>err</span>.<span style=color:#a6e22e>errors</span>) &gt; <span style=color:#ae81ff>0</span> {
                <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>errors</span> = append(<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>errors</span>, <span style=color:#a6e22e>err</span>.<span style=color:#a6e22e>errors</span><span style=color:#f92672>...</span>)
            }
        <span style=color:#66d9ef>default</span>:
            <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>errors</span> = append(<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>errors</span>, <span style=color:#a6e22e>err</span>)
        }
    }
}

<span style=color:#75715e>// Get returns nil if no errors have been added, the unique error if only one error
</span><span style=color:#75715e>// has been added, or the multi-error if multiple errors have been added.
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>m</span> <span style=color:#a6e22e>MultiError</span>) <span style=color:#a6e22e>Get</span>() <span style=color:#66d9ef>error</span> {
    <span style=color:#66d9ef>switch</span> len(<span style=color:#a6e22e>m</span>) {
    <span style=color:#66d9ef>case</span> <span style=color:#ae81ff>0</span>:
        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
    <span style=color:#66d9ef>case</span> <span style=color:#ae81ff>1</span>:
        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>m</span>[<span style=color:#ae81ff>0</span>]
    <span style=color:#66d9ef>default</span>:
        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>m</span>
    }
}
</code></pre></div><p>This code simplifies the process a bit and adds more helper functionality, but I haven&rsquo;t benchmarked it yet. New usage would be as follows:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Server</span>) <span style=color:#a6e22e>Shutdown</span>() (<span style=color:#a6e22e>err</span> <span style=color:#66d9ef>error</span>) {
    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>merr</span> <span style=color:#a6e22e>MultiError</span>

    <span style=color:#a6e22e>merr</span>.<span style=color:#a6e22e>Append</span>(<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>router</span>.<span style=color:#a6e22e>GracefulStop</span>())
    <span style=color:#a6e22e>merr</span>.<span style=color:#a6e22e>Append</span>(<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>Close</span>())
    <span style=color:#a6e22e>merr</span>.<span style=color:#a6e22e>Append</span>(<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>meta</span>.<span style=color:#a6e22e>Flush</span>())
    <span style=color:#a6e22e>merr</span>.<span style=color:#a6e22e>Append</span>(<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>meta</span>.<span style=color:#a6e22e>Close</span>())

    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>merr</span>.<span style=color:#a6e22e>Get</span>()
}
</code></pre></div><p>In real code, though, I think I might prefer to use <code>go-multierror</code> as it has a lot more functionality and a slightly more intuitive implementation. This code was mostly for commentary purposes.</p><p>The real thing I need to remember is goroutine cancellation contexts using <code>errgroup</code>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>action</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>) (<span style=color:#a6e22e>err</span> <span style=color:#66d9ef>error</span>) {
	<span style=color:#75715e>// Note that the action must listen for the cancellation!
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>timer</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>NewTimer</span>(<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Duration</span>(<span style=color:#a6e22e>rand</span>.<span style=color:#a6e22e>Int63n</span>(<span style=color:#ae81ff>4000</span>)) <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Millisecond</span>)
	<span style=color:#66d9ef>select</span> {
	<span style=color:#66d9ef>case</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>timer</span>.<span style=color:#a6e22e>C</span>:
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>rand</span>.<span style=color:#a6e22e>Float64</span>() &lt; <span style=color:#ae81ff>0.2</span> {
			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>New</span>(<span style=color:#e6db74>&#34;something bad happened&#34;</span>)
		}
	<span style=color:#66d9ef>case</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>Done</span>():
		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
	}
	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#a6e22e>g</span>, <span style=color:#a6e22e>ctx</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>errgroup</span>.<span style=color:#a6e22e>WithContext</span>(<span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Background</span>())
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#ae81ff>3</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
		<span style=color:#a6e22e>g</span>.<span style=color:#a6e22e>Go</span>(<span style=color:#66d9ef>func</span>() (<span style=color:#a6e22e>err</span> <span style=color:#66d9ef>error</span>) {
			<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>j</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>j</span> &lt; <span style=color:#ae81ff>3</span>; <span style=color:#a6e22e>j</span><span style=color:#f92672>++</span> {
				<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>action</span>(<span style=color:#a6e22e>ctx</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
					<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
				}
			}
			<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
		})
	}
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>g</span>.<span style=color:#a6e22e>Wait</span>(); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#a6e22e>err</span>)
	}
}
</code></pre></div><p>The thing the blog post forgot to mention is that the go routine must be able to actively cancel its operation by listening on the <code>ctx.Done()</code> channel in addition to a channel that signals the operation is done (in the above example, the timer channel that is just causing the routine to sleep). If the <code>action</code> function does not listen to the <code>ctx.Done()</code> channel, even though the <em>error propagates</em> to the <code>g.Wait()</code> and returns, and <code>cancel()</code> for the context is called; the program will not terminate &ldquo;early&rdquo; because no action is waiting for the cancellation signal.</p></div><footer class=post-footer></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://bbengfort.github.io>Libelli</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById('menu')
menu.scrollLeft=localStorage.getItem("menu-scroll-position");menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft);}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);if(!window.matchMedia('(prefers-reduced-motion: reduce)').matches){document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});}else{document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();}
if(id==="top"){history.replaceState(null,null," ");}else{history.pushState(null,null,`#${id}`);}});});</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script></body></html>