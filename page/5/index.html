<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.135.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Libelli</title>
<meta name=keywords content="Blog,Golang,Developer,Journal,Python,Programming,Bengfort"><meta name=description content="The development journal of @bbengfort including notes and ramblings from his various programming activities."><meta name=author content="Benjamin Bengfort"><link rel=canonical href=https://bbengfort.github.io/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://bbengfort.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://bbengfort.github.io/icon.png><link rel=icon type=image/png sizes=32x32 href=https://bbengfort.github.io/icon.png><link rel=apple-touch-icon href=https://bbengfort.github.io/apple-touch-icon-precomposed.png><link rel=mask-icon href=https://bbengfort.github.io/icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://bbengfort.github.io/index.xml><link rel=alternate type=application/json href=https://bbengfort.github.io/index.json><link rel=alternate hreflang=en href=https://bbengfort.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-D3BE7EHHVP"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-D3BE7EHHVP")}</script><meta property="og:title" content="Libelli"><meta property="og:description" content="The development journal of @bbengfort including notes and ramblings from his various programming activities."><meta property="og:type" content="website"><meta property="og:url" content="https://bbengfort.github.io/"><meta property="og:image" content="https://bbengfort.github.io/bear.png"><meta property="og:site_name" content="Libelli"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://bbengfort.github.io/bear.png"><meta name=twitter:title content="Libelli"><meta name=twitter:description content="The development journal of @bbengfort including notes and ramblings from his various programming activities."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"Libelli","url":"https://bbengfort.github.io/","description":"The development journal of @bbengfort including notes and ramblings from his various programming activities.","thumbnailUrl":"https://bbengfort.github.io/favicon.ico","sameAs":["https://scholar.google.com/citations?hl=en\u0026user=QHJF4OEAAAAJ","https://stackoverflow.com/users/488917/bbengfort","https://github.com/bbengfort/","https://linkedin.com/in/bbengfort/"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bbengfort.github.io/ accesskey=h title="Libelli (Alt + H)"><img src=https://bbengfort.github.io/icon.png alt aria-label=logo height=35>Libelli</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://bbengfort.github.io/archive/ title=archive><span>archive</span></a></li><li><a href=https://bbengfort.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://bbengfort.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://bbengfort.github.io/about/ title=about><span>about</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Lock Diagnostics in Go</h2></header><div class=entry-content><p>By now it’s pretty clear that I’ve just had a bear of a time with locks and synchronization inside of multi-threaded environments with Go. Probably most gophers would simply tell me that I should share memory by communicating rather than to communication by sharing memory — and frankly I’m in that camp too. The issue is that:
Mutexes can be more expressive than channels Channels are fairly heavyweight So to be honest, there are situations where a mutex is a better choice than a channel. I believe that one of those situations is when dealing with replicated state machines … which is what I’ve been working on the past few months. The issue is that the state of the replica has to be consistent across a variety of events: timers and remote messages. The problem is that the timers and network traffic are all go routines, and there can be a lot of them running in the system at a time.
...</p></div><footer class=entry-footer><span title='2017-09-28 10:44:30 +0000 UTC'>September 28, 2017</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;765 words&nbsp;·&nbsp;Benjamin Bengfort</footer><a class=entry-link aria-label="post link to Lock Diagnostics in Go" href=https://bbengfort.github.io/2017/09/lock-diagnostics/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Lock Queuing in Go</h2></header><div class=entry-content><p>In Go, you can use sync.Mutex and sync.RWMutex objects to create thread-safe data structures in memory as discussed in [“Synchronizing Structs for Safe Concurrency in Go”]({% post_url 2017-02-21-synchronizing-structs %}). When using the sync.RWMutex in Go, there are two kinds of locks: read locks and write locks. The basic difference is that many read locks can be acquired at the same time, but only one write lock can be acquired at at time.
...</p></div><footer class=entry-footer><span title='2017-09-08 11:31:19 +0000 UTC'>September 8, 2017</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1296 words&nbsp;·&nbsp;Benjamin Bengfort</footer><a class=entry-link aria-label="post link to Lock Queuing in Go" href=https://bbengfort.github.io/2017/09/lock-queueing/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Messaging Throughput gRPC vs. ZMQ</h2></header><div class=entry-content><p>Building distributed systems in Go requires an RPC or message framework of some sort. In the systems I build I prefer to pass messages serialized with protocol buffers therefore a natural choice for me is grpc. The grpc library uses HTTP2 as a transport layer and provides a code generator based on the protocol buffer syntax making it very simple to use.
For more detailed control, the ZMQ library is an excellent, low latency socket framework. ZMQ provides several communication patterns from basic REQ/REP (request/reply) to PUB/SUB (publish/subscribe). ZMQ is used at a lower level though, so more infrastructure per app needs to be built.
...</p></div><footer class=entry-footer><span title='2017-09-04 17:20:06 +0000 UTC'>September 4, 2017</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;429 words&nbsp;·&nbsp;Benjamin Bengfort</footer><a class=entry-link aria-label="post link to Messaging Throughput gRPC vs. ZMQ" href=https://bbengfort.github.io/2017/09/message-throughput/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Online Distribution</h2></header><div class=entry-content><p>This post started out as a discussion of a struct in Go that could keep track of online statistics without keeping an array of values. It ended up being a lesson on over-engineering for concurrency.
The spec of the routine was to build a data structure that could keep track of internal statistics of values over time in a space-saving fashion. The primary interface was a method, Update(sample float64), so that a new sample could be passed to the structure, updating internal parameters. At conclusion, the structure should be able to describe the mean, variance, and range of all values passed to the update method. I created two versions:
...</p></div><footer class=entry-footer><span title='2017-08-28 12:49:46 +0000 UTC'>August 28, 2017</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;480 words&nbsp;·&nbsp;Benjamin Bengfort</footer><a class=entry-link aria-label="post link to Online Distribution" href=https://bbengfort.github.io/2017/08/online-distribution/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Rapid FS Walks with ErrGroup</h2></header><div class=entry-content><p>I’ve been looking for a way to quickly scan a file system and gather information about the files in directories contained within. I had been doing this with multiprocessing in Python, but figured Go could speed up my performance by a lot. What I discovered when I went down this path was the sync.ErrGroup, an extension of the sync.WaitGroup that helps manage the complexity of multiple go routines but also includes error handling!
...</p></div><footer class=entry-footer><span title='2017-08-18 15:33:35 +0000 UTC'>August 18, 2017</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1206 words&nbsp;·&nbsp;Benjamin Bengfort</footer><a class=entry-link aria-label="post link to Rapid FS Walks with ErrGroup" href=https://bbengfort.github.io/2017/08/rapid-fs-walk/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Buffered Write Performance</h2></header><div class=entry-content><p>This is just a quick note on the performance of writing to a file on disk using Go, and reveals a question about a common programming paradigm that I am now suspicious of. I discovered that when I wrapped the open file object with a bufio.Writer that the performance of my writes to disk significantly increased. Ok, so this isn’t about simple file writing to disk, this is about a complex writer that does some seeking in the file writing to different positions and maintains the overall state of what’s on disk in memory, however the question remains:
...</p></div><footer class=entry-footer><span title='2017-08-03 09:48:19 +0000 UTC'>August 3, 2017</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;1065 words&nbsp;·&nbsp;Benjamin Bengfort</footer><a class=entry-link aria-label="post link to Buffered Write Performance" href=https://bbengfort.github.io/2017/08/buffered-writes/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Event Dispatcher in Go</h2></header><div class=entry-content><p>The event dispatcher pattern is extremely common in software design, particularly in languages like JavaScript that are primarily used for user interface work. The dispatcher is an object (usually a mixin to other objects) that can register callback functions for particular events. Then when a dispatch method is called with an event, the dispatcher calls each callback function in order of their registration and passes them a copy of the event. In fact, I’ve already written a version of this pattern in Python: [Implementing Observers with Events]({% post_url 2016-02-16-observer-pattern %}) In this snippet, I’m presenting a version in Go that has been incredibly stable and useful in my code.
...</p></div><footer class=entry-footer><span title='2017-07-21 06:28:45 +0000 UTC'>July 21, 2017</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;468 words&nbsp;·&nbsp;Benjamin Bengfort</footer><a class=entry-link aria-label="post link to Event Dispatcher in Go" href=https://bbengfort.github.io/2017/07/event-dispatcher/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://bbengfort.github.io/page/4/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://bbengfort.github.io/page/6/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2024 <a href=https://bbengfort.github.io/>Libelli</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>