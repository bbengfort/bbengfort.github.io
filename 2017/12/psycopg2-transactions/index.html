<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Transaction Handling with Psycopg2 | Libelli</title><meta name=keywords content><meta name=description content="Databases are essential to most applications, however most database interaction is often overlooked by Python developers who use higher level libraries like Django or SQLAlchemy. We use and love PostgreSQL with Psycopg2, but I recently realized that I didn&rsquo;t have a good grasp on how exactly psycopg2 implemented core database concepts: particularly transaction isolation and thread safety.
Here&rsquo;s what the documentation says regarding transactions:
Transactions are handled by the connection class."><meta name=author content="Benjamin Bengfort"><link rel=canonical href=https://bbengfort.github.io/2017/12/psycopg2-transactions/><link crossorigin=anonymous href=/assets/css/stylesheet.min.2d6dbfc6e0f8a1db1c9d082a76dc11d094328cf63f247bbc2421dfaa7f2bb170.css integrity="sha256-LW2/xuD4odscnQgqdtwR0JQyjPY/JHu8JCHfqn8rsXA=" rel="preload stylesheet" as=style><link rel=preload href=/icon.png as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://bbengfort.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://bbengfort.github.io/icon.png><link rel=icon type=image/png sizes=32x32 href=https://bbengfort.github.io/icon.png><link rel=apple-touch-icon href=https://bbengfort.github.io/apple-touch-icon-precomposed.png><link rel=mask-icon href=https://bbengfort.github.io/icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.105.0"><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-8096804-11","auto"),ga("send","pageview"))</script><meta property="og:title" content="Transaction Handling with Psycopg2"><meta property="og:description" content="Databases are essential to most applications, however most database interaction is often overlooked by Python developers who use higher level libraries like Django or SQLAlchemy. We use and love PostgreSQL with Psycopg2, but I recently realized that I didn&rsquo;t have a good grasp on how exactly psycopg2 implemented core database concepts: particularly transaction isolation and thread safety.
Here&rsquo;s what the documentation says regarding transactions:
Transactions are handled by the connection class."><meta property="og:type" content="article"><meta property="og:url" content="https://bbengfort.github.io/2017/12/psycopg2-transactions/"><meta property="og:image" content="https://bbengfort.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-12-06T13:58:16+00:00"><meta property="article:modified_time" content="2017-12-06T13:58:16+00:00"><meta property="og:site_name" content="Libelli"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://bbengfort.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Transaction Handling with Psycopg2"><meta name=twitter:description content="Databases are essential to most applications, however most database interaction is often overlooked by Python developers who use higher level libraries like Django or SQLAlchemy. We use and love PostgreSQL with Psycopg2, but I recently realized that I didn&rsquo;t have a good grasp on how exactly psycopg2 implemented core database concepts: particularly transaction isolation and thread safety.
Here&rsquo;s what the documentation says regarding transactions:
Transactions are handled by the connection class."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://bbengfort.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Transaction Handling with Psycopg2","item":"https://bbengfort.github.io/2017/12/psycopg2-transactions/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Transaction Handling with Psycopg2","name":"Transaction Handling with Psycopg2","description":"Databases are essential to most applications, however most database interaction is often overlooked by Python developers who use higher level libraries like Django or SQLAlchemy. We use and love PostgreSQL with Psycopg2, but I recently realized that I didn\u0026rsquo;t have a good grasp on how exactly psycopg2 implemented core database concepts: particularly transaction isolation and thread safety.\nHere\u0026rsquo;s what the documentation says regarding transactions:\nTransactions are handled by the connection class.","keywords":[],"articleBody":"Databases are essential to most applications, however most database interaction is often overlooked by Python developers who use higher level libraries like Django or SQLAlchemy. We use and love PostgreSQL with Psycopg2, but I recently realized that I didn’t have a good grasp on how exactly psycopg2 implemented core database concepts: particularly transaction isolation and thread safety.\nHere’s what the documentation says regarding transactions:\nTransactions are handled by the connection class. By default, the first time a command is sent to the database (using one of the cursors created by the connection), a new transaction is created. The following database commands will be executed in the context of the same transaction – not only the commands issued by the first cursor, but the ones issued by all the cursors created by the same connection. Should any command fail, the transaction will be aborted and no further command will be executed until a call to the rollback() method.\nTransactions are therefore connection specific. When you create a connection, you can create multiple cursors, the transaction begins when the first cursor issues an execute – all all commands executed by all cursors after that are part of the same transaction until commit or rollback. After any of these methods are called, the next transaction is started on the next execute call.\nThis brings up a very important point:\nBy default even a simple SELECT will start a transaction: in long-running programs, if no further action is taken, the session will remain “idle in transaction”, an undesirable condition for several reasons (locks are held by the session, tables bloat…). For long lived scripts, either make sure to terminate a transaction as soon as possible or use an autocommit connection.\nThis seems to indicate that when working directly with psycopg2, understanding transactions is essential to writing stable scripts. This post therefore details my notes and techniques for working more effectively with PostgreSQL from Python.\nDatabase Preliminaries In order to demonstrate the code in this blog post, we need a database. The classic database example taught to undergraduates is that of a bank account, so we’ll continue with that theme here! Sorry if this part is tedious, feel free to skip ahead. In a file, schema.sql, I defined the following schema as DDL (data definition language):\nDROP TABLE IF EXISTS users CASCADE; CREATE TABLE users ( id SERIAL PRIMARY KEY, username VARCHAR(255) UNIQUE, pin SMALLINT NOT NULL ); DROP TYPE IF EXISTS account_type CASCADE; CREATE TYPE account_type AS ENUM ('checking', 'savings'); DROP TABLE IF EXISTS accounts CASCADE; CREATE TABLE accounts ( id SERIAL PRIMARY KEY, type account_type, owner_id INTEGER NOT NULL, balance NUMERIC DEFAULT 0.0, CONSTRAINT positive_balance CHECK (balance \u003e= 0), FOREIGN KEY (owner_id) REFERENCES users (id) ); DROP TYPE IF EXISTS ledger_type CASCADE; CREATE TYPE ledger_type AS ENUM ('credit', 'debit'); DROP TABLE IF EXISTS ledger; CREATE TABLE ledger ( id SERIAL PRIMARY KEY, account_id INTEGER NOT NULL, date DATE NOT NULL DEFAULT CURRENT_DATE, type ledger_type NOT NULL, amount NUMERIC NOT NULL, FOREIGN KEY (account_id) REFERENCES accounts (id) ); This creates a simple database with two tables. The owners table contains a PIN code for verification. Owners can have one or more accounts, and accounts have the constraint that the balance can never fall below $0.00. We can also seed the database with some initial data:\nINSERT INTO users (id, username, pin) VALUES (1, 'alice', 1234), (2, 'bob', 9999); INSERT INTO accounts (type, owner_id, balance) VALUES ('checking', 1, 250.0), ('savings', 1, 5.00), ('checking', 2, 100.0), ('savings', 2, 2342.13); Moving to Python code we can add some template code to allow us to connect to the database and execute the SQL in our file above:\nimport os import psycopg2 as pg def connect(env=\"DATABASE_URL\"): url = os.getenv(env) if not url: raise ValueError(\"no database url specified\") return pg.connect(url) def createdb(conn, schema=\"schema.sql\"): with open(schema, 'r') as f: sql = f.read() try: with conn.cursor() as curs: curs.execute(sql) conn.commit() except Exception as e: conn.rollback() raise e The connect function looks for the database connection string in the environment variable $DATABASE_URL. Because database configuration code can contain passwords and network information it is always best to store it in the environment or in a local, secure configuration file that can only be accessed by the process and not checked in with code. The connection string should look something like: postgresql://user@localhost:5432/dbname.\nThe createdb function reads the SQL from the schema.sql file and executes it against the database. Note this is why we have the DROP TABLE IF EXISTS statements, so we can guarantee we always start with a fresh database when we run this script. This function also gives us our first glance at transactions and database interaction with Python.\nComplying with PEP 249 we create a connection to the database, then create a cursor from the connection. Cursors manage the execution of SQL against the database as well as data retrieval. We execute the SQL in our schema file, committing the transaction if no exceptions are raised, and rolling back if it fails. We will explore this more in the next section.\nTransaction Management A transaction consists of one or more related operations that represent a single unit of work. For example, in the bank account example you might have a deposit transaction that executes queries to look up the account and verify the user, add a record to a list of daily deposits, check if the daily deposit limit has been reached, then modify the account balance. All of these operations represent all of the steps required to perform a deposit.\nThe goal of a transaction is that when the transaction is complete, the database remains in a single consistent state. Consistency is often defined by invariants or constraints that describe at a higher level how the database should maintain information. From a programming perspective, if those constraints are violated an exception is raised. For example, the database has a positive_balance constraint, if the balance for an account goes below zero an exception is raised. When this constraint is violated the database must remain unchanged and all operations performed by the transaction must be rolled back. If the transaction was successful we can then commit the changes, which guarantee that the database has successfully applied our operation.\nSo why do we need to manage transactions? Consider the following code:\nconn = connect() curs = conn.cursor() try: # Execute a command that will raise a constraint curs.execute(\"UPDATE accounts SET balance=%s\", (-130.935,)) except Exception as e: print(e) # Constraint exception # Execute another command, but because of the previous exception: curs = conn.cursor() try: curs.execute(\"SELECT id, type FROM accounts WHERE owner_id=%s\", (1,)) except pg.InternalError as e: print(e) The first curs.execute triggers the constraint exception, which is caught and printed. However, the database is now in an inconsistent state. When you try to execute the second query, a psycopg2.InternalError is raised: \"current transaction is aborted, commands ignored until end of transaction block\". In order to continue with the application, conn.rollback() needs to be called to end the transaction and start a new one.\nNOTE: Using with conn.cursor() as curs: causes the same behavior, the context manager does not automatically clean up the state of the transaction.\nThis essentially means all transactions can be wrapped in a try block, if they conclude successfully they can be committed, however if they raise an exception, they must be rolled back. A basic decorator that does this is as follows:\nfrom functools import wraps def transaction(func): @wraps(func) def inner(*args, **kwargs): conn = connect() try: func(conn, *args, **kwargs) conn.commit() except Exception as e: conn.rollback() log.error(\"{} error: {}\".format(func.__name__, e)) finally: conn.close() return inner This decorator wraps the specified function, returning an inner function that injects a new connection as the first argument to the decorated function. If the decorated function raises an exception, the transaction is rolled back and the error is logged.\nThe decorator method is nice but the connection injection can be a bit weird. An alternative is a context manager that ensures the connection is committed or rolled back in a similar fashion:\nfrom contextlib import contextmanager @contextmanager def transaction(): try: conn = connect() yield conn conn.commit() except Exception as e: conn.rollback() log.error(\"db error: {}\".format(e)) finally: conn.close() This allows you to write code using with as follows:\nwith transaction() as conn: # do transaction The context manager allows you to easily compose two transactions inside a single function — of course this may be against the point. However, it is no problem to combine both the decorator and the context manager methods into two steps (more on this in isolation levels).\nATM Application So let’s talk about two specific transactions for an imaginary database application: deposit and withdraw. Each of these operations has several steps:\nValidate the user with the associated PIN Ensure the user owns the account being modified Write a ledger record with the credit or debit being applied On credit, ensure the daily deposit limit isn’t reached Modify the balance of the account Fetch the current balance to display to the user Each transaction will perform 6-7 distinct SQL queries: SELECT, INSERT, and UPDATE. If any of them fails, then the database should remain completely unchanged. Failure in this case is that an exception is raised, which is potentially the easiest thing to do when you have a stack of functions calling other functions. Let’s look at deposit first:\n@transaction def deposit(conn, user, pin, account, amount): # Step 1: authenticate the user via pin and verify account ownership authenticate(conn, user, pin, account) # Step 2: add the ledger record with the credit ledger(conn, account, \"credit\", amount) # Step 3: update the account value by adding the amount update_balance(conn, account, amount) # Fetch the current balance in the account and log it record = \"withdraw ${:0.2f} from account {} | current balance: ${:0.2f}\" log.info(record.format(amount, account, balance(conn, account))) This function simply calls other functions, passing the transaction context (in this case a connection as well as input details) to other functions which may or may not raise exceptions. Here are the two authenticate methods:\ndef authenticate(conn, user, pin, account=None): \"\"\" Returns an account id if the name is found and if the pin matches. \"\"\" with conn.cursor() as curs: sql = \"SELECT 1 AS authd FROM users WHERE username=%s AND pin=%s\" curs.execute(sql, (user, pin)) if curs.fetchone() is None: raise ValueError(\"could not validate user via PIN\") return True if account: # Verify account ownership if account is provided verify_account(conn, user, account) def verify_account(conn, user, account): \"\"\" Verify that the account is held by the user. \"\"\" with conn.cursor() as curs: sql = ( \"SELECT 1 AS verified FROM accounts a \" \"JOIN users u on u.id = a.owner_id \" \"WHERE u.username=%s AND a.id=%s\" ) curs.execute(sql, (user, account)) if curs.fetchone() is None: raise ValueError(\"account belonging to user not found\") return True The authenticate and verify_account functions basically look in the database to see if there is a record that matches the conditions — a user with a matching PIN in authenticate and a (user, account_id) pair in verify_account. Both of these functions rely on the UNIQUE constraint in the database for usernames and account ids. This example shows how the function call stack can get arbitrarily deep; verify_account is called by authenticate which is called by deposit. By raising an exception at any point in the stack, the transaction will proceed no further, protecting us from harm later in the transaction.\nNote also that neither of these functions have an @transaction decorator, this is because it is expected that they are called from within another transaction. They are independent operations, but they can be called independently in a transaction with the context manager.\nNext we insert a ledger record:\nMAX_DEPOSIT_LIMIT = 1000.00 def ledger(conn, account, record, amount): \"\"\" Add a ledger record with the amount being credited or debited. \"\"\" # Perform the insert with conn.cursor() as curs: sql = \"INSERT INTO ledger (account_id, type, amount) VALUES (%s, %s, %s)\" curs.execute(sql, (account, record, amount)) # If we are crediting the account, perform daily deposit verification if record == \"credit\": check_daily_deposit(conn, account) def check_daily_deposit(conn, account): \"\"\" Raise an exception if the deposit limit has been exceeded. \"\"\" with conn.cursor() as curs: sql = ( \"SELECT amount FROM ledger \" \"WHERE date=now()::date AND type='credit' AND account_id=%s\" ) curs.execute(sql, (account,)) total = sum(row[0] for row in curs.fetchall()) if total \u003e MAX_DEPOSIT_LIMIT: raise Exception(\"daily deposit limit has been exceeded!\") This is the first place that we modify the state of the database by inserting a ledger record. If, when we check_daily_deposit, we discover that our deposit limit has been exceeded for the day, an exception is raised that will rollback the transaction. This will ensure that the ledger record is not accidentally stored on disk. Finally we update the account balance:\ndef update_balance(conn, account, amount): \"\"\" Add the amount (or subtract if negative) to the account balance. \"\"\" amount = Decimal(amount) with conn.cursor() as curs: current = balance(conn, account) sql = \"UPDATE accounts SET balance=%s WHERE id=%s\" curs.execute(sql, (current+amount, account)) def balance(conn, account): with conn.cursor() as curs: curs.execute(\"SELECT balance FROM accounts WHERE id=%s\", (account,)) return curs.fetchone()[0] I’ll have more to say on update_balance when we discuss isolation levels, but suffice it to say, this is another place where if the transaction fails we want to ensure that our account is not modified! In order to complete the example, here is the withdraw transaction:\n@transaction def withdraw(conn, user, pin, account, amount): # Step 1: authenticate the user via pin and verify account ownership authenticate(conn, user, pin, account) # Step 2: add the ledger record with the debit ledger(conn, account, \"debit\", amount) # Step 3: update the account value by subtracting the amount update_balance(conn, account, amount * -1) # Fetch the current balance in the account and log it record = \"withdraw ${:0.2f} from account {} | current balance: ${:0.2f}\" log.info(record.format(amount, account, balance(conn, account))) This is similar but modifies the inputs to the various operations to decrease the amount of the account by a debit ledger record. We can run:\nif __name__ == '__main__': conn = connect() createdb(conn) # Successful deposit deposit('alice', 1234, 1, 785.0) # Successful withdrawal withdraw('alice', 1234, 1, 230.0) # Unsuccessful deposit deposit('alice', 1234, 1, 489.0) # Successful deposit deposit('bob', 9999, 2, 220.23) And we should see the following log records:\n2017-12-06 20:01:00,086 withdraw $785.00 from account 1 | current balance: $1035.00 2017-12-06 20:01:00,094 withdraw error: could not validate user via PIN 2017-12-06 20:01:00,103 withdraw $230.00 from account 1 | current balance: $805.00 2017-12-06 20:01:00,118 deposit error: daily deposit limit has been exceeded! 2017-12-06 20:01:00,130 withdraw $220.23 from account 2 | current balance: $225.23 This should set a baseline for creating simple and easy to use transactions in Python. However, if you remember your databases class as an undergraduate, things get more interesting when two transactions are occurring at the same time. We’ll explore that from a single process by looking at multi-threaded database connections.\nThreads Let’s consider how to run two transactions at the same time from within the same application. The simplest way to do this is to use the threading library to execute transactions simultaneously. How do you achieve thread safety when accessing the database? Back to the docs:\nConnection objects are thread-safe: many threads can access the same database either using separate sessions and creating a connection per thread or using the same connection and creating separate cursors. In DB API 2.0 parlance, Psycopg is level 2 thread safe.\nThis means that every thread must have its own conn object (which explore in the connection pool section). Any cursor created from the same connection object will be in the same transaction no matter the thread. We also want to consider how each transaction influences each other, and we’ll take a look at that first by exploring isolation levels and session state.\nSession State Let’s say that Alice and Charlie have a joint account, under Alice’s name. They both show up to ATMs at the same time, Alice tries to deposit $75 and then withdraw $25 and Charlie attempts to withdraw $300. We can simulate this with threads as follows:\nimport time import random import threading def op1(): time.sleep(random.random()) withdraw('alice', 1234, 1, 300.0) def op2(): time.sleep(random.random()) deposit('alice', 1234, 1, 75.0) withdraw('alice', 1234, 1, 25.0) threads = [ threading.Thread(target=op1), threading.Thread(target=op2), ] for t in threads: t.start() for t in threads: t.join() Depending on the timing, one of two things can happen. Charlie can get rejected as not having enough money in his account, and the final state of the database can be $300 or all transaction can succeed with the final state of the database set to $0. There are three transactions happening, two withdraw transactions and a deposit. Each of these transactions runs in isolation, meaning that they see the database how they started and any changes that they make; so if Charlie’s withdraw and Alice’s deposit happen simultaneously, Charlie will be rejected since it doesn’t know about the deposit until it’s finished. No matter what, the database will be left in the same state.\nHowever, for performance reasons, you may want to modify the isolation level for a particular transaction. Possible levels are as follows:\nREAD UNCOMMITTED: lowest isolation level, transaction may read values that are not yet committed (and may never be committed). READ COMMITTED: write locks are maintained but read locks are released after select, meaning two different values can be read in different parts of the transaction. REPEATABLE READ: keep both read and write locks so multiple reads return same values but phantom reads can occur. SERIALIZABLE: the highest isolation level: read, write, and range locks are maintained until the end of the transaction. DEFAULT: set by server configuration not Python, usually READ COMMITTED. Note that as the isolation level increases, the number of locks being maintained also increases, which severely impacts performance if there is lock contention or deadlocks. It is possible to set the isolation level on a per-transaction basis in order to improve performance of all transactions happening concurrently. To do this we must modify the session parameters on the connection, which modify the behavior of the transaction or statements that follow in that particular session. Additionally we can set the session to readonly, which does not allow writes to temporary tables (for performance and security) or to deferrable.\nDeferrability is very interesting in a transaction, because it modifies how database constraints are checked. Non-deferrable transactions immediately check the constraint after a statement is executed. This means that UPDATE accounts SET balance=-5.45 will immediately raise an exception. Deferrable transactions however wait until the transaction is concluded before checking the constraints. This allows you to write multiple overlapping operations that may put the database into a correct state by the end of the transaction, but potentially not during the transaction (this also overlaps with the performance of various isolation levels).\nIn order to change the session, we’ll use a context manager as we did before to modify the session for the transaction, then reset the session back to the defaults:\n@contextmanager def session(conn, isolation_level=None, readonly=None, deferrable=None): try: conn.set_session( isolation_level=isolation_level, readonly=readonly, deferrable=deferrable ) yield conn finally: # Reset the session to defaults conn.set_session(None, None, None, None) We can then use with to conduct transactions with different isolation levels:\nwith transaction() as conn: with session(conn, isolation_level=\"READ COMMITTED\") as conn: # Do transaction NOTE: There cannot be an ongoing transaction when the session is set therefore it is more common for me to set the isolation level, readonly, and deferrable inside of the transaction decorator, rather than using two separate context managers as shown above. Frankly, it is also common to set these properties on a per-process basis rather than on a per-transaction basis, therefore the session is set in connect.\nConnection Pools Connections cannot be shared across threads. In the threading example above, if we remove the @transaction decorator and pass the same connection into both operations as follows:\nconn = connect() def op1(): time.sleep(random.random()) withdraw(conn, 'alice', 1234, 1, 300.0) def op2(): time.sleep(random.random()) deposit(conn, 'alice', 1234, 1, 75.0) withdraw(conn, 'alice', 1234, 1, 25.0) If the op1 withdraw fires first, the exception will cause all of the op2 statements to also fail, since its in the same transaction. This essentially means that both op1 and op2 are in the same transaction even though they are in different threads!\nWe’ve avoided this so far by creating a new connection every time a transaction runs. However, connecting to the database can be expensive and in high-transaction workloads we may want to simply keep the connection open, but ensure they are only used by one transaction at a time. The solution is to use connection pools. We can modify our connect function as follows:\nfrom psycopg2.pool import ThreadedConnectionPool def connect(env=\"DATABASE_URL\", connections=2): \"\"\" Connect to the database using an environment variable. \"\"\" url = os.getenv(env) if not url: raise ValueError(\"no database url specified\") minconns = connections maxconns = connections * 2 return ThreadedConnectionPool(minconns, maxconns, url) This creates a thread-safe connection pool that establishes at least 2 connections and will go up to a maximum of 4 connections on demand. In order to use the pool object in our transaction decorator, we will have to connect when the decorator is imported, creating a global pool object:\npool = connect() @contextmanager def transaction(name=\"transaction\", **kwargs): # Get the session parameters from the kwargs options = { \"isolation_level\": kwargs.get(\"isolation_level\", None), \"readonly\": kwargs.get(\"readonly\", None), \"deferrable\": kwargs.get(\"deferrable\", None), } try: conn = pool.getconn() conn.set_session(**options) yield conn conn.commit() except Exception as e: conn.rollback() log.error(\"{} error: {}\".format(name, e)) finally: conn.reset() pool.putconn(conn) Using pool.getconn retrieves a connection from the pool (if one is available, blocking until one is ready), then when we’re done we can pool.putconn to release the connection object.\nConclusion This has been a ton of notes on more direct usage of psycopg2. Sorry I couldn’t write a more conclusive conclusion but it’s late and this post is now close to 4k words. Time to go get dinner!\nNotes I used logging as the primary output to this application. The logging was set up as follows:\nimport logging LOG_FORMAT = \"%(asctime)s %(message)s\" logging.basicConfig(level=logging.INFO, format=LOG_FORMAT) log = logging.getLogger('balance') For the complete code, see this gist.\n","wordCount":"3678","inLanguage":"en","datePublished":"2017-12-06T13:58:16Z","dateModified":"2017-12-06T13:58:16Z","author":{"@type":"Person","name":"Benjamin Bengfort"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://bbengfort.github.io/2017/12/psycopg2-transactions/"},"publisher":{"@type":"Organization","name":"Libelli","logo":{"@type":"ImageObject","url":"https://bbengfort.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://bbengfort.github.io accesskey=h title="Libelli (Alt + H)"><img src=/icon.png alt=logo aria-label=logo height=35>Libelli</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://bbengfort.github.io/archive/ title=archive><span>archive</span></a></li><li><a href=https://bbengfort.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://bbengfort.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://bbengfort.github.io/about/ title=about><span>about</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Transaction Handling with Psycopg2</h1><div class=post-meta>December 6, 2017&nbsp;·&nbsp;18 min&nbsp;·&nbsp;Benjamin Bengfort</div></header><div class=post-content><p>Databases are essential to most applications, however most database interaction is often overlooked by Python developers who use higher level libraries like Django or SQLAlchemy. We use and love PostgreSQL with Psycopg2, but I recently realized that I didn&rsquo;t have a good grasp on how exactly psycopg2 implemented core database concepts: particularly transaction isolation and thread safety.</p><p>Here&rsquo;s what the documentation says regarding transactions:</p><blockquote><p>Transactions are handled by the connection class. By default, the first time a command is sent to the database (using one of the cursors created by the connection), a new transaction is created. The following database commands will be executed in the context of the same transaction – not only the commands issued by the first cursor, but the ones issued by all the cursors created by the same connection. Should any command fail, the transaction will be aborted and no further command will be executed until a call to the rollback() method.</p></blockquote><p>Transactions are therefore connection specific. When you create a connection, you can create multiple cursors, the transaction begins when the first cursor issues an <code>execute</code> &ndash; all all commands executed by <em>all</em> cursors after that are part of the same transaction until <code>commit</code> or <code>rollback</code>. After any of these methods are called, the next transaction is started on the next <code>execute</code> call.</p><p>This brings up a very important point:</p><blockquote><p>By default even a simple SELECT will start a transaction: in long-running programs, if no further action is taken, the session will remain “idle in transaction”, an undesirable condition for several reasons (locks are held by the session, tables bloat…). For long lived scripts, either make sure to terminate a transaction as soon as possible or use an autocommit connection.</p></blockquote><p>This seems to indicate that when working directly with psycopg2, understanding transactions is essential to writing stable scripts. This post therefore details my notes and techniques for working more effectively with PostgreSQL from Python.</p><h2 id=database-preliminaries>Database Preliminaries<a hidden class=anchor aria-hidden=true href=#database-preliminaries>#</a></h2><p>In order to demonstrate the code in this blog post, we need a database. The classic database example taught to undergraduates is that of a bank account, so we&rsquo;ll continue with that theme here! Sorry if this part is tedious, feel free to skip ahead. In a file, <code>schema.sql</code>, I defined the following schema as DDL (data definition language):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>DROP</span> <span style=color:#66d9ef>TABLE</span> <span style=color:#66d9ef>IF</span> <span style=color:#66d9ef>EXISTS</span> users <span style=color:#66d9ef>CASCADE</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> users (
</span></span><span style=display:flex><span>    id SERIAL <span style=color:#66d9ef>PRIMARY</span> <span style=color:#66d9ef>KEY</span>,
</span></span><span style=display:flex><span>    username VARCHAR(<span style=color:#ae81ff>255</span>) <span style=color:#66d9ef>UNIQUE</span>,
</span></span><span style=display:flex><span>    pin SMALLINT <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span>
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>DROP</span> <span style=color:#66d9ef>TYPE</span> <span style=color:#66d9ef>IF</span> <span style=color:#66d9ef>EXISTS</span> account_type <span style=color:#66d9ef>CASCADE</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TYPE</span> account_type <span style=color:#66d9ef>AS</span> ENUM (<span style=color:#e6db74>&#39;checking&#39;</span>, <span style=color:#e6db74>&#39;savings&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>DROP</span> <span style=color:#66d9ef>TABLE</span> <span style=color:#66d9ef>IF</span> <span style=color:#66d9ef>EXISTS</span> accounts <span style=color:#66d9ef>CASCADE</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> accounts (
</span></span><span style=display:flex><span>    id SERIAL <span style=color:#66d9ef>PRIMARY</span> <span style=color:#66d9ef>KEY</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>type</span> account_type,
</span></span><span style=display:flex><span>    owner_id INTEGER <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span>,
</span></span><span style=display:flex><span>    balance NUMERIC <span style=color:#66d9ef>DEFAULT</span> <span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>CONSTRAINT</span> positive_balance <span style=color:#66d9ef>CHECK</span> (balance <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>),
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>FOREIGN</span> <span style=color:#66d9ef>KEY</span> (owner_id) <span style=color:#66d9ef>REFERENCES</span> users (id)
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>DROP</span> <span style=color:#66d9ef>TYPE</span> <span style=color:#66d9ef>IF</span> <span style=color:#66d9ef>EXISTS</span> ledger_type <span style=color:#66d9ef>CASCADE</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TYPE</span> ledger_type <span style=color:#66d9ef>AS</span> ENUM (<span style=color:#e6db74>&#39;credit&#39;</span>, <span style=color:#e6db74>&#39;debit&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>DROP</span> <span style=color:#66d9ef>TABLE</span> <span style=color:#66d9ef>IF</span> <span style=color:#66d9ef>EXISTS</span> ledger;
</span></span><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> ledger (
</span></span><span style=display:flex><span>    id SERIAL <span style=color:#66d9ef>PRIMARY</span> <span style=color:#66d9ef>KEY</span>,
</span></span><span style=display:flex><span>    account_id INTEGER <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span>,
</span></span><span style=display:flex><span>    date DATE <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span> <span style=color:#66d9ef>DEFAULT</span> <span style=color:#66d9ef>CURRENT_DATE</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>type</span> ledger_type <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span>,
</span></span><span style=display:flex><span>    amount NUMERIC <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>FOREIGN</span> <span style=color:#66d9ef>KEY</span> (account_id) <span style=color:#66d9ef>REFERENCES</span> accounts (id)
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><p>This creates a simple database with two tables. The owners table contains a PIN code for verification. Owners can have one or more accounts, and accounts have the constraint that the balance can never fall below $0.00. We can also seed the database with some initial data:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>INSERT</span> <span style=color:#66d9ef>INTO</span> users (id, username, pin) <span style=color:#66d9ef>VALUES</span>
</span></span><span style=display:flex><span>    (<span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#39;alice&#39;</span>, <span style=color:#ae81ff>1234</span>),
</span></span><span style=display:flex><span>    (<span style=color:#ae81ff>2</span>, <span style=color:#e6db74>&#39;bob&#39;</span>, <span style=color:#ae81ff>9999</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>INSERT</span> <span style=color:#66d9ef>INTO</span> accounts (<span style=color:#66d9ef>type</span>, owner_id, balance) <span style=color:#66d9ef>VALUES</span>
</span></span><span style=display:flex><span>    (<span style=color:#e6db74>&#39;checking&#39;</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>250</span>.<span style=color:#ae81ff>0</span>),
</span></span><span style=display:flex><span>    (<span style=color:#e6db74>&#39;savings&#39;</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>5</span>.<span style=color:#ae81ff>00</span>),
</span></span><span style=display:flex><span>    (<span style=color:#e6db74>&#39;checking&#39;</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>100</span>.<span style=color:#ae81ff>0</span>),
</span></span><span style=display:flex><span>    (<span style=color:#e6db74>&#39;savings&#39;</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>2342</span>.<span style=color:#ae81ff>13</span>);
</span></span></code></pre></div><p>Moving to Python code we can add some template code to allow us to connect to the database and execute the SQL in our file above:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> os
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> psycopg2 <span style=color:#66d9ef>as</span> pg
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>connect</span>(env<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;DATABASE_URL&#34;</span>):
</span></span><span style=display:flex><span>    url <span style=color:#f92672>=</span> os<span style=color:#f92672>.</span>getenv(env)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> url:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>ValueError</span>(<span style=color:#e6db74>&#34;no database url specified&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> pg<span style=color:#f92672>.</span>connect(url)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>createdb</span>(conn, schema<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;schema.sql&#34;</span>):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>with</span> open(schema, <span style=color:#e6db74>&#39;r&#39;</span>) <span style=color:#66d9ef>as</span> f:
</span></span><span style=display:flex><span>        sql <span style=color:#f92672>=</span> f<span style=color:#f92672>.</span>read()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>with</span> conn<span style=color:#f92672>.</span>cursor() <span style=color:#66d9ef>as</span> curs:
</span></span><span style=display:flex><span>            curs<span style=color:#f92672>.</span>execute(sql)
</span></span><span style=display:flex><span>            conn<span style=color:#f92672>.</span>commit()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>except</span> <span style=color:#a6e22e>Exception</span> <span style=color:#66d9ef>as</span> e:
</span></span><span style=display:flex><span>        conn<span style=color:#f92672>.</span>rollback()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>raise</span> e
</span></span></code></pre></div><p>The <code>connect</code> function looks for the database connection string in the environment variable <code>$DATABASE_URL</code>. Because database configuration code can contain passwords and network information it is always best to store it in the environment or in a local, secure configuration file that can only be accessed by the process and not checked in with code. The connection string should look something like: <code>postgresql://user@localhost:5432/dbname</code>.</p><p>The <code>createdb</code> function reads the SQL from the <code>schema.sql</code> file and executes it against the database. Note this is why we have the <code>DROP TABLE IF EXISTS</code> statements, so we can guarantee we always start with a fresh database when we run this script. This function also gives us our first glance at transactions and database interaction with Python.</p><p>Complying with <a href=https://www.python.org/dev/peps/pep-0249/>PEP 249</a> we create a connection to the database, then create a cursor from the connection. Cursors manage the execution of SQL against the database as well as data retrieval. We execute the SQL in our schema file, committing the transaction if no exceptions are raised, and rolling back if it fails. We will explore this more in the next section.</p><h2 id=transaction-management>Transaction Management<a hidden class=anchor aria-hidden=true href=#transaction-management>#</a></h2><p>A transaction consists of one or more related operations that represent a single unit of work. For example, in the bank account example you might have a deposit transaction that executes queries to look up the account and verify the user, add a record to a list of daily deposits, check if the daily deposit limit has been reached, then modify the account balance. All of these operations represent all of the steps required to perform a deposit.</p><p>The goal of a transaction is that when the transaction is complete, the database remains in a single consistent state. Consistency is often defined by invariants or constraints that describe at a higher level how the database should maintain information. From a programming perspective, if those constraints are violated an exception is raised. For example, the database has a <code>positive_balance</code> constraint, if the balance for an account goes below zero an exception is raised. When this constraint is violated the database <em>must remain unchanged</em> and all operations performed by the transaction must be <em>rolled back</em>. If the transaction was successful we can then <em>commit</em> the changes, which guarantee that the database has successfully applied our operation.</p><p>So why do we need to manage transactions? Consider the following code:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>conn <span style=color:#f92672>=</span> connect()
</span></span><span style=display:flex><span>curs <span style=color:#f92672>=</span> conn<span style=color:#f92672>.</span>cursor()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>    <span style=color:#75715e># Execute a command that will raise a constraint</span>
</span></span><span style=display:flex><span>    curs<span style=color:#f92672>.</span>execute(<span style=color:#e6db74>&#34;UPDATE accounts SET balance=</span><span style=color:#e6db74>%s</span><span style=color:#e6db74>&#34;</span>, (<span style=color:#f92672>-</span><span style=color:#ae81ff>130.935</span>,))
</span></span><span style=display:flex><span><span style=color:#66d9ef>except</span> <span style=color:#a6e22e>Exception</span> <span style=color:#66d9ef>as</span> e:
</span></span><span style=display:flex><span>    print(e) <span style=color:#75715e># Constraint exception</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Execute another command, but because of the previous exception:</span>
</span></span><span style=display:flex><span>curs <span style=color:#f92672>=</span> conn<span style=color:#f92672>.</span>cursor()
</span></span><span style=display:flex><span><span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>    curs<span style=color:#f92672>.</span>execute(<span style=color:#e6db74>&#34;SELECT id, type FROM accounts WHERE owner_id=</span><span style=color:#e6db74>%s</span><span style=color:#e6db74>&#34;</span>, (<span style=color:#ae81ff>1</span>,))
</span></span><span style=display:flex><span><span style=color:#66d9ef>except</span> pg<span style=color:#f92672>.</span>InternalError <span style=color:#66d9ef>as</span> e:
</span></span><span style=display:flex><span>    print(e)
</span></span></code></pre></div><p>The first <code>curs.execute</code> triggers the constraint exception, which is caught and printed. However, the database is now in an inconsistent state. When you try to execute the second query, a <code>psycopg2.InternalError</code> is raised: <code>"current transaction is aborted, commands ignored until end of transaction block"</code>. In order to continue with the application, <code>conn.rollback()</code> needs to be called to end the transaction and start a new one.</p><p><strong>NOTE</strong>: Using <code>with conn.cursor() as curs:</code> causes the same behavior, the context manager does not automatically clean up the state of the transaction.</p><p>This essentially means all transactions can be wrapped in a <code>try</code> block, if they conclude successfully they can be committed, however if they raise an exception, they must be rolled back. A basic decorator that does this is as follows:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> functools <span style=color:#f92672>import</span> wraps
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>transaction</span>(func):
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@wraps</span>(func)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>inner</span>(<span style=color:#f92672>*</span>args, <span style=color:#f92672>**</span>kwargs):
</span></span><span style=display:flex><span>        conn <span style=color:#f92672>=</span> connect()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>            func(conn, <span style=color:#f92672>*</span>args, <span style=color:#f92672>**</span>kwargs)
</span></span><span style=display:flex><span>            conn<span style=color:#f92672>.</span>commit()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>except</span> <span style=color:#a6e22e>Exception</span> <span style=color:#66d9ef>as</span> e:
</span></span><span style=display:flex><span>            conn<span style=color:#f92672>.</span>rollback()
</span></span><span style=display:flex><span>            log<span style=color:#f92672>.</span>error(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74> error: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span><span style=color:#f92672>.</span>format(func<span style=color:#f92672>.</span>__name__, e))
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>finally</span>:
</span></span><span style=display:flex><span>            conn<span style=color:#f92672>.</span>close()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> inner
</span></span></code></pre></div><p>This decorator wraps the specified function, returning an inner function that injects a new connection as the first argument to the decorated function. If the decorated function raises an exception, the transaction is rolled back and the error is logged.</p><p>The decorator method is nice but the connection injection can be a bit weird. An alternative is a <a href=https://docs.python.org/3/library/contextlib.html>context manager</a> that ensures the connection is committed or rolled back in a similar fashion:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> contextlib <span style=color:#f92672>import</span> contextmanager
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@contextmanager</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>transaction</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>        conn <span style=color:#f92672>=</span> connect()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>yield</span> conn
</span></span><span style=display:flex><span>        conn<span style=color:#f92672>.</span>commit()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>except</span> <span style=color:#a6e22e>Exception</span> <span style=color:#66d9ef>as</span> e:
</span></span><span style=display:flex><span>        conn<span style=color:#f92672>.</span>rollback()
</span></span><span style=display:flex><span>        log<span style=color:#f92672>.</span>error(<span style=color:#e6db74>&#34;db error: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span><span style=color:#f92672>.</span>format(e))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>finally</span>:
</span></span><span style=display:flex><span>        conn<span style=color:#f92672>.</span>close()
</span></span></code></pre></div><p>This allows you to write code using <code>with</code> as follows:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>with</span> transaction() <span style=color:#66d9ef>as</span> conn:
</span></span><span style=display:flex><span>    <span style=color:#75715e># do transaction</span>
</span></span></code></pre></div><p>The context manager allows you to easily compose two transactions inside a single function — of course this may be against the point. However, it is no problem to combine both the decorator and the context manager methods into two steps (more on this in isolation levels).</p><h3 id=atm-application>ATM Application<a hidden class=anchor aria-hidden=true href=#atm-application>#</a></h3><p>So let&rsquo;s talk about two specific transactions for an imaginary database application: deposit and withdraw. Each of these operations has several steps:</p><ol><li>Validate the user with the associated PIN</li><li>Ensure the user owns the account being modified</li><li>Write a ledger record with the credit or debit being applied</li><li>On credit, ensure the daily deposit limit isn&rsquo;t reached</li><li>Modify the balance of the account</li><li>Fetch the current balance to display to the user</li></ol><p>Each transaction will perform 6-7 distinct SQL queries: <code>SELECT</code>, <code>INSERT</code>, and <code>UPDATE</code>. If any of them fails, then the database should remain completely unchanged. Failure in this case is that an exception is raised, which is potentially the easiest thing to do when you have a stack of functions calling other functions. Let&rsquo;s look at <code>deposit</code> first:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#a6e22e>@transaction</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>deposit</span>(conn, user, pin, account, amount):
</span></span><span style=display:flex><span>    <span style=color:#75715e># Step 1: authenticate the user via pin and verify account ownership</span>
</span></span><span style=display:flex><span>    authenticate(conn, user, pin, account)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Step 2: add the ledger record with the credit</span>
</span></span><span style=display:flex><span>    ledger(conn, account, <span style=color:#e6db74>&#34;credit&#34;</span>, amount)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Step 3: update the account value by adding the amount</span>
</span></span><span style=display:flex><span>    update_balance(conn, account, amount)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Fetch the current balance in the account and log it</span>
</span></span><span style=display:flex><span>    record <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;withdraw $</span><span style=color:#e6db74>{:0.2f}</span><span style=color:#e6db74> from account </span><span style=color:#e6db74>{}</span><span style=color:#e6db74> | current balance: $</span><span style=color:#e6db74>{:0.2f}</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>    log<span style=color:#f92672>.</span>info(record<span style=color:#f92672>.</span>format(amount, account, balance(conn, account)))
</span></span></code></pre></div><p>This function simply calls other functions, passing the transaction context (in this case a connection as well as input details) to other functions which may or may not raise exceptions. Here are the two authenticate methods:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>authenticate</span>(conn, user, pin, account<span style=color:#f92672>=</span><span style=color:#66d9ef>None</span>):
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Returns an account id if the name is found and if the pin matches.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>with</span> conn<span style=color:#f92672>.</span>cursor() <span style=color:#66d9ef>as</span> curs:
</span></span><span style=display:flex><span>        sql <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;SELECT 1 AS authd FROM users WHERE username=</span><span style=color:#e6db74>%s</span><span style=color:#e6db74> AND pin=</span><span style=color:#e6db74>%s</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>        curs<span style=color:#f92672>.</span>execute(sql, (user, pin))
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> curs<span style=color:#f92672>.</span>fetchone() <span style=color:#f92672>is</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>ValueError</span>(<span style=color:#e6db74>&#34;could not validate user via PIN&#34;</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> account:
</span></span><span style=display:flex><span>        <span style=color:#75715e># Verify account ownership if account is provided</span>
</span></span><span style=display:flex><span>        verify_account(conn, user, account)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>verify_account</span>(conn, user, account):
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Verify that the account is held by the user.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>with</span> conn<span style=color:#f92672>.</span>cursor() <span style=color:#66d9ef>as</span> curs:
</span></span><span style=display:flex><span>        sql <span style=color:#f92672>=</span> (
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;SELECT 1 AS verified FROM accounts a &#34;</span>
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;JOIN users u on u.id = a.owner_id &#34;</span>
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;WHERE u.username=</span><span style=color:#e6db74>%s</span><span style=color:#e6db74> AND a.id=</span><span style=color:#e6db74>%s</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>        curs<span style=color:#f92672>.</span>execute(sql, (user, account))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> curs<span style=color:#f92672>.</span>fetchone() <span style=color:#f92672>is</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>ValueError</span>(<span style=color:#e6db74>&#34;account belonging to user not found&#34;</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>True</span>
</span></span></code></pre></div><p>The <code>authenticate</code> and <code>verify_account</code> functions basically look in the database to see if there is a record that matches the conditions — a user with a matching PIN in <code>authenticate</code> and a <code>(user, account_id)</code> pair in <code>verify_account</code>. Both of these functions rely on the <code>UNIQUE</code> constraint in the database for usernames and account ids. This example shows how the function call stack can get arbitrarily deep; <code>verify_account</code> is called by <code>authenticate</code> which is called by <code>deposit</code>. By raising an exception at any point in the stack, the transaction will proceed no further, protecting us from harm later in the transaction.</p><p>Note also that neither of these functions have an <code>@transaction</code> decorator, this is because it is expected that they are called from within another transaction. They are independent operations, but they can be called independently in a transaction with the context manager.</p><p>Next we insert a ledger record:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>MAX_DEPOSIT_LIMIT <span style=color:#f92672>=</span> <span style=color:#ae81ff>1000.00</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>ledger</span>(conn, account, record, amount):
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Add a ledger record with the amount being credited or debited.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Perform the insert</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>with</span> conn<span style=color:#f92672>.</span>cursor() <span style=color:#66d9ef>as</span> curs:
</span></span><span style=display:flex><span>        sql <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;INSERT INTO ledger (account_id, type, amount) VALUES (</span><span style=color:#e6db74>%s</span><span style=color:#e6db74>, </span><span style=color:#e6db74>%s</span><span style=color:#e6db74>, </span><span style=color:#e6db74>%s</span><span style=color:#e6db74>)&#34;</span>
</span></span><span style=display:flex><span>        curs<span style=color:#f92672>.</span>execute(sql, (account, record, amount))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># If we are crediting the account, perform daily deposit verification</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> record <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;credit&#34;</span>:
</span></span><span style=display:flex><span>        check_daily_deposit(conn, account)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>check_daily_deposit</span>(conn, account):
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Raise an exception if the deposit limit has been exceeded.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>with</span> conn<span style=color:#f92672>.</span>cursor() <span style=color:#66d9ef>as</span> curs:
</span></span><span style=display:flex><span>        sql <span style=color:#f92672>=</span> (
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;SELECT amount FROM ledger &#34;</span>
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;WHERE date=now()::date AND type=&#39;credit&#39; AND account_id=</span><span style=color:#e6db74>%s</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>        curs<span style=color:#f92672>.</span>execute(sql, (account,))
</span></span><span style=display:flex><span>        total <span style=color:#f92672>=</span> sum(row[<span style=color:#ae81ff>0</span>] <span style=color:#66d9ef>for</span> row <span style=color:#f92672>in</span> curs<span style=color:#f92672>.</span>fetchall())
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> total <span style=color:#f92672>&gt;</span> MAX_DEPOSIT_LIMIT:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>Exception</span>(<span style=color:#e6db74>&#34;daily deposit limit has been exceeded!&#34;</span>)
</span></span></code></pre></div><p>This is the first place that we modify the state of the database by inserting a ledger record. If, when we <code>check_daily_deposit</code>, we discover that our deposit limit has been exceeded for the day, an exception is raised that will <code>rollback</code> the transaction. This will ensure that the ledger record is not accidentally stored on disk. Finally we update the account balance:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>update_balance</span>(conn, account, amount):
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Add the amount (or subtract if negative) to the account balance.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    amount <span style=color:#f92672>=</span> Decimal(amount)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>with</span> conn<span style=color:#f92672>.</span>cursor() <span style=color:#66d9ef>as</span> curs:
</span></span><span style=display:flex><span>        current <span style=color:#f92672>=</span> balance(conn, account)
</span></span><span style=display:flex><span>        sql <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;UPDATE accounts SET balance=</span><span style=color:#e6db74>%s</span><span style=color:#e6db74> WHERE id=</span><span style=color:#e6db74>%s</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>        curs<span style=color:#f92672>.</span>execute(sql, (current<span style=color:#f92672>+</span>amount, account))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>balance</span>(conn, account):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>with</span> conn<span style=color:#f92672>.</span>cursor() <span style=color:#66d9ef>as</span> curs:
</span></span><span style=display:flex><span>        curs<span style=color:#f92672>.</span>execute(<span style=color:#e6db74>&#34;SELECT balance FROM accounts WHERE id=</span><span style=color:#e6db74>%s</span><span style=color:#e6db74>&#34;</span>, (account,))
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> curs<span style=color:#f92672>.</span>fetchone()[<span style=color:#ae81ff>0</span>]
</span></span></code></pre></div><p>I&rsquo;ll have more to say on <code>update_balance</code> when we discuss isolation levels, but suffice it to say, this is another place where if the transaction fails we want to ensure that our account is not modified! In order to complete the example, here is the <code>withdraw</code> transaction:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#a6e22e>@transaction</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>withdraw</span>(conn, user, pin, account, amount):
</span></span><span style=display:flex><span>    <span style=color:#75715e># Step 1: authenticate the user via pin and verify account ownership</span>
</span></span><span style=display:flex><span>    authenticate(conn, user, pin, account)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Step 2: add the ledger record with the debit</span>
</span></span><span style=display:flex><span>    ledger(conn, account, <span style=color:#e6db74>&#34;debit&#34;</span>, amount)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Step 3: update the account value by subtracting the amount</span>
</span></span><span style=display:flex><span>    update_balance(conn, account, amount <span style=color:#f92672>*</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Fetch the current balance in the account and log it</span>
</span></span><span style=display:flex><span>    record <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;withdraw $</span><span style=color:#e6db74>{:0.2f}</span><span style=color:#e6db74> from account </span><span style=color:#e6db74>{}</span><span style=color:#e6db74> | current balance: $</span><span style=color:#e6db74>{:0.2f}</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>    log<span style=color:#f92672>.</span>info(record<span style=color:#f92672>.</span>format(amount, account, balance(conn, account)))
</span></span></code></pre></div><p>This is similar but modifies the inputs to the various operations to decrease the amount of the account by a debit ledger record. We can run:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;__main__&#39;</span>:
</span></span><span style=display:flex><span>    conn <span style=color:#f92672>=</span> connect()
</span></span><span style=display:flex><span>    createdb(conn)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Successful deposit</span>
</span></span><span style=display:flex><span>    deposit(<span style=color:#e6db74>&#39;alice&#39;</span>, <span style=color:#ae81ff>1234</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>785.0</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Successful withdrawal</span>
</span></span><span style=display:flex><span>    withdraw(<span style=color:#e6db74>&#39;alice&#39;</span>, <span style=color:#ae81ff>1234</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>230.0</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Unsuccessful deposit</span>
</span></span><span style=display:flex><span>    deposit(<span style=color:#e6db74>&#39;alice&#39;</span>, <span style=color:#ae81ff>1234</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>489.0</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Successful deposit</span>
</span></span><span style=display:flex><span>    deposit(<span style=color:#e6db74>&#39;bob&#39;</span>, <span style=color:#ae81ff>9999</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>220.23</span>)
</span></span></code></pre></div><p>And we should see the following log records:</p><pre tabindex=0><code>2017-12-06 20:01:00,086 withdraw $785.00 from account 1 | current balance: $1035.00
2017-12-06 20:01:00,094 withdraw error: could not validate user via PIN
2017-12-06 20:01:00,103 withdraw $230.00 from account 1 | current balance: $805.00
2017-12-06 20:01:00,118 deposit error: daily deposit limit has been exceeded!
2017-12-06 20:01:00,130 withdraw $220.23 from account 2 | current balance: $225.23
</code></pre><p>This should set a baseline for creating simple and easy to use transactions in Python. However, if you remember your databases class as an undergraduate, things get more interesting when two transactions are occurring at the same time. We&rsquo;ll explore that from a single process by looking at multi-threaded database connections.</p><h2 id=threads>Threads<a hidden class=anchor aria-hidden=true href=#threads>#</a></h2><p>Let&rsquo;s consider how to run two transactions at the same time from within the same application. The simplest way to do this is to use the <code>threading</code> library to execute transactions simultaneously. How do you achieve thread safety when accessing the database? Back to the docs:</p><blockquote><p>Connection objects are thread-safe: many threads can access the same database either using separate sessions and creating a connection per thread or using the same connection and creating separate cursors. In DB API 2.0 parlance, Psycopg is level 2 thread safe.</p></blockquote><p>This means that every thread must have its own <code>conn</code> object (which explore in the connection pool section). Any cursor created from the same connection object will be in the same transaction no matter the thread. We also want to consider how each transaction influences each other, and we&rsquo;ll take a look at that first by exploring isolation levels and session state.</p><h3 id=session-state>Session State<a hidden class=anchor aria-hidden=true href=#session-state>#</a></h3><p>Let&rsquo;s say that Alice and Charlie have a joint account, under Alice&rsquo;s name. They both show up to ATMs at the same time, Alice tries to deposit $75 and then withdraw $25 and Charlie attempts to withdraw $300. We can simulate this with threads as follows:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> time
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> random
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> threading
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>op1</span>():
</span></span><span style=display:flex><span>    time<span style=color:#f92672>.</span>sleep(random<span style=color:#f92672>.</span>random())
</span></span><span style=display:flex><span>    withdraw(<span style=color:#e6db74>&#39;alice&#39;</span>, <span style=color:#ae81ff>1234</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>300.0</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>op2</span>():
</span></span><span style=display:flex><span>    time<span style=color:#f92672>.</span>sleep(random<span style=color:#f92672>.</span>random())
</span></span><span style=display:flex><span>    deposit(<span style=color:#e6db74>&#39;alice&#39;</span>, <span style=color:#ae81ff>1234</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>75.0</span>)
</span></span><span style=display:flex><span>    withdraw(<span style=color:#e6db74>&#39;alice&#39;</span>, <span style=color:#ae81ff>1234</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>25.0</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>threads <span style=color:#f92672>=</span> [
</span></span><span style=display:flex><span>    threading<span style=color:#f92672>.</span>Thread(target<span style=color:#f92672>=</span>op1),
</span></span><span style=display:flex><span>    threading<span style=color:#f92672>.</span>Thread(target<span style=color:#f92672>=</span>op2),
</span></span><span style=display:flex><span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> t <span style=color:#f92672>in</span> threads:
</span></span><span style=display:flex><span>    t<span style=color:#f92672>.</span>start()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> t <span style=color:#f92672>in</span> threads:
</span></span><span style=display:flex><span>    t<span style=color:#f92672>.</span>join()
</span></span></code></pre></div><p>Depending on the timing, one of two things can happen. Charlie can get rejected as not having enough money in his account, and the final state of the database can be $300 or all transaction can succeed with the final state of the database set to $0. There are three transactions happening, two <code>withdraw</code> transactions and a <code>deposit</code>. Each of these transactions runs in <em>isolation</em>, meaning that they see the database how they started and any changes that they make; so if Charlie&rsquo;s <code>withdraw</code> and Alice&rsquo;s <code>deposit</code> happen simultaneously, Charlie will be rejected since it doesn&rsquo;t know about the deposit until it&rsquo;s finished. No matter what, the database will be left in the same state.</p><p>However, for performance reasons, you may want to modify the isolation level for a particular transaction. Possible levels are as follows:</p><ol><li><code>READ UNCOMMITTED</code>: lowest isolation level, transaction may read values that are not yet committed (and may never be committed).</li><li><code>READ COMMITTED</code>: write locks are maintained but read locks are released after select, meaning two different values can be read in different parts of the transaction.</li><li><code>REPEATABLE READ</code>: keep both read and write locks so multiple reads return same values but <a href=https://en.wikipedia.org/wiki/Isolation_(database_systems)#Phantom_reads>phantom reads</a> can occur.</li><li><code>SERIALIZABLE</code>: the highest isolation level: read, write, and range locks are maintained until the end of the transaction.</li><li><code>DEFAULT</code>: set by server configuration not Python, usually <code>READ COMMITTED</code>.</li></ol><p>Note that as the isolation level increases, the number of locks being maintained also increases, which severely impacts performance if there is lock contention or deadlocks. It is possible to set the isolation level on a <em>per-transaction</em> basis in order to improve performance of all transactions happening concurrently. To do this we must modify the <em>session</em> parameters on the connection, which modify the behavior of the transaction or statements that follow in that particular session. Additionally we can set the session to <code>readonly</code>, which does not allow writes to temporary tables (for performance and security) or to <code>deferrable</code>.</p><p>Deferrability is very interesting in a transaction, because it modifies how database constraints are checked. Non-deferrable transactions immediately check the constraint after a statement is executed. This means that <code>UPDATE accounts SET balance=-5.45</code> will immediately raise an exception. Deferrable transactions however wait until the transaction is concluded before checking the constraints. This allows you to write multiple overlapping operations that may put the database into a correct state by the end of the transaction, but potentially not during the transaction (this also overlaps with the performance of various isolation levels).</p><p>In order to change the session, we&rsquo;ll use a context manager as we did before to modify the session for the transaction, then reset the session back to the defaults:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#a6e22e>@contextmanager</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>session</span>(conn, isolation_level<span style=color:#f92672>=</span><span style=color:#66d9ef>None</span>, readonly<span style=color:#f92672>=</span><span style=color:#66d9ef>None</span>, deferrable<span style=color:#f92672>=</span><span style=color:#66d9ef>None</span>):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>        conn<span style=color:#f92672>.</span>set_session(
</span></span><span style=display:flex><span>            isolation_level<span style=color:#f92672>=</span>isolation_level,
</span></span><span style=display:flex><span>            readonly<span style=color:#f92672>=</span>readonly,
</span></span><span style=display:flex><span>            deferrable<span style=color:#f92672>=</span>deferrable
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>yield</span> conn
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>finally</span>:
</span></span><span style=display:flex><span>        <span style=color:#75715e># Reset the session to defaults</span>
</span></span><span style=display:flex><span>        conn<span style=color:#f92672>.</span>set_session(<span style=color:#66d9ef>None</span>, <span style=color:#66d9ef>None</span>, <span style=color:#66d9ef>None</span>, <span style=color:#66d9ef>None</span>)
</span></span></code></pre></div><p>We can then use <code>with</code> to conduct transactions with different isolation levels:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>with</span> transaction() <span style=color:#66d9ef>as</span> conn:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>with</span> session(conn, isolation_level<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;READ COMMITTED&#34;</span>) <span style=color:#66d9ef>as</span> conn:
</span></span><span style=display:flex><span>        <span style=color:#75715e># Do transaction</span>
</span></span></code></pre></div><p><strong>NOTE</strong>: There cannot be an ongoing transaction when the session is set therefore it is more common for me to set the isolation level, readonly, and deferrable inside of the transaction decorator, rather than using two separate context managers as shown above. Frankly, it is also common to set these properties on a per-process basis rather than on a per-transaction basis, therefore the session is set in <code>connect</code>.</p><h3 id=connection-pools>Connection Pools<a hidden class=anchor aria-hidden=true href=#connection-pools>#</a></h3><p>Connections cannot be shared across threads. In the threading example above, if we remove the <code>@transaction</code> decorator and pass the same connection into both operations as follows:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>conn <span style=color:#f92672>=</span> connect()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>op1</span>():
</span></span><span style=display:flex><span>    time<span style=color:#f92672>.</span>sleep(random<span style=color:#f92672>.</span>random())
</span></span><span style=display:flex><span>    withdraw(conn, <span style=color:#e6db74>&#39;alice&#39;</span>, <span style=color:#ae81ff>1234</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>300.0</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>op2</span>():
</span></span><span style=display:flex><span>    time<span style=color:#f92672>.</span>sleep(random<span style=color:#f92672>.</span>random())
</span></span><span style=display:flex><span>    deposit(conn, <span style=color:#e6db74>&#39;alice&#39;</span>, <span style=color:#ae81ff>1234</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>75.0</span>)
</span></span><span style=display:flex><span>    withdraw(conn, <span style=color:#e6db74>&#39;alice&#39;</span>, <span style=color:#ae81ff>1234</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>25.0</span>)
</span></span></code></pre></div><p>If the <code>op1</code> withdraw fires first, the exception will cause all of the <code>op2</code> statements to also fail, since its in the same transaction. This essentially means that <em>both op1 and op2 are in the same transaction even though they are in different threads!</em></p><p>We&rsquo;ve avoided this so far by creating a new connection every time a transaction runs. However, connecting to the database can be expensive and in high-transaction workloads we may want to simply keep the connection open, but ensure they are only used by one transaction at a time. The solution is to use <em>connection pools</em>. We can modify our connect function as follows:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> psycopg2.pool <span style=color:#f92672>import</span> ThreadedConnectionPool
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>connect</span>(env<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;DATABASE_URL&#34;</span>, connections<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>):
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Connect to the database using an environment variable.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    url <span style=color:#f92672>=</span> os<span style=color:#f92672>.</span>getenv(env)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> url:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>ValueError</span>(<span style=color:#e6db74>&#34;no database url specified&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    minconns <span style=color:#f92672>=</span> connections
</span></span><span style=display:flex><span>    maxconns <span style=color:#f92672>=</span> connections <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ThreadedConnectionPool(minconns, maxconns, url)
</span></span></code></pre></div><p>This creates a thread-safe connection pool that establishes at least 2 connections and will go up to a maximum of 4 connections on demand. In order to use the pool object in our transaction decorator, we will have to connect when the decorator is imported, creating a global pool object:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>pool <span style=color:#f92672>=</span> connect()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@contextmanager</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>transaction</span>(name<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;transaction&#34;</span>, <span style=color:#f92672>**</span>kwargs):
</span></span><span style=display:flex><span>    <span style=color:#75715e># Get the session parameters from the kwargs</span>
</span></span><span style=display:flex><span>    options <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;isolation_level&#34;</span>: kwargs<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#34;isolation_level&#34;</span>, <span style=color:#66d9ef>None</span>),
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;readonly&#34;</span>: kwargs<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#34;readonly&#34;</span>, <span style=color:#66d9ef>None</span>),
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;deferrable&#34;</span>: kwargs<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#34;deferrable&#34;</span>, <span style=color:#66d9ef>None</span>),
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>        conn <span style=color:#f92672>=</span> pool<span style=color:#f92672>.</span>getconn()
</span></span><span style=display:flex><span>        conn<span style=color:#f92672>.</span>set_session(<span style=color:#f92672>**</span>options)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>yield</span> conn
</span></span><span style=display:flex><span>        conn<span style=color:#f92672>.</span>commit()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>except</span> <span style=color:#a6e22e>Exception</span> <span style=color:#66d9ef>as</span> e:
</span></span><span style=display:flex><span>        conn<span style=color:#f92672>.</span>rollback()
</span></span><span style=display:flex><span>        log<span style=color:#f92672>.</span>error(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74> error: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span><span style=color:#f92672>.</span>format(name, e))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>finally</span>:
</span></span><span style=display:flex><span>        conn<span style=color:#f92672>.</span>reset()
</span></span><span style=display:flex><span>        pool<span style=color:#f92672>.</span>putconn(conn)
</span></span></code></pre></div><p>Using <code>pool.getconn</code> retrieves a connection from the pool (if one is available, blocking until one is ready), then when we&rsquo;re done we can <code>pool.putconn</code> to release the connection object.</p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>This has been a ton of notes on more direct usage of psycopg2. Sorry I couldn&rsquo;t write a more conclusive conclusion but it&rsquo;s late and this post is now close to 4k words. Time to go get dinner!</p><h2 id=notes>Notes<a hidden class=anchor aria-hidden=true href=#notes>#</a></h2><p>I used logging as the primary output to this application. The logging was set up as follows:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> logging
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>LOG_FORMAT <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>%(asctime)s</span><span style=color:#e6db74> </span><span style=color:#e6db74>%(message)s</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>logging<span style=color:#f92672>.</span>basicConfig(level<span style=color:#f92672>=</span>logging<span style=color:#f92672>.</span>INFO, format<span style=color:#f92672>=</span>LOG_FORMAT)
</span></span><span style=display:flex><span>log <span style=color:#f92672>=</span> logging<span style=color:#f92672>.</span>getLogger(<span style=color:#e6db74>&#39;balance&#39;</span>)
</span></span></code></pre></div><p>For the complete code, see this <a href=https://gist.github.com/bbengfort/936b4b3db9d81d27204a81f6ad816e5d>gist</a>.</p></div><footer class=post-footer></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://bbengfort.github.io>Libelli</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById("menu");menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>