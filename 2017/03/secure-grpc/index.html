<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Secure gRPC with TLS/SSL | Libelli</title><meta name=keywords content><meta name=description content="One of the primary requirements for the systems we build is something we call the “minimum security requirement”. Although our systems are not designed specifically for high security applications, they must use minimum standards of encryption and authentication. For example, it seems obvious to me that a web application that stores passwords or credit card information would encrypt their data on disk on a per-record basis with a salted hash. In the same way, a distributed system must be able to handle encrypted blobs, encrypt all inter-node communication, and authenticate and sign all messages."><meta name=author content="Benjamin Bengfort"><link rel=canonical href=https://bbengfort.github.io/2017/03/secure-grpc/><link crossorigin=anonymous href=/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe+FVUFzPh7U=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://bbengfort.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://bbengfort.github.io/icon.png><link rel=icon type=image/png sizes=32x32 href=https://bbengfort.github.io/icon.png><link rel=apple-touch-icon href=https://bbengfort.github.io/apple-touch-icon-precomposed.png><link rel=mask-icon href=https://bbengfort.github.io/icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-D3BE7EHHVP"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-D3BE7EHHVP",{anonymize_ip:!1})}</script><meta property="og:title" content="Secure gRPC with TLS/SSL"><meta property="og:description" content="One of the primary requirements for the systems we build is something we call the “minimum security requirement”. Although our systems are not designed specifically for high security applications, they must use minimum standards of encryption and authentication. For example, it seems obvious to me that a web application that stores passwords or credit card information would encrypt their data on disk on a per-record basis with a salted hash. In the same way, a distributed system must be able to handle encrypted blobs, encrypt all inter-node communication, and authenticate and sign all messages."><meta property="og:type" content="article"><meta property="og:url" content="https://bbengfort.github.io/2017/03/secure-grpc/"><meta property="og:image" content="https://bbengfort.github.io/bear.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-03-03T09:41:39+00:00"><meta property="article:modified_time" content="2017-03-03T09:41:39+00:00"><meta property="og:site_name" content="Libelli"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://bbengfort.github.io/bear.png"><meta name=twitter:title content="Secure gRPC with TLS/SSL"><meta name=twitter:description content="One of the primary requirements for the systems we build is something we call the “minimum security requirement”. Although our systems are not designed specifically for high security applications, they must use minimum standards of encryption and authentication. For example, it seems obvious to me that a web application that stores passwords or credit card information would encrypt their data on disk on a per-record basis with a salted hash. In the same way, a distributed system must be able to handle encrypted blobs, encrypt all inter-node communication, and authenticate and sign all messages."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://bbengfort.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Secure gRPC with TLS/SSL","item":"https://bbengfort.github.io/2017/03/secure-grpc/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Secure gRPC with TLS/SSL","name":"Secure gRPC with TLS\/SSL","description":"One of the primary requirements for the systems we build is something we call the “minimum security requirement”. Although our systems are not designed specifically for high security applications, they must use minimum standards of encryption and authentication. For example, it seems obvious to me that a web application that stores passwords or credit card information would encrypt their data on disk on a per-record basis with a salted hash. In the same way, a distributed system must be able to handle encrypted blobs, encrypt all inter-node communication, and authenticate and sign all messages.","keywords":[],"articleBody":"One of the primary requirements for the systems we build is something we call the “minimum security requirement”. Although our systems are not designed specifically for high security applications, they must use minimum standards of encryption and authentication. For example, it seems obvious to me that a web application that stores passwords or credit card information would encrypt their data on disk on a per-record basis with a salted hash. In the same way, a distributed system must be able to handle encrypted blobs, encrypt all inter-node communication, and authenticate and sign all messages. This adds some overhead to the system but the cost of overhead is far smaller than the cost of a breach, and if minimum security is the baseline then the overhead is just an accepted part of doing business.\nFor inter-replica communication we are currently using gRPC, an multi-platform RPC framework that uses protocol buffers for message serialization (we have also used zeromq in the past). The nice part about gRPC is that it has authentication baked-in and promotes the use of SSL/TLS to authenticate and encrypt exchanges. The not so nice part is that while the gRPC tutorial has examples in Ruby, C++, C#, Python, Java, Node.js, and PHP there is no guide for Go (at the time of this post). This post is my attempt to figure it out.\nFrom the documentation:\ngRPC has SSL/TLS integration and promotes the use of SSL/TLS to authenticate the server, and encrypt all the data exchanged between the client and the server. Optional mechanisms are available for clients to provide certificates for mutual authentication.\nI’m primarily interested in the first part — authenticate the server and encrypt the data exchanged. However, the idea of mutual TLS is something I hadn’t considered before this investigation. My original plan was to use Hawk client authentication and message signatures. But potentially that’s not something I have to do. So this post has two phases:\nEncrypted communication using TLS/SSL from the server Authenticated, mutual TLS using a certificate authority Since all replicas in my system are both servers and clients, I think that it wouldn’t make much sense not to do mutual TLS. After all, we’re already creating certificates and exchanging keys and whatnot.\nCreating SSL/TLS Certificates It seems like step one is to generate certificates and key files for encrypting communication. I thought this would be fairly straightforward using openssl from the command line, and it is (kind of) though there are a lot of things to consider. First, the files we need to generate:\nserver.key: a private RSA key to sign and authenticate the public key server.pem/server.crt: self-signed X.509 public keys for distribution rootca.crt: a certificate authority public key for signing .csr files host.csr: a certificate signing request to access the CA So there are a lot of files and a lot of extensions, many of which are duplicates or synonyms (or simply different encodings). I think that’s primarily what’s made this process so difficult. So to generate some simple .key/.crt pairs using openssl:\n$ openssl genrsa -out server.key 2048 $ openssl req -new -x509 -sha256 -key server.key \\ -out server.crt -days 3650 The first command will generate a 2048 bit RSA key (stronger keys are available as well). The second command will generate the certificate, and will also prompt you for some questions about the location, organization, and contact of the certificate holder. These fields are pretty straight forward, but probably the most important field is the “Common Name” which is typically composed of the host, domain, or IP address related to the certificate. The name is then used during verification and if the host doesn’t match the common name a warning is raised.\nFinally, to generate a certificate signing request (.csr) using openssl:\n$ openssl req -new -sha256 -key server.key -out server.csr $ openssl x509 -req -sha256 -in server.csr -signkey server.key \\ -out server.crt -days 3650 So this is pretty straightforward on the command line. However, it may be simpler to use certstrap, a simple certificate manager written in Go by the folks at Square. The app avoids dealing with openssl (and therefore raises questions about security in implementation), but has a very simple workflow: create a certificate authority, sign certificates with it.\nTo create a new certificate authority:\n$ certstrap init --common-name \"umd.fluidfs.com\" Created out/umd.fluidfs.com.key Created out/umd.fluidfs.com.crt Created out/umd.fluidfs.com.crl To request a certificate for a specific host:\n$ certstrap request-cert -ip 192.168.1.18 Created out/192.168.1.18.key Created out/192.168.1.18.csr And finally to generate the certificate for the host:\n$ certstrap sign 192.168.1.18 --CA umd.fluidfs.com Created out/192.168.1.18.crt from out/192.168.1.18.csr signed by out/umd.fluidfs.com.key Probably the most interesting opportunity for me is the ability to use certstrap programmatically to automatically generate keys. However, some review will have to be done into how safe it is.\nEncrypted Server The simplest method to encrypt communication using gRPC is to use server-side TLS. This means that the server needs to be initialized with a public/private key pair and the client needs to have the server’s public key in order to make the connection. I’ve created a small application called sping (secure ping) that basically does an echo request from a client to a server (example repository). The server code is as follows:\nvar ( crt = \"server.crt\" key = \"server.key\" ) func (s *PingServer) Serve(addr string) error { // Create the channel to listen on lis, err := net.Listen(\"tcp\", addr) if err != nil { return fmt.Errorf(\"could not list on %s: %s\", addr, err) } // Create the TLS credentials creds, err := credentials.NewServerTLSFromFile(crt, key) if err != nil { return fmt.Errorf(\"could not load TLS keys: %s\", err) } // Create the gRPC server with the credentials srv := grpc.NewServer(grpc.Creds(creds)) // Register the handler object pb.RegisterSecurePingServer(srv, s) // Serve and Listen if err := srv.Serve(lis); err != nil { return fmt.Errorf(\"grpc serve error: %s\", err) } return nil } So the steps to the server are pretty straight forward. First, create a TCP connection on the desired address (e.g. pass in \":3264\" to listen on the external address on port 3264). Second, load the TLS credentials from their respective key files (both the private and the public keys), then initialize the grpc server with the credentials. Finally, register the handler for the service you implemented (here I’m using a method call on a struct that does implement the handler) and serve.\nTo get the client connected, you need to give it the server.crt (or server.pem) public key. In normal operation, this key can be fetched from a certificate authority, but since we’re doing internal RPC, the public key must be shipped with the application.\nvar cert = \"server.crt\" func (c *PingClient) Ping(addr string, ping *pb.Ping) error { // Create the client TLS credentials creds, err := credentials.NewClientTLSFromFile(cert, \"\") if err != nil { return fmt.Errorf(\"could not load tls cert: %s\", err) } // Create a connection with the TLS credentials conn, err := grpc.Dial(addr, grpc.WithTransportCredentials(creds)) if err != nil { return fmt.Errorf(\"could not dial %s: %s\", addr, err) } // Initialize the client and make the request client := pb.NewSecurePingClient(conn) pong, err := client.Echo(context.Background(), ping) if err != nil { return fmt.Errof(\"could not ping %s: %s\", addr, err) } // Log the ping log.Printf(\"%s\\n\", pong.String()) return nil } Again, this is a fairly straight forward process that adds only three lines and modifies one from the original code. First load the server public key from a file into the credentials object, then pass the transport credentials into the grpc dialer. This will cause GRPC to initiate the TLS handshake every time it sends an echo RPC.\nMutual TLS with Certificate Authority The real problem with using the above method and HAWK authentication is that every single replica will have to maintain both a server public key and a HAWK key for every other node in the system. That frankly sounds like a headache to me. Instead, we’ll have every replica (client and server both) load their own public/private key pairs, then load the public keys of a CA (certificate authority) .crt file. Because all client public keys are signed by the CA key, the server and client can exchange and authenticate private keys during communication.\nCAVEAT: when a client connects to a server, it must know the ServerName property to pass into the tls.Config object. This ServerName appears to have to be in agreement with the common name in the certificate.\nThe server code is now modified to create X.509 key pairs directly and to create a certificate pool based on the certificate authority public key.\nvar ( crt = \"server.crt\" key = \"server.key\" ca = \"ca.crt\" ) func (s *PingServer) Serve(addr string) error { // Load the certificates from disk certificate, err := tls.LoadX509KeyPair(crt, key) if err != nil { return fmt.Errorf(\"could not load server key pair: %s\", err) } // Create a certificate pool from the certificate authority certPool := x509.NewCertPool() ca, err := ioutil.ReadFile(ca) if err != nil { return fmt.Errorf(\"could not read ca certificate: %s\", err) } // Append the client certificates from the CA if ok := certPool.AppendCertsFromPEM(ca); !ok { return errors.New(\"failed to append client certs\") } // Create the channel to listen on lis, err := net.Listen(\"tcp\", addr) if err != nil { return fmt.Errorf(\"could not list on %s: %s\", addr, err) } // Create the TLS credentials creds := credentials.NewTLS(\u0026tls.Config{ ClientAuth: tls.RequireAndVerifyClientCert, Certificates: []tls.Certificate{certificate}, ClientCAs: certPool, }) // Create the gRPC server with the credentials srv := grpc.NewServer(grpc.Creds(creds)) // Register the handler object pb.RegisterSecurePingServer(srv, s) // Serve and Listen if err := srv.Serve(lis); err != nil { return fmt.Errorf(\"grpc serve error: %s\", err) } return nil } So quite a bit more work here than in the first version. First, we load the server key pair from disk into a tls.Certificate struct. Then we create a certificate pool, read the CA certificate from disk and append it to the pool. That done, we can create our TLS credentials. Importantly, our server will require client certificates for verification, and we specify the pool as our client certificate authority. Finally we pass our certificates into the configuration and create new TLS grpc server options, passing them into the grpc.NewServer function. The client code is very similar:\nvar ( crt = \"client.crt\" key = \"client.key\" ca = \"ca.crt\" ) func (c *PingClient) Ping(addr string, ping *pb.Ping) error { // Load the client certificates from disk certificate, err := tls.LoadX509KeyPair(crt, key) if err != nil { return fmt.Errorf(\"could not load client key pair: %s\", err) } // Create a certificate pool from the certificate authority certPool := x509.NewCertPool() ca, err := ioutil.ReadFile(ca) if err != nil { return fmt.Errorf(\"could not read ca certificate: %s\", err) } // Append the certificates from the CA if ok := certPool.AppendCertsFromPEM(ca); !ok { return errors.New(\"failed to append ca certs\") } creds := credentials.NewTLS(\u0026tls.Config{ ServerName: addr, // NOTE: this is required! Certificates: []tls.Certificate{certificate}, RootCAs: certPool, }) // Create a connection with the TLS credentials conn, err := grpc.Dial(addr, grpc.WithTransportCredentials(creds)) if err != nil { return fmt.Errorf(\"could not dial %s: %s\", addr, err) } // Initialize the client and make the request client := pb.NewSecurePingClient(conn) pong, err := client.Echo(context.Background(), ping) if err != nil { return fmt.Errof(\"could not ping %s: %s\", addr, err) } // Log the ping log.Printf(\"%s\\n\", pong.String()) return nil } The primary difference here being that we load client certificates as opposed to the server certificate and that we specify RootCAs instead of ClientCAs in the TLS config. One final, important point, is that we also must specify the ServerName, whose value must match the common name on the certificate.\nGo Client In this section, I will describe the method for a client connecting to a secure RPC in the same style as the gRPC authentication examples. These examples use the greeter quick start code and perhaps they can be contributed back to the grpc.io documentation. Frankly, though, they’re just a guess so hopefully the PR I submitted gets reviewed thoroughly.\nBase case - No encryption or authentication import ( \"google.golang.org/grpc\" pb \"google.golang.org/grpc/examples/helloworld/helloworld\" ) channel, _ := grpc.Dial(\"localhost:50051\", grpc.WithInsecure()) client := pb.NewGreeterClient(channel) With server authentication SSL/TLS import \"google.golang.org/grpc/credentials\" creds := credentials.NewClientTLSFromFile(\"roots.pem\", \"\") channel, _ := grpc.Dial( \"localhost:443\", grpc.WithTransportCredentials(creds) ) client := pb.NewGreeterClient(channel) Authenticate with Google import \"google.golang.org/grpc/credentials/oauth\" auth, _ := oauth.NewApplicationDefault(context.Background(), \"\") channel, _ := grpc.Dial( \"greeter.googleapis.com\", grpc.WithPerRPCCredentials(auth) ) client := pb.NewGreeterClient(channel) Conclusion Always use SSL/TLS to encrypt communications and authenticate nodes. It is an open question about how to manage certificates in a larger system, but potentially an internal certificate authority resolves these problems. Getting secure communications up and running isn’t necessarily the easiest part of distributed systems, but it is worth taking the time out to do it right. And finally, gRPC, please update your documentation.\nOther Resources:\nSecure Ping on GitHub Using gRPC with Mutual TLS in Golang Simple GolangHTTPS/TLS Examples ","wordCount":"2128","inLanguage":"en","datePublished":"2017-03-03T09:41:39Z","dateModified":"2017-03-03T09:41:39Z","author":{"@type":"Person","name":"Benjamin Bengfort"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://bbengfort.github.io/2017/03/secure-grpc/"},"publisher":{"@type":"Organization","name":"Libelli","logo":{"@type":"ImageObject","url":"https://bbengfort.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bbengfort.github.io accesskey=h title="Libelli (Alt + H)"><img src=https://bbengfort.github.io/icon.png alt aria-label=logo height=35>Libelli</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://bbengfort.github.io/archive/ title=archive><span>archive</span></a></li><li><a href=https://bbengfort.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://bbengfort.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://bbengfort.github.io/about/ title=about><span>about</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://bbengfort.github.io>Home</a>&nbsp;»&nbsp;<a href=https://bbengfort.github.io/posts/>Posts</a></div><h1 class=post-title>Secure gRPC with TLS/SSL</h1><div class=post-meta><span title='2017-03-03 09:41:39 +0000 UTC'>March 3, 2017</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;2128 words&nbsp;·&nbsp;Benjamin Bengfort&nbsp;|&nbsp;<a href=https://github.com/bbengfort/bbengfort.github.io/tree/main/content/posts/2017-03-03-secure-grpc.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>One of the primary requirements for the systems we build is something we call the “minimum security requirement”. Although our systems are not designed specifically for high security applications, they must use minimum standards of encryption and authentication. For example, it seems obvious to me that a web application that <a href=https://docs.djangoproject.com/en/1.10/topics/auth/passwords/>stores passwords</a> or <a href=https://www.pcisecuritystandards.org/>credit card information</a> would encrypt their data on disk on a per-record basis with a <a href=https://www.codeproject.com/Articles/704865/Salted-Password-Hashing-Doing-it-Right>salted hash</a>. In the same way, a distributed system must be able to handle <a href=https://www.usenix.org/legacy/event/osdi04/tech/full_papers/li_j/li_j.pdf>encrypted blobs</a>, <a href=http://blog.cloudera.com/blog/2013/03/how-to-set-up-a-hadoop-cluster-with-network-encryption/>encrypt all inter-node communication</a>, and <a href=https://alexbilbie.com/2012/11/hawk-a-new-http-authentication-scheme/>authenticate and sign all messages</a>. This adds some overhead to the system but the cost of overhead is far smaller than the cost of a breach, and if minimum security is the baseline then the overhead is just an accepted part of doing business.</p><p>For inter-replica communication we are currently using <a href=http://www.grpc.io/>gRPC</a>, an multi-platform RPC framework that uses <a href=https://developers.google.com/protocol-buffers/>protocol buffers</a> for message serialization (we have also used <a href=http://zeromq.org/>zeromq</a> in the past). The nice part about gRPC is that it has <a href=http://www.grpc.io/docs/guides/auth.html>authentication baked-in</a> and promotes the use of SSL/TLS to authenticate and encrypt exchanges. The not so nice part is that while the gRPC tutorial has examples in <a href=http://www.grpc.io/docs/guides/auth.html#ruby>Ruby</a>, <a href=http://www.grpc.io/docs/guides/auth.html#c>C++</a>, <a href=http://www.grpc.io/docs/guides/auth.html#c-1>C#</a>, <a href=http://www.grpc.io/docs/guides/auth.html#python>Python</a>, <a href=http://www.grpc.io/docs/guides/auth.html#java>Java</a>, <a href=http://www.grpc.io/docs/guides/auth.html#nodejs>Node.js</a>, and <a href=http://www.grpc.io/docs/guides/auth.html#php>PHP</a> there is no guide for Go (at the time of this post). This post is my attempt to figure it out.</p><p>From the <a href=http://www.grpc.io/docs/guides/auth.html>documentation</a>:</p><blockquote><p>gRPC has SSL/TLS integration and promotes the use of SSL/TLS to authenticate the server, and encrypt all the data exchanged between the client and the server. Optional mechanisms are available for clients to provide certificates for mutual authentication.</p></blockquote><p>I&rsquo;m primarily interested in the first part — authenticate the server and encrypt the data exchanged. However, the idea of <a href=https://en.wikipedia.org/wiki/Mutual_authentication>mutual TLS</a> is something I hadn&rsquo;t considered before this investigation. My original plan was to use <a href=https://github.com/hueniverse/hawk>Hawk</a> client authentication and message signatures. But potentially that&rsquo;s not something I have to do. So this post has two phases:</p><ol><li>Encrypted communication using TLS/SSL from the server</li><li>Authenticated, mutual TLS using a certificate authority</li></ol><p>Since all replicas in my system are both servers and clients, I think that it wouldn&rsquo;t make much sense not to do mutual TLS. After all, we&rsquo;re already creating certificates and exchanging keys and whatnot.</p><h2 id=creating-ssltls-certificates>Creating SSL/TLS Certificates<a hidden class=anchor aria-hidden=true href=#creating-ssltls-certificates>#</a></h2><p>It seems like step one is to generate certificates and key files for encrypting communication. I thought this would be fairly straightforward using <code>openssl</code> from the command line, and it is (kind of) though there are a lot of things to consider. First, the files we need to generate:</p><ul><li><code>server.key</code>: a private RSA key to sign and authenticate the public key</li><li><code>server.pem</code>/<code>server.crt</code>: self-signed <a href=https://en.wikipedia.org/wiki/X.509>X.509</a> public keys for distribution</li><li><code>rootca.crt</code>: a certificate authority public key for signing .csr files</li><li><code>host.csr</code>: a certificate signing request to access the CA</li></ul><p>So there are a lot of files and a lot of extensions, many of which are duplicates or synonyms (or simply different encodings). I think that&rsquo;s primarily what&rsquo;s made this process so difficult. So to generate some simple .key/.crt pairs using <code>openssl</code>:</p><pre tabindex=0><code>$ openssl genrsa -out server.key 2048
$ openssl req -new -x509 -sha256 -key server.key \
              -out server.crt -days 3650
</code></pre><p>The first command will generate a 2048 bit RSA key (stronger keys are available as well). The second command will generate the certificate, and will also prompt you for some questions about the location, organization, and contact of the certificate holder. These fields are pretty straight forward, but probably the most important field is the &ldquo;Common Name&rdquo; which is typically composed of the host, domain, or IP address related to the certificate. The name is then used during verification and if the host doesn&rsquo;t match the common name a warning is raised.</p><p>Finally, to generate a certificate signing request (.csr) using <code>openssl</code>:</p><pre tabindex=0><code>$ openssl req -new -sha256 -key server.key -out server.csr
$ openssl x509 -req -sha256 -in server.csr -signkey server.key \
               -out server.crt -days 3650
</code></pre><p>So this is pretty straightforward on the command line. However, it may be simpler to use <a href=https://github.com/square/certstrap>certstrap</a>, a simple certificate manager written in Go by the folks at <a href=http://square.github.io/>Square</a>. The app avoids dealing with openssl (and therefore raises questions about security in implementation), but has a very simple workflow: create a certificate authority, sign certificates with it.</p><p>To create a new certificate authority:</p><pre tabindex=0><code>$ certstrap init --common-name &#34;umd.fluidfs.com&#34;
Created out/umd.fluidfs.com.key
Created out/umd.fluidfs.com.crt
Created out/umd.fluidfs.com.crl
</code></pre><p>To request a certificate for a specific host:</p><pre tabindex=0><code>$ certstrap request-cert -ip 192.168.1.18
Created out/192.168.1.18.key
Created out/192.168.1.18.csr
</code></pre><p>And finally to generate the certificate for the host:</p><pre tabindex=0><code>$ certstrap sign 192.168.1.18 --CA umd.fluidfs.com
Created out/192.168.1.18.crt from out/192.168.1.18.csr signed by
out/umd.fluidfs.com.key
</code></pre><p>Probably the most interesting opportunity for me is the ability to use <code>certstrap</code> programmatically to automatically generate keys. However, some review will have to be done into how safe it is.</p><h2 id=encrypted-server>Encrypted Server<a hidden class=anchor aria-hidden=true href=#encrypted-server>#</a></h2><p>The simplest method to encrypt communication using gRPC is to use server-side TLS. This means that the server needs to be initialized with a public/private key pair and the client needs to have the server&rsquo;s public key in order to make the connection. I&rsquo;ve created a small application called <code>sping</code> (secure ping) that basically does an echo request from a client to a server (<a href=https://github.com/bbengfort/sping>example repository</a>). The server code is as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=nx>crt</span> <span class=p>=</span> <span class=s>&#34;server.crt&#34;</span>
</span></span><span class=line><span class=cl>    <span class=nx>key</span> <span class=p>=</span> <span class=s>&#34;server.key&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=nx>PingServer</span><span class=p>)</span> <span class=nf>Serve</span><span class=p>(</span><span class=nx>addr</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Create the channel to listen on
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>lis</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>net</span><span class=p>.</span><span class=nf>Listen</span><span class=p>(</span><span class=s>&#34;tcp&#34;</span><span class=p>,</span> <span class=nx>addr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;could not list on %s: %s&#34;</span><span class=p>,</span> <span class=nx>addr</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Create the TLS credentials
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>creds</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>credentials</span><span class=p>.</span><span class=nf>NewServerTLSFromFile</span><span class=p>(</span><span class=nx>crt</span><span class=p>,</span> <span class=nx>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;could not load TLS keys: %s&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Create the gRPC server with the credentials
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>srv</span> <span class=o>:=</span> <span class=nx>grpc</span><span class=p>.</span><span class=nf>NewServer</span><span class=p>(</span><span class=nx>grpc</span><span class=p>.</span><span class=nf>Creds</span><span class=p>(</span><span class=nx>creds</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Register the handler object
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>pb</span><span class=p>.</span><span class=nf>RegisterSecurePingServer</span><span class=p>(</span><span class=nx>srv</span><span class=p>,</span> <span class=nx>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Serve and Listen
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>srv</span><span class=p>.</span><span class=nf>Serve</span><span class=p>(</span><span class=nx>lis</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;grpc serve error: %s&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>So the steps to the server are pretty straight forward. First, create a TCP connection on the desired address (e.g. pass in <code>":3264"</code> to listen on the external address on port 3264). Second, load the TLS credentials from their respective key files (both the private and the public keys), then initialize the grpc server with the credentials. Finally, register the handler for the service you implemented (here I&rsquo;m using a method call on a struct that does implement the handler) and serve.</p><p>To get the client connected, you need to give it the <code>server.crt</code> (or <code>server.pem</code>) public key. In normal operation, this key can be fetched from a certificate authority, but since we&rsquo;re doing internal RPC, the public key must be shipped with the application.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>cert</span> <span class=p>=</span> <span class=s>&#34;server.crt&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>PingClient</span><span class=p>)</span> <span class=nf>Ping</span><span class=p>(</span><span class=nx>addr</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>ping</span> <span class=o>*</span><span class=nx>pb</span><span class=p>.</span><span class=nx>Ping</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Create the client TLS credentials
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>creds</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>credentials</span><span class=p>.</span><span class=nf>NewClientTLSFromFile</span><span class=p>(</span><span class=nx>cert</span><span class=p>,</span> <span class=s>&#34;&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;could not load tls cert: %s&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Create a connection with the TLS credentials
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>conn</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>grpc</span><span class=p>.</span><span class=nf>Dial</span><span class=p>(</span><span class=nx>addr</span><span class=p>,</span> <span class=nx>grpc</span><span class=p>.</span><span class=nf>WithTransportCredentials</span><span class=p>(</span><span class=nx>creds</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;could not dial %s: %s&#34;</span><span class=p>,</span> <span class=nx>addr</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Initialize the client and make the request
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>client</span> <span class=o>:=</span> <span class=nx>pb</span><span class=p>.</span><span class=nf>NewSecurePingClient</span><span class=p>(</span><span class=nx>conn</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>pong</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>client</span><span class=p>.</span><span class=nf>Echo</span><span class=p>(</span><span class=nx>context</span><span class=p>.</span><span class=nf>Background</span><span class=p>(),</span> <span class=nx>ping</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errof</span><span class=p>(</span><span class=s>&#34;could not ping %s: %s&#34;</span><span class=p>,</span> <span class=nx>addr</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Log the ping
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>log</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%s\n&#34;</span><span class=p>,</span> <span class=nx>pong</span><span class=p>.</span><span class=nf>String</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Again, this is a fairly straight forward process that adds only three lines and modifies one from the original code. First load the server public key from a file into the credentials object, then pass the transport credentials into the grpc dialer. This will cause GRPC to initiate the TLS handshake every time it sends an echo RPC.</p><h2 id=mutual-tls-with-certificate-authority>Mutual TLS with Certificate Authority<a hidden class=anchor aria-hidden=true href=#mutual-tls-with-certificate-authority>#</a></h2><p>The real problem with using the above method <em>and</em> HAWK authentication is that every single replica will have to maintain both a server public key and a HAWK key for every other node in the system. That frankly sounds like a headache to me. Instead, we&rsquo;ll have every replica (client and server both) load their own public/private key pairs, then load the public keys of a CA (certificate authority) .crt file. Because all client public keys are signed by the CA key, the server and client can exchange and authenticate private keys during communication.</p><p><strong>CAVEAT</strong>: when a client connects to a server, it must know the <code>ServerName</code> property to pass into the <code>tls.Config</code> object. This <code>ServerName</code> appears to have to be in agreement with the common name in the certificate.</p><p>The server code is now modified to create X.509 key pairs directly and to create a certificate pool based on the certificate authority public key.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=nx>crt</span> <span class=p>=</span> <span class=s>&#34;server.crt&#34;</span>
</span></span><span class=line><span class=cl>    <span class=nx>key</span> <span class=p>=</span> <span class=s>&#34;server.key&#34;</span>
</span></span><span class=line><span class=cl>    <span class=nx>ca</span>  <span class=p>=</span> <span class=s>&#34;ca.crt&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=nx>PingServer</span><span class=p>)</span> <span class=nf>Serve</span><span class=p>(</span><span class=nx>addr</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Load the certificates from disk
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>certificate</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>tls</span><span class=p>.</span><span class=nf>LoadX509KeyPair</span><span class=p>(</span><span class=nx>crt</span><span class=p>,</span> <span class=nx>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;could not load server key pair: %s&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Create a certificate pool from the certificate authority
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>certPool</span> <span class=o>:=</span> <span class=nx>x509</span><span class=p>.</span><span class=nf>NewCertPool</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>ca</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>ioutil</span><span class=p>.</span><span class=nf>ReadFile</span><span class=p>(</span><span class=nx>ca</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;could not read ca certificate: %s&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Append the client certificates from the CA
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>certPool</span><span class=p>.</span><span class=nf>AppendCertsFromPEM</span><span class=p>(</span><span class=nx>ca</span><span class=p>);</span> <span class=p>!</span><span class=nx>ok</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=s>&#34;failed to append client certs&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Create the channel to listen on
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>lis</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>net</span><span class=p>.</span><span class=nf>Listen</span><span class=p>(</span><span class=s>&#34;tcp&#34;</span><span class=p>,</span> <span class=nx>addr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;could not list on %s: %s&#34;</span><span class=p>,</span> <span class=nx>addr</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Create the TLS credentials
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>creds</span> <span class=o>:=</span> <span class=nx>credentials</span><span class=p>.</span><span class=nf>NewTLS</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>tls</span><span class=p>.</span><span class=nx>Config</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    	<span class=nx>ClientAuth</span><span class=p>:</span>   <span class=nx>tls</span><span class=p>.</span><span class=nx>RequireAndVerifyClientCert</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    	<span class=nx>Certificates</span><span class=p>:</span> <span class=p>[]</span><span class=nx>tls</span><span class=p>.</span><span class=nx>Certificate</span><span class=p>{</span><span class=nx>certificate</span><span class=p>},</span>
</span></span><span class=line><span class=cl>    	<span class=nx>ClientCAs</span><span class=p>:</span>    <span class=nx>certPool</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>})</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Create the gRPC server with the credentials
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>srv</span> <span class=o>:=</span> <span class=nx>grpc</span><span class=p>.</span><span class=nf>NewServer</span><span class=p>(</span><span class=nx>grpc</span><span class=p>.</span><span class=nf>Creds</span><span class=p>(</span><span class=nx>creds</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Register the handler object
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>pb</span><span class=p>.</span><span class=nf>RegisterSecurePingServer</span><span class=p>(</span><span class=nx>srv</span><span class=p>,</span> <span class=nx>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Serve and Listen
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>srv</span><span class=p>.</span><span class=nf>Serve</span><span class=p>(</span><span class=nx>lis</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;grpc serve error: %s&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>So quite a bit more work here than in the first version. First, we load the server key pair from disk into a <code>tls.Certificate</code> struct. Then we create a certificate pool, read the CA certificate from disk and append it to the pool. That done, we can create our TLS credentials. Importantly, our server will require client certificates for verification, and we specify the pool as our client certificate authority. Finally we pass our certificates into the configuration and create new TLS grpc server options, passing them into the <code>grpc.NewServer</code> function. The client code is very similar:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=nx>crt</span> <span class=p>=</span> <span class=s>&#34;client.crt&#34;</span>
</span></span><span class=line><span class=cl>    <span class=nx>key</span> <span class=p>=</span> <span class=s>&#34;client.key&#34;</span>
</span></span><span class=line><span class=cl>    <span class=nx>ca</span>  <span class=p>=</span> <span class=s>&#34;ca.crt&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>PingClient</span><span class=p>)</span> <span class=nf>Ping</span><span class=p>(</span><span class=nx>addr</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>ping</span> <span class=o>*</span><span class=nx>pb</span><span class=p>.</span><span class=nx>Ping</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Load the client certificates from disk
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>certificate</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>tls</span><span class=p>.</span><span class=nf>LoadX509KeyPair</span><span class=p>(</span><span class=nx>crt</span><span class=p>,</span> <span class=nx>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;could not load client key pair: %s&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Create a certificate pool from the certificate authority
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>certPool</span> <span class=o>:=</span> <span class=nx>x509</span><span class=p>.</span><span class=nf>NewCertPool</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>ca</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>ioutil</span><span class=p>.</span><span class=nf>ReadFile</span><span class=p>(</span><span class=nx>ca</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;could not read ca certificate: %s&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Append the certificates from the CA
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>certPool</span><span class=p>.</span><span class=nf>AppendCertsFromPEM</span><span class=p>(</span><span class=nx>ca</span><span class=p>);</span> <span class=p>!</span><span class=nx>ok</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=s>&#34;failed to append ca certs&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>creds</span> <span class=o>:=</span> <span class=nx>credentials</span><span class=p>.</span><span class=nf>NewTLS</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>tls</span><span class=p>.</span><span class=nx>Config</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>ServerName</span><span class=p>:</span>   <span class=nx>addr</span><span class=p>,</span> <span class=c1>// NOTE: this is required!
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>Certificates</span><span class=p>:</span> <span class=p>[]</span><span class=nx>tls</span><span class=p>.</span><span class=nx>Certificate</span><span class=p>{</span><span class=nx>certificate</span><span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=nx>RootCAs</span><span class=p>:</span>      <span class=nx>certPool</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>})</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Create a connection with the TLS credentials
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>conn</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>grpc</span><span class=p>.</span><span class=nf>Dial</span><span class=p>(</span><span class=nx>addr</span><span class=p>,</span> <span class=nx>grpc</span><span class=p>.</span><span class=nf>WithTransportCredentials</span><span class=p>(</span><span class=nx>creds</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;could not dial %s: %s&#34;</span><span class=p>,</span> <span class=nx>addr</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Initialize the client and make the request
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>client</span> <span class=o>:=</span> <span class=nx>pb</span><span class=p>.</span><span class=nf>NewSecurePingClient</span><span class=p>(</span><span class=nx>conn</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>pong</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>client</span><span class=p>.</span><span class=nf>Echo</span><span class=p>(</span><span class=nx>context</span><span class=p>.</span><span class=nf>Background</span><span class=p>(),</span> <span class=nx>ping</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errof</span><span class=p>(</span><span class=s>&#34;could not ping %s: %s&#34;</span><span class=p>,</span> <span class=nx>addr</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Log the ping
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>log</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%s\n&#34;</span><span class=p>,</span> <span class=nx>pong</span><span class=p>.</span><span class=nf>String</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The primary difference here being that we load <em>client certificates</em> as opposed to the server certificate and that we specify <code>RootCAs</code> instead of <code>ClientCAs</code> in the TLS config. One final, important point, is that we also must specify the <code>ServerName</code>, whose value must match the common name on the certificate.</p><h2 id=go-client>Go Client<a hidden class=anchor aria-hidden=true href=#go-client>#</a></h2><p>In this section, I will describe the method for a client connecting to a secure RPC in the same style as the <a href=http://www.grpc.io/docs/guides/auth.html#examples>gRPC authentication examples</a>. These examples use the <a href=http://www.grpc.io/docs/quickstart/go.html>greeter quick start</a> code and perhaps they can be contributed back to the grpc.io documentation. Frankly, though, they&rsquo;re just a guess so hopefully the <a href=https://github.com/grpc/grpc.github.io/pull/469/commits/331b5fa12c8932f66ab96c26661b1a6f77768d1a>PR</a> I submitted gets reviewed thoroughly.</p><h3 id=base-case---no-encryption-or-authentication>Base case - No encryption or authentication<a hidden class=anchor aria-hidden=true href=#base-case---no-encryption-or-authentication>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;google.golang.org/grpc&#34;</span>
</span></span><span class=line><span class=cl>    <span class=nx>pb</span> <span class=s>&#34;google.golang.org/grpc/examples/helloworld/helloworld&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>channel</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>grpc</span><span class=p>.</span><span class=nf>Dial</span><span class=p>(</span><span class=s>&#34;localhost:50051&#34;</span><span class=p>,</span> <span class=nx>grpc</span><span class=p>.</span><span class=nf>WithInsecure</span><span class=p>())</span>
</span></span><span class=line><span class=cl><span class=nx>client</span> <span class=o>:=</span> <span class=nx>pb</span><span class=p>.</span><span class=nf>NewGreeterClient</span><span class=p>(</span><span class=nx>channel</span><span class=p>)</span>
</span></span></code></pre></div><h3 id=with-server-authentication-ssltls>With server authentication SSL/TLS<a hidden class=anchor aria-hidden=true href=#with-server-authentication-ssltls>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;google.golang.org/grpc/credentials&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>creds</span> <span class=o>:=</span> <span class=nx>credentials</span><span class=p>.</span><span class=nf>NewClientTLSFromFile</span><span class=p>(</span><span class=s>&#34;roots.pem&#34;</span><span class=p>,</span> <span class=s>&#34;&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>channel</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>grpc</span><span class=p>.</span><span class=nf>Dial</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;localhost:443&#34;</span><span class=p>,</span> <span class=nx>grpc</span><span class=p>.</span><span class=nf>WithTransportCredentials</span><span class=p>(</span><span class=nx>creds</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>client</span> <span class=o>:=</span> <span class=nx>pb</span><span class=p>.</span><span class=nf>NewGreeterClient</span><span class=p>(</span><span class=nx>channel</span><span class=p>)</span>
</span></span></code></pre></div><h3 id=authenticate-with-google>Authenticate with Google<a hidden class=anchor aria-hidden=true href=#authenticate-with-google>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;google.golang.org/grpc/credentials/oauth&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>auth</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>oauth</span><span class=p>.</span><span class=nf>NewApplicationDefault</span><span class=p>(</span><span class=nx>context</span><span class=p>.</span><span class=nf>Background</span><span class=p>(),</span> <span class=s>&#34;&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>channel</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>grpc</span><span class=p>.</span><span class=nf>Dial</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;greeter.googleapis.com&#34;</span><span class=p>,</span> <span class=nx>grpc</span><span class=p>.</span><span class=nf>WithPerRPCCredentials</span><span class=p>(</span><span class=nx>auth</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>client</span> <span class=o>:=</span> <span class=nx>pb</span><span class=p>.</span><span class=nf>NewGreeterClient</span><span class=p>(</span><span class=nx>channel</span><span class=p>)</span>
</span></span></code></pre></div><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>Always use SSL/TLS to encrypt communications and authenticate nodes. It is an open question about how to manage certificates in a larger system, but potentially an internal certificate authority resolves these problems. Getting secure communications up and running isn&rsquo;t necessarily the easiest part of distributed systems, but it is worth taking the time out to do it right. And finally, gRPC, please update your documentation.</p><p>Other Resources:</p><ul><li><a href=https://github.com/bbengfort/sping>Secure Ping on GitHub</a></li><li><a href=http://krishicks.com/post/grpc-mutual-tls-golang/>Using gRPC with Mutual TLS in Golang</a></li><li><a href=https://gist.github.com/denji/12b3a568f092ab951456>Simple GolangHTTPS/TLS Examples</a></li></ul></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://bbengfort.github.io/2017/03/tls-grpc-benchmarks/><span class=title>« Prev</span><br><span>Benchmarking Secure gRPC</span></a>
<a class=next href=https://bbengfort.github.io/2017/02/synchronizing-structs/><span class=title>Next »</span><br><span>Synchronizing Structs for Safe Concurrency in Go</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://bbengfort.github.io>Libelli</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>