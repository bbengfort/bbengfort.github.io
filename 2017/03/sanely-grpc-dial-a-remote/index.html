<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Sanely gRPC Dial a Remote | Libelli</title><meta name=keywords content><meta name=description content="In my systems I need to handle failure; so unlike in a typical client-server relationship, I&rsquo;m prepared for the remote I&rsquo;m dialing to not be available. Unfortunately when you do this with gRPC-Go there are a couple of annoyances you have to address. They are (in order of solutions):
 Verbose connection logging Background and back-off for reconnection attempts Errors are not returned on demand. There is no ability to keep track of statistics  So first the logging."><meta name=author content="Benjamin Bengfort"><link rel=canonical href=https://bbengfort.github.io/2017/03/sanely-grpc-dial-a-remote/><link crossorigin=anonymous href=/assets/css/stylesheet.min.d0c0348c2d0cff14148d0e347258519d8df2ce53ce5ac32c7bd9a549182cb8ae.css integrity="sha256-0MA0jC0M/xQUjQ40clhRnY3yzlPOWsMse9mlSRgsuK4=" rel="preload stylesheet" as=style><link rel=preload href=/icon.png as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><link rel=icon href=https://bbengfort.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://bbengfort.github.io/icon.png><link rel=icon type=image/png sizes=32x32 href=https://bbengfort.github.io/icon.png><link rel=apple-touch-icon href=https://bbengfort.github.io/apple-touch-icon-precomposed.png><link rel=mask-icon href=https://bbengfort.github.io/icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.79.0"><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-8096804-11','auto');ga('send','pageview');}</script><meta property="og:title" content="Sanely gRPC Dial a Remote"><meta property="og:description" content="In my systems I need to handle failure; so unlike in a typical client-server relationship, I&rsquo;m prepared for the remote I&rsquo;m dialing to not be available. Unfortunately when you do this with gRPC-Go there are a couple of annoyances you have to address. They are (in order of solutions):
 Verbose connection logging Background and back-off for reconnection attempts Errors are not returned on demand. There is no ability to keep track of statistics  So first the logging."><meta property="og:type" content="article"><meta property="og:url" content="https://bbengfort.github.io/2017/03/sanely-grpc-dial-a-remote/"><meta property="og:image" content="https://bbengfort.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-03-21T16:27:39+00:00"><meta property="article:modified_time" content="2017-03-21T16:27:39+00:00"><meta property="og:site_name" content="Libelli"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://bbengfort.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Sanely gRPC Dial a Remote"><meta name=twitter:description content="In my systems I need to handle failure; so unlike in a typical client-server relationship, I&rsquo;m prepared for the remote I&rsquo;m dialing to not be available. Unfortunately when you do this with gRPC-Go there are a couple of annoyances you have to address. They are (in order of solutions):
 Verbose connection logging Background and back-off for reconnection attempts Errors are not returned on demand. There is no ability to keep track of statistics  So first the logging."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://bbengfort.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Sanely gRPC Dial a Remote","item":"https://bbengfort.github.io/2017/03/sanely-grpc-dial-a-remote/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Sanely gRPC Dial a Remote","name":"Sanely gRPC Dial a Remote","description":"In my systems I need to handle failure; so unlike in a typical client-server relationship, I\u0026rsquo;m prepared for the remote I\u0026rsquo;m dialing to not be available. Unfortunately when you do this with gRPC-Go there are a couple of annoyances you have to address. They are (in order of solutions):\n Verbose connection logging Background and back-off for reconnection attempts Errors are not returned on demand. There is no ability to keep track of statistics  So first the logging.","keywords":[],"articleBody":"In my systems I need to handle failure; so unlike in a typical client-server relationship, I’m prepared for the remote I’m dialing to not be available. Unfortunately when you do this with gRPC-Go there are a couple of annoyances you have to address. They are (in order of solutions):\n Verbose connection logging Background and back-off for reconnection attempts Errors are not returned on demand. There is no ability to keep track of statistics  So first the logging. When you dial an unavailable remote as follows:\nconn, err := grpc.Dial(addr, grpc.WithInsecure()) if err != nil { return err } client := pb.NewServiceClient(conn) resp = client.RPC() You will get a lot of log messages in the form of:\n2017/03/20 16:36:16 grpc: addrConn.resetTransport failed to create client transport: connection error: desc = \"transport: dial tcp 192.168.1.1:port: getsockopt: connection refused\"; Reconnecting to {addr:port } 2017/03/20 16:36:16 grpc: addrConn.resetTransport failed to create client 2017/03/20 16:36:16 grpc: addrConn.resetTransport failed to create client transport: connection error: desc = \"transport: dial tcp 192.168.1.1:port: getsockopt: connection refused\"; Reconnecting to {addr:port } 2017/03/20 16:36:16 grpc: addrConn.resetTransport failed to create client ... And by a lot, I mean … a lot; they will continue to spew for a while (probably at least 30 seconds). So to tackle that issue, we’ll turn off the logging by creating a noop (nop, no-op) logger that doesn’t do anything, and set it as the logger for grpclog. First the logger:\n As you can see, this logger meets the interface for a SetLogger() function, and we can set the grpc logger in our library’s init as follows:\nfunc init() { // Set the random seed to something different each time. \trand.Seed(time.Now().Unix()) // Stop the grpc verbose logging \tgrpclog.SetLogger(noplog) } Ok, onto the next two problems that are both solved with context. First, the call to grpc.Dial() happens in the background by default. This can cause panics due to nil dereference errors if you’re not careful. Block until connected as follows:\nconn, err := grpc.Dial(addr, grpc.WithInsecure(), grpc.WithBlock()) Now it’s up to you to handle concurrency with the connections. Of course blocking doesn’t make a whole lot of sense until you limit it. And in fact, no err will be returned from the function unless you cause it to error with a timeout.\nconn, err := grpc.Dial( addr, grpc.WithInsecure(), grpc.WithBlock(), grpc.WithTimeout(1 * time.Second) ) Note that the WithTimeout option does not do anything if WithBlock is not used as well.\nComing Soon: using WithStatsHandler() to address the fourth issue.\nAnd there is my basic start to managing the grpc.Dial function for scenarios when the remote may not be reachable. I’m sure there will be a lot more on this later.\n","wordCount":"442","inLanguage":"en","datePublished":"2017-03-21T16:27:39Z","dateModified":"2017-03-21T16:27:39Z","author":{"@type":"Person","name":"Benjamin Bengfort"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://bbengfort.github.io/2017/03/sanely-grpc-dial-a-remote/"},"publisher":{"@type":"Organization","name":"Libelli","logo":{"@type":"ImageObject","url":"https://bbengfort.github.io/favicon.ico"}}}</script></head><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme: #1d1e20;--entry: #2e2e33;--primary: rgba(255, 255, 255, 0.84);--secondary: rgba(255, 255, 255, 0.56);--tertiary: rgba(255, 255, 255, 0.16);--content: rgba(255, 255, 255, 0.74);--hljs-bg: #2e2e33;--code-bg: #37383e;--border: #333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://bbengfort.github.io accesskey=h title="Libelli (Alt + H)"><img src=/icon.png alt=logo aria-label=logo height=35>Libelli</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://bbengfort.github.io/archive/ title=archive><span>archive</span></a></li><li><a href=https://bbengfort.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://bbengfort.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://bbengfort.github.io/about/ title=about><span>about</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Sanely gRPC Dial a Remote</h1><div class=post-meta>March 21, 2017&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Benjamin Bengfort</div></header><div class=post-content><p>In my systems I need to handle failure; so unlike in a typical client-server relationship, I&rsquo;m prepared for the remote I&rsquo;m dialing to not be available. Unfortunately when you do this with <a href=https://godoc.org/google.golang.org/grpc>gRPC-Go</a> there are a couple of annoyances you have to address. They are (in order of solutions):</p><ol><li>Verbose connection logging</li><li>Background and back-off for reconnection attempts</li><li>Errors are not returned on demand.</li><li>There is no ability to keep track of statistics</li></ol><p>So first the logging. When you dial an unavailable remote as follows:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>conn</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>grpc</span>.<span style=color:#a6e22e>Dial</span>(<span style=color:#a6e22e>addr</span>, <span style=color:#a6e22e>grpc</span>.<span style=color:#a6e22e>WithInsecure</span>())
<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
}

<span style=color:#a6e22e>client</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>pb</span>.<span style=color:#a6e22e>NewServiceClient</span>(<span style=color:#a6e22e>conn</span>)
<span style=color:#a6e22e>resp</span> = <span style=color:#a6e22e>client</span>.<span style=color:#a6e22e>RPC</span>()
</code></pre></div><p>You will get a lot of log messages in the form of:</p><pre><code>2017/03/20 16:36:16 grpc: addrConn.resetTransport failed to create client transport: connection error: desc = &quot;transport: dial tcp 192.168.1.1:port: getsockopt: connection refused&quot;; Reconnecting to {addr:port &lt;nil&gt;}
2017/03/20 16:36:16 grpc: addrConn.resetTransport failed to create client 2017/03/20 16:36:16 grpc: addrConn.resetTransport failed to create client transport: connection error: desc = &quot;transport: dial tcp 192.168.1.1:port: getsockopt: connection refused&quot;; Reconnecting to {addr:port &lt;nil&gt;}
2017/03/20 16:36:16 grpc: addrConn.resetTransport failed to create client
...
</code></pre><p>And by a lot, I mean &mldr; a lot; they will continue to spew for a while (probably at least 30 seconds). So to tackle that issue, we&rsquo;ll turn off the logging by creating a noop (nop, no-op) logger that doesn&rsquo;t do anything, and set it as the logger for <code>grpclog</code>. First the logger:</p><script type=application/javascript src=https://gist.github.com/bbengfort/b9345330339dee7fc04d6153b1a2eb91.js></script><p>As you can see, this logger meets the interface for a <code>SetLogger()</code> function, and we can set the grpc logger in our library&rsquo;s init as follows:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>init</span>() {
	<span style=color:#75715e>// Set the random seed to something different each time.
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>rand</span>.<span style=color:#a6e22e>Seed</span>(<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>().<span style=color:#a6e22e>Unix</span>())

	<span style=color:#75715e>// Stop the grpc verbose logging
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>grpclog</span>.<span style=color:#a6e22e>SetLogger</span>(<span style=color:#a6e22e>noplog</span>)
}
</code></pre></div><p>Ok, onto the next two problems that are both solved with context. First, the call to <code>grpc.Dial()</code> happens in the background by default. This can cause panics due to nil dereference errors if you&rsquo;re not careful. Block until connected as follows:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>conn</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>grpc</span>.<span style=color:#a6e22e>Dial</span>(<span style=color:#a6e22e>addr</span>, <span style=color:#a6e22e>grpc</span>.<span style=color:#a6e22e>WithInsecure</span>(), <span style=color:#a6e22e>grpc</span>.<span style=color:#a6e22e>WithBlock</span>())
</code></pre></div><p>Now it&rsquo;s up to you to handle concurrency with the connections. Of course blocking doesn&rsquo;t make a whole lot of sense until you limit it. And in fact, no <code>err</code> will be returned from the function unless you cause it to error with a timeout.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>conn</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>grpc</span>.<span style=color:#a6e22e>Dial</span>(
        <span style=color:#a6e22e>addr</span>, <span style=color:#a6e22e>grpc</span>.<span style=color:#a6e22e>WithInsecure</span>(), <span style=color:#a6e22e>grpc</span>.<span style=color:#a6e22e>WithBlock</span>(),
        <span style=color:#a6e22e>grpc</span>.<span style=color:#a6e22e>WithTimeout</span>(<span style=color:#ae81ff>1</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>)
)
</code></pre></div><p>Note that the <code>WithTimeout</code> option does not do anything if <code>WithBlock</code> is not used as well.</p><p>Coming Soon: using <code>WithStatsHandler()</code> to address the fourth issue.</p><p>And there is my basic start to managing the <code>grpc.Dial</code> function for scenarios when the remote may not be reachable. I&rsquo;m sure there will be a lot more on this later.</p></div><footer class=post-footer></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://bbengfort.github.io>Libelli</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById('menu')
menu.scrollLeft=localStorage.getItem("menu-scroll-position");menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft);}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);if(!window.matchMedia('(prefers-reduced-motion: reduce)').matches){document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});}else{document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();}
if(id==="top"){history.replaceState(null,null," ");}else{history.pushState(null,null,`#${id}`);}});});</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script></body></html>