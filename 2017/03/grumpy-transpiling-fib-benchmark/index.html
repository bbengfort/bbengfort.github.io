<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>A Benchmark of Grumpy Transpiling | Libelli</title><meta name=keywords content><meta name=description content="On Tuesday evening I attended a Django District meetup on Grumpy, a transpiler from Python to Go. Because it was a Python meetup, the talk naturally focused on introducing Go to a Python audience, and because it was a Django meetup, we also focused on web services. The premise for Grumpy, as discussed in the announcing Google blog post, is also a web focused one — to take YouTube&rsquo;s API that&rsquo;s primarily written in Python and transpile it to Go to improve the overall performance and stability of YouTube&rsquo;s front-end services."><meta name=author content="Benjamin Bengfort"><link rel=canonical href=https://bbengfort.github.io/2017/03/grumpy-transpiling-fib-benchmark/><link crossorigin=anonymous href=/assets/css/stylesheet.min.2d6dbfc6e0f8a1db1c9d082a76dc11d094328cf63f247bbc2421dfaa7f2bb170.css integrity="sha256-LW2/xuD4odscnQgqdtwR0JQyjPY/JHu8JCHfqn8rsXA=" rel="preload stylesheet" as=style><link rel=preload href=/icon.png as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://bbengfort.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://bbengfort.github.io/icon.png><link rel=icon type=image/png sizes=32x32 href=https://bbengfort.github.io/icon.png><link rel=apple-touch-icon href=https://bbengfort.github.io/apple-touch-icon-precomposed.png><link rel=mask-icon href=https://bbengfort.github.io/icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.110.0"><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-8096804-11","auto"),ga("send","pageview"))</script><meta property="og:title" content="A Benchmark of Grumpy Transpiling"><meta property="og:description" content="On Tuesday evening I attended a Django District meetup on Grumpy, a transpiler from Python to Go. Because it was a Python meetup, the talk naturally focused on introducing Go to a Python audience, and because it was a Django meetup, we also focused on web services. The premise for Grumpy, as discussed in the announcing Google blog post, is also a web focused one — to take YouTube&rsquo;s API that&rsquo;s primarily written in Python and transpile it to Go to improve the overall performance and stability of YouTube&rsquo;s front-end services."><meta property="og:type" content="article"><meta property="og:url" content="https://bbengfort.github.io/2017/03/grumpy-transpiling-fib-benchmark/"><meta property="og:image" content="https://bbengfort.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-03-23T08:47:04+00:00"><meta property="article:modified_time" content="2017-03-23T08:47:04+00:00"><meta property="og:site_name" content="Libelli"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://bbengfort.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="A Benchmark of Grumpy Transpiling"><meta name=twitter:description content="On Tuesday evening I attended a Django District meetup on Grumpy, a transpiler from Python to Go. Because it was a Python meetup, the talk naturally focused on introducing Go to a Python audience, and because it was a Django meetup, we also focused on web services. The premise for Grumpy, as discussed in the announcing Google blog post, is also a web focused one — to take YouTube&rsquo;s API that&rsquo;s primarily written in Python and transpile it to Go to improve the overall performance and stability of YouTube&rsquo;s front-end services."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://bbengfort.github.io/posts/"},{"@type":"ListItem","position":3,"name":"A Benchmark of Grumpy Transpiling","item":"https://bbengfort.github.io/2017/03/grumpy-transpiling-fib-benchmark/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"A Benchmark of Grumpy Transpiling","name":"A Benchmark of Grumpy Transpiling","description":"On Tuesday evening I attended a Django District meetup on Grumpy, a transpiler from Python to Go. Because it was a Python meetup, the talk naturally focused on introducing Go to a Python audience, and because it was a Django meetup, we also focused on web services. The premise for Grumpy, as discussed in the announcing Google blog post, is also a web focused one — to take YouTube\u0026rsquo;s API that\u0026rsquo;s primarily written in Python and transpile it to Go to improve the overall performance and stability of YouTube\u0026rsquo;s front-end services.","keywords":[],"articleBody":"On Tuesday evening I attended a Django District meetup on Grumpy, a transpiler from Python to Go. Because it was a Python meetup, the talk naturally focused on introducing Go to a Python audience, and because it was a Django meetup, we also focused on web services. The premise for Grumpy, as discussed in the announcing Google blog post, is also a web focused one — to take YouTube’s API that’s primarily written in Python and transpile it to Go to improve the overall performance and stability of YouTube’s front-end services.\nWhile still in experimental mode, they show a benchmarking graph in the blog post that shows as the number of threads increases, the number of Grumpy transpiled operations per second also increases linearly, whereas the CPython ops/sec actually decreases to a floor. This is fascinating stuff and actually kind of makes sense; potentially the opportunities for concurrency in Go defeat the GIL in Python and can give Python code deployable scalability.\nStill, I wanted to know, if it’s faster, how much faster is it? (skip ahead to results)\nIn both the meetup talk and the blog post, the fibonacci benchmark is discussed. Unfortunately, neither had raw numbers and since I wanted to try it out on my own anyway, I thought I would. In this post I’ll review the steps I took to use Grumpy then the benchmarking numbers that I came up with.\nGetting Started Transpiling Because the package is in experimental mode, you must download or clone the Grumpy repository and do all your work in the project root directory. This is because relative paths and a couple of special environment variables are required in order to make things work. First clone the repository and change your working directory to the project root:\n$ git clone https://github.com/google/grumpy.git $ cd grumpy At this point you need to build the grumpy tools and set a couple of environment variables to make things work.\n$ make $ export GOPATH=$PWD/build $ export PYTHONPATH=$PWD/build/lib/python2.7/site-packages Note that the make process actually took quite a bit of time on my MacBook, so be patient! I also added the export statements to an .env file locally so that I could easily set the environment for this directory in the future.\nThe hello world of Grumpy transpiling is quite simple. First create a python file, hello.py:\n#!/usr/bin/env python if __name__ == '__main__': print \"hello world!\" You then transpile it and build a binary executable as follows:\n$ build/bin/grumpc hello.py \u003e hello.go $ go build -o hello hello.go The first step uses the grumpc transpiler to create Go code from the Python code, and outputs it to the Go source code file, hello.go. The second step uses the go build tool (which requires the $GOPATH to be set correctly) to compile the hello.go program into a binary executable. You can now execute the file directly:\n$ ./hello hello world! Fibonacci In order to benchmark the code for time I want to compare three executables:\nA Python 2.7 implementation with recursion (fib.py) A pure Go implementation with similar characteristics (fib.go) The transpiled Python implementation (fibpy.go) Note: Obligatory Py2/3 comment: Grumpy is about making the YouTube API better, which is written in Python 2.7; so tough luck Python 3 folks, I guess.\nThe hypothesis is that the Python implementation will be the slowest, the transpiled one slightly faster and the Go implementation will blaze. For reference, here are my implementations:\n#!/usr/bin/env python import sys def fib(i): if i \u003c 2: return 1 return fib(i-1) + fib(i-2) if __name__ == '__main__': try: idx = sys.argv[1] print fib(int(idx)) except IndexError: print \"please specify a fibonacci index\" except ValueError: print \"please specify an integer\" The Python implementation is compact and understandable, coming in at 14 lines of code. The Go implementation is slightly longer at 24 lines of code:\npackage main import ( \"fmt\" \"os\" \"strconv\" ) func fib(i uint64) uint64 { if i \u003c 2 { return uint64(1) } return fib(i-1) + fib(i-2) } func main() { if len(os.Args) != 2 { fmt.Println(\"please specify a fibonacci index\") os.Exit(1) } idx, err := strconv.ParseUint(os.Args[1], 10, 64) if err != nil { fmt.Println(\"please specify an integer\") os.Exit(1) } fmt.Println(fib(idx)) } In order to transpile the code, build it as follows:\n$ $ build/bin/grumpc fib.py \u003e fibpy.go $ go build -o fibpy fibpy.go And of course build the go code as well:\n$ go build -o fib fib.go The transpiled code comes in at a whopping 255 lines of code, so I’ll not show it here, but if you’re interested you can find it at this gist.\nOne interesting thing about Grumpy is it uses a π symbol for variable names that reference Python, for example, the grumpy package is imported into the namespace πg.\nSo in terms of code, we have the following characteristics:\nBut frankly that’s fair — Grumpy has to do a lot of work to bring over the sys package from Python, handle exceptions in the try/except, handle the builtins and deal with objects and function definitions. I actually think Grumpy is doing pretty well in the translation in terms of LOC.\nBenchmarking Typically I would use Go benchmarking to measure the performance of an operation — it is both formal and does a good job of doing micro-measurements in terms of number of operations per second. However, I can’t use this technique for the Python code and I want to make sure that we can capture the benchmarks for the complete executable including imports like the sys module. Therefore the benchmarks are timings of complete runs of the executables, the equivalent of:\n$ time ./fib 40 $ time ./fibpy 40 $ time python fib.py 40 Because the recursive fibonacci implementation does not use memoization or dynamic programming, the computational time increases exponentially as the index gets higher. Therefore the benchmarks are several runs at moderately high indices to push the performance. In order to operationalize this, I wrote a small Python script to execute the benchmarks. You can find the benchmark script on Gist (it is a bit too large to include in this post).\nNOTE: I hope that I have provided everything needed to repeat these benchmarks. If you find a hole in the methodology or different results, I’d certainly be interested.\nAfter the timing benchmarks I also wanted to run resource usage benchmarks. Since the fibonacci implementation currently doesn’t use multiple threads, I can’t compare run times across increasing number of processes (TODO!). Instead, using the memory profiler library I simply measured memory usage. In the results section, I run each process using mprof independently in order to precisely track what is running where. However, using the new multiprocess feature of the memory profiler library you could create a bash script as follows:\n#!/bin/bash ./fib $1 \u0026 ./fibpy $1 \u0026 python fib.py $1 \u0026 wait And run the memory profiler on each of the processes:\n$ mprof run -M ./fibmem.sh 40 $ mprof plot This will background each of the processes so that they are plotted as child processes of the main bash script. Unfortunately they are plotted by index, so it’s hard to know which child is which, but I believe that child 0 is the go implementation, child 1 is the transpiled implementation, and child 2 is the Python implementation. Ok, so after that long description of methods, let’s get into findings.\nResults For 20 runs of each executable for fibonacci arguments 25, 30, 35, and 40, I recorded the following average times for the various executables shown in the next figure. Note that the amount of time for the next argument increases exponentially, opening up the performance gap between executables.\nUnsurprisingly, the pure Go implementation was blazing fast, about 42 times faster than the Python implementation on average. The real surprise, however, is that the transpiled Go was actually 1.5 times slower than the Python implementation. I actually cannot explain why this might be — I’m hugely curious if anyone has an answer.\nIn order to give a clearer picture, here are the log scaled results with a fifth timing for the 45th fibonacci number computation:\nIn order to track memory usage, I used mprof to track memory for each executable ran independently in it’s own process, here are the results:\nAnd so that you can actually see the pure Go implementation as well as memory usage initialization and start up, here is a zoomed in version to the first few milliseconds of execution:\nThe memory usage profiling reveals yet another surprise, not only does the transpiled version take longer to execute, but it also uses more memory. Meanwhile, the pure go implementation is so lightweight as to blow away with a stiff breeze.\nConclusions Transpiling is hard.\nGrumpy is still only experimental, and there does seem to be some real promise particularly with concurrency gains. However, I’m not sold on transpiling as an approach to squeezing more performance out of a system.\n","wordCount":"1489","inLanguage":"en","datePublished":"2017-03-23T08:47:04Z","dateModified":"2017-03-23T08:47:04Z","author":{"@type":"Person","name":"Benjamin Bengfort"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://bbengfort.github.io/2017/03/grumpy-transpiling-fib-benchmark/"},"publisher":{"@type":"Organization","name":"Libelli","logo":{"@type":"ImageObject","url":"https://bbengfort.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://bbengfort.github.io accesskey=h title="Libelli (Alt + H)"><img src=/icon.png alt=logo aria-label=logo height=35>Libelli</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://bbengfort.github.io/archive/ title=archive><span>archive</span></a></li><li><a href=https://bbengfort.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://bbengfort.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://bbengfort.github.io/about/ title=about><span>about</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>A Benchmark of Grumpy Transpiling</h1><div class=post-meta>March 23, 2017&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Benjamin Bengfort</div></header><div class=post-content><p>On Tuesday evening I attended a <a href=https://www.meetup.com/django-district/events/238128100/>Django District meetup</a> on <a href=https://github.com/google/grumpy>Grumpy</a>, a <a href=https://www.stevefenton.co.uk/2012/11/compiling-vs-transpiling/>transpiler</a> from Python to Go. Because it was a Python meetup, the talk naturally focused on introducing Go to a Python audience, and because it was a Django meetup, we also focused on web services. The premise for Grumpy, as discussed in the announcing <a href=https://opensource.googleblog.com/2017/01/grumpy-go-running-python.html>Google blog post</a>, is also a web focused one — to take YouTube&rsquo;s API that&rsquo;s primarily written in Python and transpile it to Go to improve the overall performance and stability of YouTube&rsquo;s front-end services.</p><p>While still in experimental mode, they show <a href=https://lh6.googleusercontent.com/AJtJgMwyxN3KWnDrHW5JhersJGuf1SsR_lhhQoUY5gSMBjhV-BJo-vWh4JztqD7qq9pcr0JYT-niwehvDqvCmM8ZhCUAkgZFpviWnNKah5xGJCNGuMAGBdhYYhT3ZbN-HDfw_Fs3>a benchmarking graph</a> in the blog post that shows as the number of threads increases, the number of Grumpy transpiled operations per second also increases linearly, whereas the CPython ops/sec actually decreases to a floor. This is fascinating stuff and actually kind of makes sense; potentially the opportunities for concurrency in Go defeat the GIL in Python and can give Python code deployable scalability.</p><p>Still, I wanted to know, if it&rsquo;s faster, <em>how much faster is it?</em> <a href=#2017-03-23-benchmarks>(skip ahead to results)</a></p><p>In both the meetup talk and the blog post, the <a href=https://crystal-lang.org/2016/07/15/fibonacci-benchmark.html>fibonacci</a> benchmark is discussed. Unfortunately, neither had raw numbers and since I wanted to try it out on my own anyway, I thought I would. In this post I&rsquo;ll review the steps I took to use Grumpy then the benchmarking numbers that I came up with.</p><h2 id=getting-started-transpiling>Getting Started Transpiling<a hidden class=anchor aria-hidden=true href=#getting-started-transpiling>#</a></h2><p>Because the package is in experimental mode, you must download or clone the Grumpy repository and do all your work in the project root directory. This is because relative paths and a couple of special environment variables are required in order to make things work. First clone the repository and change your working directory to the project root:</p><pre tabindex=0><code>$ git clone https://github.com/google/grumpy.git
$ cd grumpy
</code></pre><p>At this point you need to build the grumpy tools and set a couple of environment variables to make things work.</p><pre tabindex=0><code>$ make
$ export GOPATH=$PWD/build
$ export PYTHONPATH=$PWD/build/lib/python2.7/site-packages
</code></pre><p>Note that the <code>make</code> process actually took quite a bit of time on my MacBook, so be patient! I also added the export statements to an .env file locally so that I could easily set the environment for this directory in the future.</p><p>The hello world of Grumpy transpiling is quite simple. First create a python file, <code>hello.py</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e>#!/usr/bin/env python</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;__main__&#39;</span>:
</span></span><span style=display:flex><span>    print <span style=color:#e6db74>&#34;hello world!&#34;</span>
</span></span></code></pre></div><p>You then transpile it and build a binary executable as follows:</p><pre tabindex=0><code>$ build/bin/grumpc hello.py &gt; hello.go
$ go build -o hello hello.go
</code></pre><p>The first step uses the <code>grumpc</code> transpiler to create Go code from the Python code, and outputs it to the Go source code file, <code>hello.go</code>. The second step uses the go build tool (which requires the <code>$GOPATH</code> to be set correctly) to compile the hello.go program into a binary executable. You can now execute the file directly:</p><pre tabindex=0><code>$ ./hello
hello world!
</code></pre><h2 id=fibonacci>Fibonacci<a hidden class=anchor aria-hidden=true href=#fibonacci>#</a></h2><p>In order to benchmark the code for time I want to compare three executables:</p><ol><li>A Python 2.7 implementation with recursion (fib.py)</li><li>A pure Go implementation with similar characteristics (fib.go)</li><li>The transpiled Python implementation (fibpy.go)</li></ol><p><strong>Note</strong>: Obligatory Py2/3 comment: Grumpy is about making the YouTube API better, which is written in Python 2.7; so tough luck Python 3 folks, I guess.</p><p>The hypothesis is that the Python implementation will be the slowest, the transpiled one slightly faster and the Go implementation will blaze. For reference, here are my implementations:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e>#!/usr/bin/env python</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> sys
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>fib</span>(i):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>2</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> fib(i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) <span style=color:#f92672>+</span> fib(i<span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;__main__&#39;</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>        idx <span style=color:#f92672>=</span> sys<span style=color:#f92672>.</span>argv[<span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>        print fib(int(idx))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>except</span> <span style=color:#a6e22e>IndexError</span>:
</span></span><span style=display:flex><span>        print <span style=color:#e6db74>&#34;please specify a fibonacci index&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>except</span> <span style=color:#a6e22e>ValueError</span>:
</span></span><span style=display:flex><span>        print <span style=color:#e6db74>&#34;please specify an integer&#34;</span>
</span></span></code></pre></div><p>The Python implementation is compact and understandable, coming in at 14 lines of code. The Go implementation is slightly longer at 24 lines of code:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;os&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;strconv&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>fib</span>(<span style=color:#a6e22e>i</span> <span style=color:#66d9ef>uint64</span>) <span style=color:#66d9ef>uint64</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>i</span> &lt; <span style=color:#ae81ff>2</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> uint64(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>fib</span>(<span style=color:#a6e22e>i</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) <span style=color:#f92672>+</span> <span style=color:#a6e22e>fib</span>(<span style=color:#a6e22e>i</span><span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Args</span>) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>2</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;please specify a fibonacci index&#34;</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Exit</span>(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>idx</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>strconv</span>.<span style=color:#a6e22e>ParseUint</span>(<span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Args</span>[<span style=color:#ae81ff>1</span>], <span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>64</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;please specify an integer&#34;</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Exit</span>(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>fib</span>(<span style=color:#a6e22e>idx</span>))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>In order to transpile the code, build it as follows:</p><pre tabindex=0><code>$ $ build/bin/grumpc fib.py &gt; fibpy.go
$ go build -o fibpy fibpy.go
</code></pre><p>And of course build the go code as well:</p><pre tabindex=0><code>$ go build -o fib fib.go
</code></pre><p>The transpiled code comes in at a whopping 255 lines of code, so I&rsquo;ll not show it here, but if you&rsquo;re interested you can find it <a href=https://gist.github.com/bbengfort/e924822d9e4ec8e8c9097f7bc21c6dc3>at this gist</a>.</p><blockquote><p>One interesting thing about Grumpy is it uses a <code>π</code> symbol for variable names that reference Python, for example, the grumpy package is imported into the namespace <code>πg</code>.</p></blockquote><p>So in terms of code, we have the following characteristics:</p><p><a href=/images/2017-03-23-grumpy-lines-of-code.png><img loading=lazy src=/images/2017-03-23-grumpy-lines-of-code.png alt="Lines of Code Comparison"></a></p><p>But frankly that&rsquo;s fair — Grumpy has to do a lot of work to bring over the sys package from Python, handle exceptions in the try/except, handle the builtins and deal with objects and function definitions. I actually think Grumpy is doing pretty well in the translation in terms of LOC.</p><h2 id=benchmarking>Benchmarking<a hidden class=anchor aria-hidden=true href=#benchmarking>#</a></h2><p>Typically I would use <a href=https://dave.cheney.net/2013/06/30/how-to-write-benchmarks-in-go>Go benchmarking</a> to measure the performance of an operation — it is both formal and does a good job of doing micro-measurements in terms of number of operations per second. However, I can&rsquo;t use this technique for the Python code and I want to make sure that we can capture the benchmarks for the complete executable including imports like the <code>sys</code> module. Therefore the benchmarks are timings of complete runs of the executables, the equivalent of:</p><pre tabindex=0><code>$ time ./fib 40
$ time ./fibpy 40
$ time python fib.py 40
</code></pre><p>Because the recursive fibonacci implementation does not use memoization or dynamic programming, the computational time increases exponentially as the index gets higher. Therefore the benchmarks are several runs at moderately high indices to push the performance. In order to operationalize this, I wrote a small Python script to execute the benchmarks. You can find the <a href=https://gist.github.com/bbengfort/e048b647ae8c94dc1d6465342d7ba34d>benchmark script on Gist</a> (it is a bit too large to include in this post).</p><p><strong>NOTE</strong>: I hope that I have provided everything needed to repeat these benchmarks. If you find a hole in the methodology or different results, I&rsquo;d certainly be interested.</p><p>After the timing benchmarks I also wanted to run resource usage benchmarks. Since the fibonacci implementation currently doesn&rsquo;t use multiple threads, I can&rsquo;t compare run times across increasing number of processes (TODO!). Instead, using the <a href=https://pypi.python.org/pypi/memory_profiler>memory profiler</a> library I simply measured memory usage. In the results section, I run each process using <code>mprof</code> independently in order to precisely track what is running where. However, using the new multiprocess feature of the memory profiler library you could create a bash script as follows:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>#!/bin/bash
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>./fib $1 &amp;
</span></span><span style=display:flex><span>./fibpy $1 &amp;
</span></span><span style=display:flex><span>python fib.py $1 &amp;
</span></span><span style=display:flex><span>wait
</span></span></code></pre></div><p>And run the memory profiler on each of the processes:</p><pre tabindex=0><code>$ mprof run -M ./fibmem.sh 40
$ mprof plot
</code></pre><p>This will background each of the processes so that they are plotted as child processes of the main bash script. Unfortunately they are plotted by index, so it&rsquo;s hard to know which child is which, but I believe that child 0 is the go implementation, child 1 is the transpiled implementation, and child 2 is the Python implementation. Ok, so after that long description of methods, let&rsquo;s get into findings.</p><p></p><h2 id=results>Results<a hidden class=anchor aria-hidden=true href=#results>#</a></h2><p>For 20 runs of each executable for fibonacci arguments 25, 30, 35, and 40, I recorded the following average times for the various executables shown in the next figure. Note that the amount of time for the next argument increases exponentially, opening up the performance gap between executables.</p><p><a href=/images/2017-03-23-fib-executable-runtimes.png><img loading=lazy src=/images/2017-03-23-fib-executable-runtimes.png alt="Executable Run Times"></a></p><p>Unsurprisingly, the pure Go implementation was blazing fast, about 42 times faster than the Python implementation on average. The real surprise, however, is that the transpiled Go was actually <em>1.5 times slower</em> than the Python implementation. I actually cannot explain why this might be — I&rsquo;m hugely curious if anyone has an answer.</p><p>In order to give a clearer picture, here are the log scaled results with a fifth timing for the 45th fibonacci number computation:</p><p><a href=/images/2017-03-23-fib-executable-runtimes-log-scale.png><img loading=lazy src=/images/2017-03-23-fib-executable-runtimes-log-scale.png alt="Log Scaled Executable Run Times"></a></p><p>In order to track memory usage, I used <code>mprof</code> to track memory for each executable ran independently in it&rsquo;s own process, here are the results:</p><p><a href=/images/2017-03-23-fib-memory-usage.png><img loading=lazy src=/images/2017-03-23-fib-memory-usage.png alt="Memory Usage"></a></p><p>And so that you can actually see the pure Go implementation as well as memory usage initialization and start up, here is a zoomed in version to the first few milliseconds of execution:</p><p><a href=/images/2017-03-23-fib-memory-usage-zoomed.png><img loading=lazy src=/images/2017-03-23-fib-memory-usage-zoomed.png alt="Memory Usage Zoomed"></a></p><p>The memory usage profiling reveals yet another surprise, not only does the transpiled version take longer to execute, but it also uses more memory. Meanwhile, the pure go implementation is so lightweight as to blow away with a stiff breeze.</p><h2 id=conclusions>Conclusions<a hidden class=anchor aria-hidden=true href=#conclusions>#</a></h2><p>Transpiling is hard.</p><p>Grumpy is still only experimental, and there does seem to be some real promise particularly with concurrency gains. However, I&rsquo;m not sold on transpiling as an approach to squeezing more performance out of a system.</p></div><footer class=post-footer></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://bbengfort.github.io>Libelli</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById("menu");menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>