<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Synchronizing Structs for Safe Concurrency in Go | Libelli</title><meta name=keywords content><meta name=description content="Go is built for concurrency by providing language features that allow developers to embed complex concurrency patterns into their applications. These language features can be intuitive and a lot of safety is built in (for example a race detector) but developers still need to be aware of the interactions between various threads in their programs.
In any shared memory system the biggest concern is synchronization: ensuring that separate go routines operate in the correct order and that no race conditions occur."><meta name=author content="Benjamin Bengfort"><link rel=canonical href=https://bbengfort.github.io/2017/02/synchronizing-structs/><link crossorigin=anonymous href=/assets/css/stylesheet.min.d0c0348c2d0cff14148d0e347258519d8df2ce53ce5ac32c7bd9a549182cb8ae.css integrity="sha256-0MA0jC0M/xQUjQ40clhRnY3yzlPOWsMse9mlSRgsuK4=" rel="preload stylesheet" as=style><link rel=preload href=/icon.png as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><link rel=icon href=https://bbengfort.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://bbengfort.github.io/icon.png><link rel=icon type=image/png sizes=32x32 href=https://bbengfort.github.io/icon.png><link rel=apple-touch-icon href=https://bbengfort.github.io/apple-touch-icon-precomposed.png><link rel=mask-icon href=https://bbengfort.github.io/icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.79.0"><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-8096804-11','auto');ga('send','pageview');}</script><meta property="og:title" content="Synchronizing Structs for Safe Concurrency in Go"><meta property="og:description" content="Go is built for concurrency by providing language features that allow developers to embed complex concurrency patterns into their applications. These language features can be intuitive and a lot of safety is built in (for example a race detector) but developers still need to be aware of the interactions between various threads in their programs.
In any shared memory system the biggest concern is synchronization: ensuring that separate go routines operate in the correct order and that no race conditions occur."><meta property="og:type" content="article"><meta property="og:url" content="https://bbengfort.github.io/2017/02/synchronizing-structs/"><meta property="og:image" content="https://bbengfort.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-02-21T10:48:24+00:00"><meta property="article:modified_time" content="2017-02-21T10:48:24+00:00"><meta property="og:site_name" content="Libelli"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://bbengfort.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Synchronizing Structs for Safe Concurrency in Go"><meta name=twitter:description content="Go is built for concurrency by providing language features that allow developers to embed complex concurrency patterns into their applications. These language features can be intuitive and a lot of safety is built in (for example a race detector) but developers still need to be aware of the interactions between various threads in their programs.
In any shared memory system the biggest concern is synchronization: ensuring that separate go routines operate in the correct order and that no race conditions occur."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://bbengfort.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Synchronizing Structs for Safe Concurrency in Go","item":"https://bbengfort.github.io/2017/02/synchronizing-structs/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Synchronizing Structs for Safe Concurrency in Go","name":"Synchronizing Structs for Safe Concurrency in Go","description":"Go is built for concurrency by providing language features that allow developers to embed complex concurrency patterns into their applications. These language features can be intuitive and a lot of safety is built in (for example a race detector) but developers still need to be aware of the interactions between various threads in their programs.\nIn any shared memory system the biggest concern is synchronization: ensuring that separate go routines operate in the correct order and that no race conditions occur.","keywords":[],"articleBody":"Go is built for concurrency by providing language features that allow developers to embed complex concurrency patterns into their applications. These language features can be intuitive and a lot of safety is built in (for example a race detector) but developers still need to be aware of the interactions between various threads in their programs.\nIn any shared memory system the biggest concern is synchronization: ensuring that separate go routines operate in the correct order and that no race conditions occur. The primary way to handle synchronization is the use of channels. Channels synchronize execution by forcing sends on the channel to block until the value on the channel is received. In this way, channels act as a barrier since the go routine can not progress while being blocked by the channel and enforce a specific ordering to execution, the ordering of routines arriving at the barrier.\nChannels are made to implement CSP, but there are other concurrency primitives like mutexes (locks designed to enforce mutual exclusion concurrency control). In fact, channels use locks behind the scenes to serialize access, and you’re likely going to have to use other concurrency primitives anyway. I’ve encountered this problem, and have started using mutexes in a very specific way, which this post is about.\nConsider an operation that is not commutative or not associative (operations that are can be implemented with CRDTs), for example concatenating data to a buffer. This operation must be synchronized because the original state must be preserved during the operation. A simple explanation of this is the += which (for the purpose of our discussion) fetches the original value of the variable, performs the operation and stores the result back to the value. If two processes attempt to += concurrently a race condition occurs because whichever process is first to complete will have its answer overridden. In the following example, the final result of the variable will be \"hello Bob\" or \"hello Alice\" depending on which process gets there last, an undesirable state (the second operation may have preferred the concatenation to be \"hello Bob and Alice\" or \"hello Alice and Bob\").\n\nThe solution is to lock the variable whenever the first process accesses it and then release it when it’s done, that way the process is guaranteed the state of the variable for the duration of the operation. Here’s how I implement this with a struct in Go:\ntype Buffer struct { sync.Mutex // wraps a synchronization flag  buf string // the string being concatenated to } By embedding the sync.Mutex into the struct, it can now be locked and unlocked. Even more powerfully, you can write methods that lock and defer unlock for very easy thread safe synchronization. Here is an example of safe and unsafe concatenation to the buffer:\nfunc (b *Buffer) Concat(s string) { b.buf += s } func (b *Buffer) SafeConcat(s string) { b.Lock() defer b.Unlock() b.Concat(s) } It is important to note that safety does not mean that you’re guaranteed some other arbitrary order of operations when using goroutines. Consider the following concurrent concatenate example that injects some sleep into the concat function (find the complete code on Gist):\nvar ( safe bool start time.Time group *sync.WaitGroup buffer *Buffer alphas []string ) func write(idx int, safe bool) { defer group.Done() if idx = len(alphas) { return } if safe { buffer.SafeConcat(alphas[idx]) } else { buffer.Concat(alphas[idx]) } } group = new(sync.WaitGroup) alphas = []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\",} buffer = new(Buffer) start = time.Now() for i := 0; i alphas); i++ { group.Add(1) go write(i, safe) } group.Wait() fmt.Printf(\"\\nresult: %s in %s (safe=%t)\\n\", buffer, time.Since(start), safe) Here, we’re using a sync.WaitGroup to determine when all the go routines are complete (e.g. join on the collection of routines) and have them write the letter of their index to the buffer. The output is as follows:\nresult: fiedhcjgab in 1.004835942s (safe=false) result: kbahgifjced in 11.020241668s (safe=true) Note that in the unsafe case, one of the letters is missing because of incorrect synchronization and that the safe case took 11 seconds to complete. This is because each goroutine had to wait (for a second) until it could access the buffer since it was locked. However, it’s also important to note that neither method (safe or unsafe) produced \"abcdefghijk\", since the locking order is about which routine got to the lock first, not about what order the goroutine was started.\nAnd honestly, that’s the prime lesson from this post (most of which are my notes from implementing this in a production system).\nBut of course, I have another question - given the sequential case, how much overhead do the locks add? So benchmarking …\nBenchmarkUnsafeConcat-8 1000000\t47287 ns/op BenchmarkSafeConcat-8 1000000\t53170 ns/op Clearly having locks adds some overhead and if you’re not going to do any concurrent programming, then the 6 microseconds it takes to lock and unlock is probably not worth it. On the other hand, if there is the chance that you’ll have any concurrency at all - using the sync.Mutex embedding is a very clear and understandable way to go about things.\n","wordCount":"852","inLanguage":"en","datePublished":"2017-02-21T10:48:24Z","dateModified":"2017-02-21T10:48:24Z","author":{"@type":"Person","name":"Benjamin Bengfort"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://bbengfort.github.io/2017/02/synchronizing-structs/"},"publisher":{"@type":"Organization","name":"Libelli","logo":{"@type":"ImageObject","url":"https://bbengfort.github.io/favicon.ico"}}}</script></head><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme: #1d1e20;--entry: #2e2e33;--primary: rgba(255, 255, 255, 0.84);--secondary: rgba(255, 255, 255, 0.56);--tertiary: rgba(255, 255, 255, 0.16);--content: rgba(255, 255, 255, 0.74);--hljs-bg: #2e2e33;--code-bg: #37383e;--border: #333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://bbengfort.github.io accesskey=h title="Libelli (Alt + H)"><img src=/icon.png alt=logo aria-label=logo height=35>Libelli</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://bbengfort.github.io/archive/ title=archive><span>archive</span></a></li><li><a href=https://bbengfort.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://bbengfort.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://bbengfort.github.io/about/ title=about><span>about</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Synchronizing Structs for Safe Concurrency in Go</h1><div class=post-meta>February 21, 2017&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Benjamin Bengfort</div></header><div class=post-content><p>Go is <a href=https://divan.github.io/posts/go_concurrency_visualize/>built for concurrency</a> by providing language features that allow developers to embed complex concurrency patterns into their applications. These language features can be intuitive and a lot of safety is built in (for example a <a href=https://blog.golang.org/race-detector>race detector</a>) but developers still need to be aware of the interactions between various threads in their programs.</p><p>In any shared memory system the biggest concern is <a href=https://en.wikipedia.org/wiki/Synchronization_(computer_science)>synchronization</a>: ensuring that separate go routines operate in the correct order and that no race conditions occur. The primary way to handle synchronization is the use of <a href=https://gobyexample.com/channels>channels</a>. Channels synchronize execution by forcing sends on the channel to block until the value on the channel is received. In this way, channels act as a <a href=https://en.wikipedia.org/wiki/Barrier_(computer_science)>barrier</a> since the go routine can not progress while being blocked by the channel and enforce a specific ordering to execution, the ordering of routines arriving at the barrier.</p><p>Channels are made to implement <a href=https://en.wikipedia.org/wiki/Communicating_sequential_processes>CSP</a>, but there are other concurrency primitives like <a href=https://en.wikipedia.org/wiki/Lock_(computer_science)>mutexes</a> (locks designed to enforce mutual exclusion concurrency control). In fact, channels use locks behind the scenes to serialize access, and <a href=http://www.jtolds.com/writing/2016/03/go-channels-are-bad-and-you-should-feel-bad/>you&rsquo;re likely going to have to use other concurrency primitives anyway</a>. I&rsquo;ve encountered this problem, and have started using mutexes in a very specific way, which this post is about.</p><p>Consider an operation that is not <a href=https://en.wikipedia.org/wiki/Commutative_property>commutative</a> or not <a href=https://en.wikipedia.org/wiki/Associative_property>associative</a> (operations that are can be implemented with <a href=https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type>CRDTs</a>), for example concatenating data to a buffer. This operation must be synchronized because the original state must be preserved during the operation. A simple explanation of this is the <code>+=</code> which (for the purpose of our discussion) fetches the original value of the variable, performs the operation and stores the result back to the value. If two processes attempt to <code>+=</code> concurrently a <a href=https://en.wikipedia.org/wiki/Race_condition>race condition</a> occurs because whichever process is first to complete will have its answer overridden. In the following example, the final result of the variable will be <code>"hello Bob"</code> or <code>"hello Alice"</code> depending on which process gets there last, an undesirable state (the second operation may have preferred the concatenation to be <code>"hello Bob and Alice"</code> or <code>"hello Alice and Bob"</code>).</p><p><a href=/images/2017-02-21-race-condition.png><img loading=lazy src=/images/2017-02-21-race-condition.png alt="Race Condition"></a></p><p>The solution is to lock the variable whenever the first process accesses it and then release it when it&rsquo;s done, that way the process is guaranteed the state of the variable for the duration of the operation. Here&rsquo;s how I implement this with a <code>struct</code> in Go:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Buffer</span> <span style=color:#66d9ef>struct</span> {
    <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>Mutex</span>        <span style=color:#75715e>// wraps a synchronization flag
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>buf</span>        <span style=color:#66d9ef>string</span> <span style=color:#75715e>// the string being concatenated to
</span><span style=color:#75715e></span>}
</code></pre></div><p>By embedding the <code>sync.Mutex</code> into the struct, it can now be locked and unlocked. Even more powerfully, you can write methods that lock and <code>defer</code> unlock for very easy thread safe synchronization. Here is an example of safe and unsafe concatenation to the buffer:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Buffer</span>) <span style=color:#a6e22e>Concat</span>(<span style=color:#a6e22e>s</span> <span style=color:#66d9ef>string</span>) {
	<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>buf</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>s</span>
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Buffer</span>) <span style=color:#a6e22e>SafeConcat</span>(<span style=color:#a6e22e>s</span> <span style=color:#66d9ef>string</span>) {
	<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Lock</span>()
	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Unlock</span>()
	<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Concat</span>(<span style=color:#a6e22e>s</span>)
}
</code></pre></div><p>It is important to note that safety does not mean that you&rsquo;re guaranteed some other arbitrary order of operations when using goroutines. Consider the following concurrent concatenate example that injects some sleep into the concat function (find the <a href=https://gist.github.com/bbengfort/dcd6a1a36a9670562fe8a04cf836ce49>complete code on Gist</a>):</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>var</span> (
	<span style=color:#a6e22e>safe</span>   <span style=color:#66d9ef>bool</span>
	<span style=color:#a6e22e>start</span>  <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Time</span>
	<span style=color:#a6e22e>group</span>  <span style=color:#f92672>*</span><span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>WaitGroup</span>
	<span style=color:#a6e22e>buffer</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Buffer</span>
	<span style=color:#a6e22e>alphas</span> []<span style=color:#66d9ef>string</span>
)

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>write</span>(<span style=color:#a6e22e>idx</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>safe</span> <span style=color:#66d9ef>bool</span>) {
	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>group</span>.<span style=color:#a6e22e>Done</span>()

	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>idx</span> <span style=color:#f92672>&gt;=</span> len(<span style=color:#a6e22e>alphas</span>) {
		<span style=color:#66d9ef>return</span>
	}

	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>safe</span> {
		<span style=color:#a6e22e>buffer</span>.<span style=color:#a6e22e>SafeConcat</span>(<span style=color:#a6e22e>alphas</span>[<span style=color:#a6e22e>idx</span>])
	} <span style=color:#66d9ef>else</span> {
		<span style=color:#a6e22e>buffer</span>.<span style=color:#a6e22e>Concat</span>(<span style=color:#a6e22e>alphas</span>[<span style=color:#a6e22e>idx</span>])
	}

}

<span style=color:#a6e22e>group</span> = new(<span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>WaitGroup</span>)
<span style=color:#a6e22e>alphas</span> = []<span style=color:#66d9ef>string</span>{<span style=color:#e6db74>&#34;a&#34;</span>, <span style=color:#e6db74>&#34;b&#34;</span>, <span style=color:#e6db74>&#34;c&#34;</span>, <span style=color:#e6db74>&#34;d&#34;</span>, <span style=color:#e6db74>&#34;e&#34;</span>, <span style=color:#e6db74>&#34;f&#34;</span>, <span style=color:#e6db74>&#34;g&#34;</span>, <span style=color:#e6db74>&#34;h&#34;</span>, <span style=color:#e6db74>&#34;i&#34;</span>,}
<span style=color:#a6e22e>buffer</span> = new(<span style=color:#a6e22e>Buffer</span>)
<span style=color:#a6e22e>start</span> = <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>()

<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; len(<span style=color:#a6e22e>alphas</span>); <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
    <span style=color:#a6e22e>group</span>.<span style=color:#a6e22e>Add</span>(<span style=color:#ae81ff>1</span>)
    <span style=color:#66d9ef>go</span> <span style=color:#a6e22e>write</span>(<span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>safe</span>)
}

<span style=color:#a6e22e>group</span>.<span style=color:#a6e22e>Wait</span>()
<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;\nresult: %s in %s (safe=%t)\n&#34;</span>, <span style=color:#a6e22e>buffer</span>, <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Since</span>(<span style=color:#a6e22e>start</span>), <span style=color:#a6e22e>safe</span>)
</code></pre></div><p>Here, we&rsquo;re using a <code>sync.WaitGroup</code> to determine when all the go routines are complete (e.g. join on the collection of routines) and have them write the letter of their index to the buffer. The output is as follows:</p><pre><code>result: fiedhcjgab in 1.004835942s (safe=false)
result: kbahgifjced in 11.020241668s (safe=true)
</code></pre><p>Note that in the unsafe case, one of the letters is missing because of incorrect synchronization and that the safe case took 11 seconds to complete. This is because each goroutine had to wait (for a second) until it could access the buffer since it was locked. However, it&rsquo;s also important to note that neither method (safe or unsafe) produced <code>"abcdefghijk"</code>, since the locking order is about which routine got to the lock first, not about what order the goroutine was started.</p><p>And honestly, that&rsquo;s the prime lesson from this post (most of which are my notes from implementing this in a production system).</p><p>But of course, I have another question - given the sequential case, how much overhead do the locks add? So benchmarking &mldr;</p><pre><code>BenchmarkUnsafeConcat-8   	 1000000	     47287 ns/op
BenchmarkSafeConcat-8     	 1000000	     53170 ns/op
</code></pre><p>Clearly having locks adds some overhead and if you&rsquo;re not going to do any concurrent programming, then the 6 microseconds it takes to lock and unlock is probably not worth it. On the other hand, if there is the chance that you&rsquo;ll have any concurrency at all - using the <code>sync.Mutex</code> embedding is a very clear and understandable way to go about things.</p></div><footer class=post-footer></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://bbengfort.github.io>Libelli</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById('menu')
menu.scrollLeft=localStorage.getItem("menu-scroll-position");menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft);}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);if(!window.matchMedia('(prefers-reduced-motion: reduce)').matches){document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});}else{document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();}
if(id==="top"){history.replaceState(null,null," ");}else{history.pushState(null,null,`#${id}`);}});});</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script></body></html>