<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Synchronizing Structs for Safe Concurrency in Go | Libelli</title>
<meta name=keywords content><meta name=description content="Go is built for concurrency by providing language features that allow developers to embed complex concurrency patterns into their applications. These language features can be intuitive and a lot of safety is built in (for example a race detector) but developers still need to be aware of the interactions between various threads in their programs.
In any shared memory system the biggest concern is synchronization: ensuring that separate go routines operate in the correct order and that no race conditions occur. The primary way to handle synchronization is the use of channels. Channels synchronize execution by forcing sends on the channel to block until the value on the channel is received. In this way, channels act as a barrier since the go routine can not progress while being blocked by the channel and enforce a specific ordering to execution, the ordering of routines arriving at the barrier."><meta name=author content="Benjamin Bengfort"><link rel=canonical href=https://bbengfort.github.io/2017/02/synchronizing-structs/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://bbengfort.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://bbengfort.github.io/icon.png><link rel=icon type=image/png sizes=32x32 href=https://bbengfort.github.io/icon.png><link rel=apple-touch-icon href=https://bbengfort.github.io/apple-touch-icon-precomposed.png><link rel=mask-icon href=https://bbengfort.github.io/icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://bbengfort.github.io/2017/02/synchronizing-structs/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-D3BE7EHHVP"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-D3BE7EHHVP")}</script><meta property="og:title" content="Synchronizing Structs for Safe Concurrency in Go"><meta property="og:description" content="Go is built for concurrency by providing language features that allow developers to embed complex concurrency patterns into their applications. These language features can be intuitive and a lot of safety is built in (for example a race detector) but developers still need to be aware of the interactions between various threads in their programs.
In any shared memory system the biggest concern is synchronization: ensuring that separate go routines operate in the correct order and that no race conditions occur. The primary way to handle synchronization is the use of channels. Channels synchronize execution by forcing sends on the channel to block until the value on the channel is received. In this way, channels act as a barrier since the go routine can not progress while being blocked by the channel and enforce a specific ordering to execution, the ordering of routines arriving at the barrier."><meta property="og:type" content="article"><meta property="og:url" content="https://bbengfort.github.io/2017/02/synchronizing-structs/"><meta property="og:image" content="https://bbengfort.github.io/bear.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-02-21T10:48:24+00:00"><meta property="article:modified_time" content="2017-02-21T10:48:24+00:00"><meta property="og:site_name" content="Libelli"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://bbengfort.github.io/bear.png"><meta name=twitter:title content="Synchronizing Structs for Safe Concurrency in Go"><meta name=twitter:description content="Go is built for concurrency by providing language features that allow developers to embed complex concurrency patterns into their applications. These language features can be intuitive and a lot of safety is built in (for example a race detector) but developers still need to be aware of the interactions between various threads in their programs.
In any shared memory system the biggest concern is synchronization: ensuring that separate go routines operate in the correct order and that no race conditions occur. The primary way to handle synchronization is the use of channels. Channels synchronize execution by forcing sends on the channel to block until the value on the channel is received. In this way, channels act as a barrier since the go routine can not progress while being blocked by the channel and enforce a specific ordering to execution, the ordering of routines arriving at the barrier."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://bbengfort.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Synchronizing Structs for Safe Concurrency in Go","item":"https://bbengfort.github.io/2017/02/synchronizing-structs/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Synchronizing Structs for Safe Concurrency in Go","name":"Synchronizing Structs for Safe Concurrency in Go","description":"Go is built for concurrency by providing language features that allow developers to embed complex concurrency patterns into their applications. These language features can be intuitive and a lot of safety is built in (for example a race detector) but developers still need to be aware of the interactions between various threads in their programs.\nIn any shared memory system the biggest concern is synchronization: ensuring that separate go routines operate in the correct order and that no race conditions occur. The primary way to handle synchronization is the use of channels. Channels synchronize execution by forcing sends on the channel to block until the value on the channel is received. In this way, channels act as a barrier since the go routine can not progress while being blocked by the channel and enforce a specific ordering to execution, the ordering of routines arriving at the barrier.\n","keywords":[],"articleBody":"Go is built for concurrency by providing language features that allow developers to embed complex concurrency patterns into their applications. These language features can be intuitive and a lot of safety is built in (for example a race detector) but developers still need to be aware of the interactions between various threads in their programs.\nIn any shared memory system the biggest concern is synchronization: ensuring that separate go routines operate in the correct order and that no race conditions occur. The primary way to handle synchronization is the use of channels. Channels synchronize execution by forcing sends on the channel to block until the value on the channel is received. In this way, channels act as a barrier since the go routine can not progress while being blocked by the channel and enforce a specific ordering to execution, the ordering of routines arriving at the barrier.\nChannels are made to implement CSP, but there are other concurrency primitives like mutexes (locks designed to enforce mutual exclusion concurrency control). In fact, channels use locks behind the scenes to serialize access, and you’re likely going to have to use other concurrency primitives anyway. I’ve encountered this problem, and have started using mutexes in a very specific way, which this post is about.\nConsider an operation that is not commutative or not associative (operations that are can be implemented with CRDTs), for example concatenating data to a buffer. This operation must be synchronized because the original state must be preserved during the operation. A simple explanation of this is the += which (for the purpose of our discussion) fetches the original value of the variable, performs the operation and stores the result back to the value. If two processes attempt to += concurrently a race condition occurs because whichever process is first to complete will have its answer overridden. In the following example, the final result of the variable will be \"hello Bob\" or \"hello Alice\" depending on which process gets there last, an undesirable state (the second operation may have preferred the concatenation to be \"hello Bob and Alice\" or \"hello Alice and Bob\").\nThe solution is to lock the variable whenever the first process accesses it and then release it when it’s done, that way the process is guaranteed the state of the variable for the duration of the operation. Here’s how I implement this with a struct in Go:\ntype Buffer struct { sync.Mutex // wraps a synchronization flag buf string // the string being concatenated to } By embedding the sync.Mutex into the struct, it can now be locked and unlocked. Even more powerfully, you can write methods that lock and defer unlock for very easy thread safe synchronization. Here is an example of safe and unsafe concatenation to the buffer:\nfunc (b *Buffer) Concat(s string) { b.buf += s } func (b *Buffer) SafeConcat(s string) { b.Lock() defer b.Unlock() b.Concat(s) } It is important to note that safety does not mean that you’re guaranteed some other arbitrary order of operations when using goroutines. Consider the following concurrent concatenate example that injects some sleep into the concat function (find the complete code on Gist):\nvar ( safe bool start time.Time group *sync.WaitGroup buffer *Buffer alphas []string ) func write(idx int, safe bool) { defer group.Done() if idx \u003e= len(alphas) { return } if safe { buffer.SafeConcat(alphas[idx]) } else { buffer.Concat(alphas[idx]) } } group = new(sync.WaitGroup) alphas = []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\",} buffer = new(Buffer) start = time.Now() for i := 0; i \u003c len(alphas); i++ { group.Add(1) go write(i, safe) } group.Wait() fmt.Printf(\"\\nresult: %s in %s (safe=%t)\\n\", buffer, time.Since(start), safe) Here, we’re using a sync.WaitGroup to determine when all the go routines are complete (e.g. join on the collection of routines) and have them write the letter of their index to the buffer. The output is as follows:\nresult: fiedhcjgab in 1.004835942s (safe=false) result: kbahgifjced in 11.020241668s (safe=true) Note that in the unsafe case, one of the letters is missing because of incorrect synchronization and that the safe case took 11 seconds to complete. This is because each goroutine had to wait (for a second) until it could access the buffer since it was locked. However, it’s also important to note that neither method (safe or unsafe) produced \"abcdefghijk\", since the locking order is about which routine got to the lock first, not about what order the goroutine was started.\nAnd honestly, that’s the prime lesson from this post (most of which are my notes from implementing this in a production system).\nBut of course, I have another question - given the sequential case, how much overhead do the locks add? So benchmarking …\nBenchmarkUnsafeConcat-8 1000000\t47287 ns/op BenchmarkSafeConcat-8 1000000\t53170 ns/op Clearly having locks adds some overhead and if you’re not going to do any concurrent programming, then the 6 microseconds it takes to lock and unlock is probably not worth it. On the other hand, if there is the chance that you’ll have any concurrency at all - using the sync.Mutex embedding is a very clear and understandable way to go about things.\n","wordCount":"852","inLanguage":"en","image":"https://bbengfort.github.io/bear.png","datePublished":"2017-02-21T10:48:24Z","dateModified":"2017-02-21T10:48:24Z","author":{"@type":"Person","name":"Benjamin Bengfort"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://bbengfort.github.io/2017/02/synchronizing-structs/"},"publisher":{"@type":"Organization","name":"Libelli","logo":{"@type":"ImageObject","url":"https://bbengfort.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bbengfort.github.io/ accesskey=h title="Libelli (Alt + H)"><img src=https://bbengfort.github.io/icon.png alt aria-label=logo height=35>Libelli</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://bbengfort.github.io/archive/ title=archive><span>archive</span></a></li><li><a href=https://bbengfort.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://bbengfort.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://bbengfort.github.io/about/ title=about><span>about</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://bbengfort.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://bbengfort.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Synchronizing Structs for Safe Concurrency in Go</h1><div class=post-meta><span title='2017-02-21 10:48:24 +0000 UTC'>February 21, 2017</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;852 words&nbsp;·&nbsp;Benjamin Bengfort&nbsp;|&nbsp;<a href=https://github.com/bbengfort/bbengfort.github.io/tree/main/content/posts/2017-02-21-synchronizing-structs.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>Go is <a href=https://divan.github.io/posts/go_concurrency_visualize/>built for concurrency</a> by providing language features that allow developers to embed complex concurrency patterns into their applications. These language features can be intuitive and a lot of safety is built in (for example a <a href=https://blog.golang.org/race-detector>race detector</a>) but developers still need to be aware of the interactions between various threads in their programs.</p><p>In any shared memory system the biggest concern is <a href=https://en.wikipedia.org/wiki/Synchronization_(computer_science)>synchronization</a>: ensuring that separate go routines operate in the correct order and that no race conditions occur. The primary way to handle synchronization is the use of <a href=https://gobyexample.com/channels>channels</a>. Channels synchronize execution by forcing sends on the channel to block until the value on the channel is received. In this way, channels act as a <a href=https://en.wikipedia.org/wiki/Barrier_(computer_science)>barrier</a> since the go routine can not progress while being blocked by the channel and enforce a specific ordering to execution, the ordering of routines arriving at the barrier.</p><p>Channels are made to implement <a href=https://en.wikipedia.org/wiki/Communicating_sequential_processes>CSP</a>, but there are other concurrency primitives like <a href=https://en.wikipedia.org/wiki/Lock_(computer_science)>mutexes</a> (locks designed to enforce mutual exclusion concurrency control). In fact, channels use locks behind the scenes to serialize access, and <a href=http://www.jtolds.com/writing/2016/03/go-channels-are-bad-and-you-should-feel-bad/>you&rsquo;re likely going to have to use other concurrency primitives anyway</a>. I&rsquo;ve encountered this problem, and have started using mutexes in a very specific way, which this post is about.</p><p>Consider an operation that is not <a href=https://en.wikipedia.org/wiki/Commutative_property>commutative</a> or not <a href=https://en.wikipedia.org/wiki/Associative_property>associative</a> (operations that are can be implemented with <a href=https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type>CRDTs</a>), for example concatenating data to a buffer. This operation must be synchronized because the original state must be preserved during the operation. A simple explanation of this is the <code>+=</code> which (for the purpose of our discussion) fetches the original value of the variable, performs the operation and stores the result back to the value. If two processes attempt to <code>+=</code> concurrently a <a href=https://en.wikipedia.org/wiki/Race_condition>race condition</a> occurs because whichever process is first to complete will have its answer overridden. In the following example, the final result of the variable will be <code>"hello Bob"</code> or <code>"hello Alice"</code> depending on which process gets there last, an undesirable state (the second operation may have preferred the concatenation to be <code>"hello Bob and Alice"</code> or <code>"hello Alice and Bob"</code>).</p><p><a href=/images/2017-02-21-race-condition.png><img loading=lazy src=/images/2017-02-21-race-condition.png alt="Race Condition"></a></p><p>The solution is to lock the variable whenever the first process accesses it and then release it when it&rsquo;s done, that way the process is guaranteed the state of the variable for the duration of the operation. Here&rsquo;s how I implement this with a <code>struct</code> in Go:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Buffer</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>sync</span><span class=p>.</span><span class=nx>Mutex</span>        <span class=c1>// wraps a synchronization flag
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>buf</span>        <span class=kt>string</span> <span class=c1>// the string being concatenated to
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>By embedding the <code>sync.Mutex</code> into the struct, it can now be locked and unlocked. Even more powerfully, you can write methods that lock and <code>defer</code> unlock for very easy thread safe synchronization. Here is an example of safe and unsafe concatenation to the buffer:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>b</span> <span class=o>*</span><span class=nx>Buffer</span><span class=p>)</span> <span class=nf>Concat</span><span class=p>(</span><span class=nx>s</span> <span class=kt>string</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>b</span><span class=p>.</span><span class=nx>buf</span> <span class=o>+=</span> <span class=nx>s</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>b</span> <span class=o>*</span><span class=nx>Buffer</span><span class=p>)</span> <span class=nf>SafeConcat</span><span class=p>(</span><span class=nx>s</span> <span class=kt>string</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>b</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=nx>b</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>b</span><span class=p>.</span><span class=nf>Concat</span><span class=p>(</span><span class=nx>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>It is important to note that safety does not mean that you&rsquo;re guaranteed some other arbitrary order of operations when using goroutines. Consider the following concurrent concatenate example that injects some sleep into the concat function (find the <a href=https://gist.github.com/bbengfort/dcd6a1a36a9670562fe8a04cf836ce49>complete code on Gist</a>):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=nx>safe</span>   <span class=kt>bool</span>
</span></span><span class=line><span class=cl>	<span class=nx>start</span>  <span class=nx>time</span><span class=p>.</span><span class=nx>Time</span>
</span></span><span class=line><span class=cl>	<span class=nx>group</span>  <span class=o>*</span><span class=nx>sync</span><span class=p>.</span><span class=nx>WaitGroup</span>
</span></span><span class=line><span class=cl>	<span class=nx>buffer</span> <span class=o>*</span><span class=nx>Buffer</span>
</span></span><span class=line><span class=cl>	<span class=nx>alphas</span> <span class=p>[]</span><span class=kt>string</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>write</span><span class=p>(</span><span class=nx>idx</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>safe</span> <span class=kt>bool</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=nx>group</span><span class=p>.</span><span class=nf>Done</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>idx</span> <span class=o>&gt;=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>alphas</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>safe</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>buffer</span><span class=p>.</span><span class=nf>SafeConcat</span><span class=p>(</span><span class=nx>alphas</span><span class=p>[</span><span class=nx>idx</span><span class=p>])</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>buffer</span><span class=p>.</span><span class=nf>Concat</span><span class=p>(</span><span class=nx>alphas</span><span class=p>[</span><span class=nx>idx</span><span class=p>])</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>group</span> <span class=p>=</span> <span class=nb>new</span><span class=p>(</span><span class=nx>sync</span><span class=p>.</span><span class=nx>WaitGroup</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>alphas</span> <span class=p>=</span> <span class=p>[]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;a&#34;</span><span class=p>,</span> <span class=s>&#34;b&#34;</span><span class=p>,</span> <span class=s>&#34;c&#34;</span><span class=p>,</span> <span class=s>&#34;d&#34;</span><span class=p>,</span> <span class=s>&#34;e&#34;</span><span class=p>,</span> <span class=s>&#34;f&#34;</span><span class=p>,</span> <span class=s>&#34;g&#34;</span><span class=p>,</span> <span class=s>&#34;h&#34;</span><span class=p>,</span> <span class=s>&#34;i&#34;</span><span class=p>,}</span>
</span></span><span class=line><span class=cl><span class=nx>buffer</span> <span class=p>=</span> <span class=nb>new</span><span class=p>(</span><span class=nx>Buffer</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>start</span> <span class=p>=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>alphas</span><span class=p>);</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>group</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=nf>write</span><span class=p>(</span><span class=nx>i</span><span class=p>,</span> <span class=nx>safe</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>group</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;\nresult: %s in %s (safe=%t)\n&#34;</span><span class=p>,</span> <span class=nx>buffer</span><span class=p>,</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Since</span><span class=p>(</span><span class=nx>start</span><span class=p>),</span> <span class=nx>safe</span><span class=p>)</span>
</span></span></code></pre></div><p>Here, we&rsquo;re using a <code>sync.WaitGroup</code> to determine when all the go routines are complete (e.g. join on the collection of routines) and have them write the letter of their index to the buffer. The output is as follows:</p><pre tabindex=0><code>result: fiedhcjgab in 1.004835942s (safe=false)
result: kbahgifjced in 11.020241668s (safe=true)
</code></pre><p>Note that in the unsafe case, one of the letters is missing because of incorrect synchronization and that the safe case took 11 seconds to complete. This is because each goroutine had to wait (for a second) until it could access the buffer since it was locked. However, it&rsquo;s also important to note that neither method (safe or unsafe) produced <code>"abcdefghijk"</code>, since the locking order is about which routine got to the lock first, not about what order the goroutine was started.</p><p>And honestly, that&rsquo;s the prime lesson from this post (most of which are my notes from implementing this in a production system).</p><p>But of course, I have another question - given the sequential case, how much overhead do the locks add? So benchmarking &mldr;</p><pre tabindex=0><code>BenchmarkUnsafeConcat-8   	 1000000	     47287 ns/op
BenchmarkSafeConcat-8     	 1000000	     53170 ns/op
</code></pre><p>Clearly having locks adds some overhead and if you&rsquo;re not going to do any concurrent programming, then the 6 microseconds it takes to lock and unlock is probably not worth it. On the other hand, if there is the chance that you&rsquo;ll have any concurrency at all - using the <code>sync.Mutex</code> embedding is a very clear and understandable way to go about things.</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://bbengfort.github.io/2017/03/secure-grpc/><span class=title>« Prev</span><br><span>Secure gRPC with TLS/SSL</span>
</a><a class=next href=https://bbengfort.github.io/2017/02/chunking/><span class=title>Next »</span><br><span>Fixed vs. Variable Length Chunking</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://bbengfort.github.io/>Libelli</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>