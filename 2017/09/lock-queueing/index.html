<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Lock Queuing in Go | Libelli</title>
<meta name=keywords content><meta name=description content="In Go, you can use sync.Mutex and sync.RWMutex objects to create thread-safe data structures in memory as discussed in [“Synchronizing Structs for Safe Concurrency in Go”]({% post_url 2017-02-21-synchronizing-structs %}). When using the sync.RWMutex in Go, there are two kinds of locks: read locks and write locks. The basic difference is that many read locks can be acquired at the same time, but only one write lock can be acquired at at time."><meta name=author content="Benjamin Bengfort"><link rel=canonical href=https://bbengfort.github.io/2017/09/lock-queueing/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://bbengfort.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://bbengfort.github.io/icon.png><link rel=icon type=image/png sizes=32x32 href=https://bbengfort.github.io/icon.png><link rel=apple-touch-icon href=https://bbengfort.github.io/apple-touch-icon-precomposed.png><link rel=mask-icon href=https://bbengfort.github.io/icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://bbengfort.github.io/2017/09/lock-queueing/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-D3BE7EHHVP"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-D3BE7EHHVP")}</script><meta property="og:title" content="Lock Queuing in Go"><meta property="og:description" content="In Go, you can use sync.Mutex and sync.RWMutex objects to create thread-safe data structures in memory as discussed in [“Synchronizing Structs for Safe Concurrency in Go”]({% post_url 2017-02-21-synchronizing-structs %}). When using the sync.RWMutex in Go, there are two kinds of locks: read locks and write locks. The basic difference is that many read locks can be acquired at the same time, but only one write lock can be acquired at at time."><meta property="og:type" content="article"><meta property="og:url" content="https://bbengfort.github.io/2017/09/lock-queueing/"><meta property="og:image" content="https://bbengfort.github.io/bear.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-09-08T11:31:19+00:00"><meta property="article:modified_time" content="2017-09-08T11:31:19+00:00"><meta property="og:site_name" content="Libelli"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://bbengfort.github.io/bear.png"><meta name=twitter:title content="Lock Queuing in Go"><meta name=twitter:description content="In Go, you can use sync.Mutex and sync.RWMutex objects to create thread-safe data structures in memory as discussed in [“Synchronizing Structs for Safe Concurrency in Go”]({% post_url 2017-02-21-synchronizing-structs %}). When using the sync.RWMutex in Go, there are two kinds of locks: read locks and write locks. The basic difference is that many read locks can be acquired at the same time, but only one write lock can be acquired at at time."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://bbengfort.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Lock Queuing in Go","item":"https://bbengfort.github.io/2017/09/lock-queueing/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Lock Queuing in Go","name":"Lock Queuing in Go","description":"In Go, you can use sync.Mutex and sync.RWMutex objects to create thread-safe data structures in memory as discussed in [“Synchronizing Structs for Safe Concurrency in Go”]({% post_url 2017-02-21-synchronizing-structs %}). When using the sync.RWMutex in Go, there are two kinds of locks: read locks and write locks. The basic difference is that many read locks can be acquired at the same time, but only one write lock can be acquired at at time.\n","keywords":[],"articleBody":"In Go, you can use sync.Mutex and sync.RWMutex objects to create thread-safe data structures in memory as discussed in [“Synchronizing Structs for Safe Concurrency in Go”]({% post_url 2017-02-21-synchronizing-structs %}). When using the sync.RWMutex in Go, there are two kinds of locks: read locks and write locks. The basic difference is that many read locks can be acquired at the same time, but only one write lock can be acquired at at time.\nThis means that if a thread attempts to acquire a read lock on an object that is already read locked, then it will not block and it will acquire its own read lock. If a thread attempts to acquire a read or a write lock on a write locked object, then it will block until it is unlocked (as will a write lock acquisition on a read locked object).\nGranting a lock can be prioritized depending on different policies for accesses. Priorities balance the trade-off between concurrency and starvation as follows:\nRead-Preferring RW allows new read locks to be acquired as long as the lock is read-locked, forcing the write-lock acquirer to wait until there are no more read-locks. In high contention environments, this might lead to write-starvation.\nWrite-Preferring RW prevents a read-lock acquisition if a writer is queued and waiting for the lock. This reduces concurrency, because new read locks have to wait for the write lock, but prevents starvation.\nSo which of these does Go implement? According to the documentation:\nIf a goroutine holds a RWMutex for reading and another goroutine might call Lock, no goroutine should expect to be able to acquire a read lock until the initial read lock is released. In particular, this prohibits recursive read locking. This is to ensure that the lock eventually becomes available; a blocked Lock call excludes new readers from acquiring the lock. — godoc\nMy initial read of this made me think that Go implements write-preferring mutexes. However, this was not the behavior that I observed.\nConsider the following locker:\nvar delay time.Duration var started time.Time // Locker holds values that are threadsafe type Locker struct { sync.RWMutex value uint64 // the current value of the locker access time.Time // time of the last access } // Write to the value of the locker in a threadsafe fashion. func (l *Locker) Write(value uint64) { l.Lock() defer l.Unlock() // Arbitrary amount of work time.Sleep(delay) l.value = value l.access = time.Now() l.log(\"written\") } // Read the value of the locker in a threadsafe fasion. func (l *Locker) Read() uint64 { l.RLock() defer l.RUnlock() // Arbirtray amount of work time.Sleep(delay / 2) l.access = time.Now() l.log(\"read\") return l.value } // Log the access (not thread-safe) func (l *Locker) log(method string) { after := l.access.Sub(started) log.Printf( \"%d %s after %s\\n\", l.value, method, after, ) } This locker holds a value and logs all accesses to it after the start time. If we run a few threads to read and write to it we can see concurrent reads in action:\nfunc main() { delay = 1 * time.Second started = time.Now() group := new(errgroup.Group) locker := new(Locker) // Straight forward, write three reads and a write group.Go(func() error { locker.Write(42); return nil }) group.Go(func() error { locker.Read(); return nil }) group.Go(func() error { locker.Read(); return nil }) group.Go(func() error { locker.Read(); return nil }) group.Go(func() error { locker.Write(101); return nil }) group.Wait() } The output is as follows\n$ go run locker.go 2017/09/08 12:26:32 101 written after 1.005058824s 2017/09/08 12:26:33 101 read after 1.50770225s 2017/09/08 12:26:33 101 read after 1.507769109s 2017/09/08 12:26:33 101 read after 1.50773587s 2017/09/08 12:26:34 42 written after 2.511968581s Note that the last go routine actually managed to acquire the lock first, after which the three readers managed to acquire the lock, then finally the last writer. Now if we interleave the read and write access, adding a sleep between the kick-off of each go routine to ensure that the preceding thread has time to acquire the lock:\nfunc main() { delay = 1 * time.Second started = time.Now() group := new(errgroup.Group) locker := new(Locker) // Straight forward, write three reads and a write group.Go(func() error { locker.Write(42); return nil }) time.Sleep(10 * time.Millisecond) group.Go(func() error { locker.Read(); return nil }) time.Sleep(10 * time.Millisecond) group.Go(func() error { locker.Write(101); return nil }) time.Sleep(10 * time.Millisecond) group.Go(func() error { locker.Read(); return nil }) time.Sleep(10 * time.Millisecond) group.Go(func() error { locker.Write(3); return nil }) time.Sleep(10 * time.Millisecond) group.Go(func() error { locker.Read(); return nil }) time.Sleep(10 * time.Millisecond) group.Go(func() error { locker.Write(18); return nil }) time.Sleep(10 * time.Millisecond) group.Go(func() error { locker.Read(); return nil }) group.Wait() } We get the following output:\ngo run locker.go 2017/09/08 12:29:28 42 written after 1.000178155s 2017/09/08 12:29:28 42 read after 1.500703007s 2017/09/08 12:29:28 42 read after 1.500691088s 2017/09/08 12:29:28 42 read after 1.500756144s 2017/09/08 12:29:28 42 read after 1.500648159s 2017/09/08 12:29:28 42 read after 1.500762323s 2017/09/08 12:29:28 42 read after 1.500679533s 2017/09/08 12:29:28 42 read after 1.500795204s 2017/09/08 12:29:29 101 written after 2.500971593s 2017/09/08 12:29:30 3 written after 3.505325487s 2017/09/08 12:29:31 18 written after 4.50594131s This suggests that the reads continue to acquire locks as long as the Locker is read locked, forcing the writes to happen at the end.\nI found one Stack Overflow post: “Read preferring RW mutex lock in Golang” that seems to suggest that sync.RWMutex can implement both read and write preferred locking, but doesn’t really give an explanation about how external callers can implement it.\nFinally consider the following:\nfunc main() { delay = 1 * time.Second started = time.Now() group := new(errgroup.Group) locker := new(Locker) // Straight forward, write three reads and a write group.Go(func() error { locker.Write(42); return nil }) group.Go(func() error { locker.Write(101); return nil }) group.Go(func() error { locker.Write(3); return nil }) group.Go(func() error { locker.Write(18); return nil }) for i := 0; i \u003c 22; i++ { group.Go(func() error { locker.Read() return nil }) time.Sleep(delay / 4) } group.Wait() } Given the loop issuing 22 read locks that sleep only a quarter of the time of the write lock, we might expect that this code will issue 22 read locks then all the write locks will occur at the end (and if we put this in a forever loop, then the writes would never occur). However, the output of this is as follows:\n2017/09/08 12:43:40 18 written after 1.004461829s 2017/09/08 12:43:40 18 read after 1.508343716s 2017/09/08 12:43:40 18 read after 1.50842899s 2017/09/08 12:43:40 18 read after 1.508362345s 2017/09/08 12:43:40 18 read after 1.508339659s 2017/09/08 12:43:40 18 read after 1.50852229s 2017/09/08 12:43:41 42 written after 2.513789339s 2017/09/08 12:43:42 42 read after 3.0163191s 2017/09/08 12:43:42 42 read after 3.016330534s 2017/09/08 12:43:42 42 read after 3.016355628s 2017/09/08 12:43:42 42 read after 3.016371381s 2017/09/08 12:43:42 42 read after 3.016316992s 2017/09/08 12:43:43 3 written after 4.017954589s 2017/09/08 12:43:43 3 read after 4.518495233s 2017/09/08 12:43:43 3 read after 4.518523255s 2017/09/08 12:43:43 3 read after 4.518537387s 2017/09/08 12:43:43 3 read after 4.518540397s 2017/09/08 12:43:43 3 read after 4.518543262s 2017/09/08 12:43:43 3 read after 4.51863128s 2017/09/08 12:43:44 101 written after 5.521872765s 2017/09/08 12:43:45 101 read after 6.023207828s 2017/09/08 12:43:45 101 read after 6.023225272s 2017/09/08 12:43:45 101 read after 6.023249529s 2017/09/08 12:43:45 101 read after 6.023190828s 2017/09/08 12:43:45 101 read after 6.023243032s 2017/09/08 12:43:45 101 read after 6.023190457s 2017/09/08 12:43:45 101 read after 6.04455716s 2017/09/08 12:43:45 101 read after 6.29457923s What Go implements is actually something else: read locks can only be acquired so long as the original read lock is maintained (the word “initial” being critical in the documentation). As soon as the first read lock is released, then the queued write-lock gets priority. The first read lock lasts approximately 500ms; this means that there is enough time for between 4-5 other locks to acquire a read lock, as soon as the first read lock completes, the write is given priority.\n","wordCount":"1296","inLanguage":"en","image":"https://bbengfort.github.io/bear.png","datePublished":"2017-09-08T11:31:19Z","dateModified":"2017-09-08T11:31:19Z","author":{"@type":"Person","name":"Benjamin Bengfort"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://bbengfort.github.io/2017/09/lock-queueing/"},"publisher":{"@type":"Organization","name":"Libelli","logo":{"@type":"ImageObject","url":"https://bbengfort.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bbengfort.github.io/ accesskey=h title="Libelli (Alt + H)"><img src=https://bbengfort.github.io/icon.png alt aria-label=logo height=35>Libelli</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://bbengfort.github.io/archive/ title=archive><span>archive</span></a></li><li><a href=https://bbengfort.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://bbengfort.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://bbengfort.github.io/about/ title=about><span>about</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://bbengfort.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://bbengfort.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Lock Queuing in Go</h1><div class=post-meta><span title='2017-09-08 11:31:19 +0000 UTC'>September 8, 2017</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1296 words&nbsp;·&nbsp;Benjamin Bengfort&nbsp;|&nbsp;<a href=https://github.com/bbengfort/bbengfort.github.io/tree/main/content/posts/2017-09-08-lock-queueing.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>In Go, you can use <code>sync.Mutex</code> and <code>sync.RWMutex</code> objects to create thread-safe data structures in memory as discussed in [“Synchronizing Structs for Safe Concurrency in Go”]({% post_url 2017-02-21-synchronizing-structs %}). When using the <code>sync.RWMutex</code> in Go, there are two kinds of locks: read locks and write locks. The basic difference is that many read locks can be acquired at the same time, but only one write lock can be acquired at at time.</p><p>This means that if a thread attempts to acquire a read lock on an object that is already read locked, then it will not block and it will acquire its own read lock. If a thread attempts to acquire a read or a write lock on a write locked object, then it will block until it is unlocked (as will a write lock acquisition on a read locked object).</p><p>Granting a lock can be prioritized depending on different <a href=https://en.wikipedia.org/wiki/Readers%E2%80%93writer_lock>policies for accesses</a>. Priorities balance the trade-off between concurrency and starvation as follows:</p><ol><li><p><em>Read-Preferring RW</em> allows new read locks to be acquired as long as the lock is read-locked, forcing the write-lock acquirer to wait until there are no more read-locks. In high contention environments, this might lead to write-starvation.</p></li><li><p><em>Write-Preferring RW</em> prevents a read-lock acquisition if a writer is queued and waiting for the lock. This reduces concurrency, because new read locks have to wait for the write lock, but prevents starvation.</p></li></ol><p>So which of these does Go implement? According to the documentation:</p><blockquote><p>If a goroutine holds a RWMutex for reading and another goroutine might call Lock, no goroutine should expect to be able to acquire a read lock until the initial read lock is released. In particular, this prohibits recursive read locking. This is to ensure that the lock eventually becomes available; a blocked Lock call excludes new readers from acquiring the lock. <a href=https://golang.org/pkg/sync/#RWMutex>— godoc</a></p></blockquote><p>My initial read of this made me think that Go implements write-preferring mutexes. However, this was not the behavior that I observed.</p><p>Consider the following locker:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>delay</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Duration</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>started</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Time</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Locker holds values that are threadsafe
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>Locker</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>sync</span><span class=p>.</span><span class=nx>RWMutex</span>
</span></span><span class=line><span class=cl>	<span class=nx>value</span>  <span class=kt>uint64</span>    <span class=c1>// the current value of the locker
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>access</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Time</span> <span class=c1>// time of the last access
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Write to the value of the locker in a threadsafe fashion.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>l</span> <span class=o>*</span><span class=nx>Locker</span><span class=p>)</span> <span class=nf>Write</span><span class=p>(</span><span class=nx>value</span> <span class=kt>uint64</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>l</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=nx>l</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Arbitrary amount of work
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>delay</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>l</span><span class=p>.</span><span class=nx>value</span> <span class=p>=</span> <span class=nx>value</span>
</span></span><span class=line><span class=cl>	<span class=nx>l</span><span class=p>.</span><span class=nx>access</span> <span class=p>=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>l</span><span class=p>.</span><span class=nf>log</span><span class=p>(</span><span class=s>&#34;written&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Read the value of the locker in a threadsafe fasion.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>l</span> <span class=o>*</span><span class=nx>Locker</span><span class=p>)</span> <span class=nf>Read</span><span class=p>()</span> <span class=kt>uint64</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>l</span><span class=p>.</span><span class=nf>RLock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=nx>l</span><span class=p>.</span><span class=nf>RUnlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Arbirtray amount of work
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>delay</span> <span class=o>/</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>l</span><span class=p>.</span><span class=nx>access</span> <span class=p>=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>l</span><span class=p>.</span><span class=nf>log</span><span class=p>(</span><span class=s>&#34;read&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>l</span><span class=p>.</span><span class=nx>value</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Log the access (not thread-safe)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>l</span> <span class=o>*</span><span class=nx>Locker</span><span class=p>)</span> <span class=nf>log</span><span class=p>(</span><span class=nx>method</span> <span class=kt>string</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>after</span> <span class=o>:=</span> <span class=nx>l</span><span class=p>.</span><span class=nx>access</span><span class=p>.</span><span class=nf>Sub</span><span class=p>(</span><span class=nx>started</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>log</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span>
</span></span><span class=line><span class=cl>		<span class=s>&#34;%d %s after %s\n&#34;</span><span class=p>,</span> <span class=nx>l</span><span class=p>.</span><span class=nx>value</span><span class=p>,</span> <span class=nx>method</span><span class=p>,</span> <span class=nx>after</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This locker holds a value and logs all accesses to it after the start time. If we run a few threads to read and write to it we can see concurrent reads in action:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>delay</span> <span class=p>=</span> <span class=mi>1</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span>
</span></span><span class=line><span class=cl>	<span class=nx>started</span> <span class=p>=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>group</span> <span class=o>:=</span> <span class=nb>new</span><span class=p>(</span><span class=nx>errgroup</span><span class=p>.</span><span class=nx>Group</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>locker</span> <span class=o>:=</span> <span class=nb>new</span><span class=p>(</span><span class=nx>Locker</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Straight forward, write three reads and a write
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>group</span><span class=p>.</span><span class=nf>Go</span><span class=p>(</span><span class=kd>func</span><span class=p>()</span> <span class=kt>error</span> <span class=p>{</span> <span class=nx>locker</span><span class=p>.</span><span class=nf>Write</span><span class=p>(</span><span class=mi>42</span><span class=p>);</span> <span class=k>return</span> <span class=kc>nil</span> <span class=p>})</span>
</span></span><span class=line><span class=cl>	<span class=nx>group</span><span class=p>.</span><span class=nf>Go</span><span class=p>(</span><span class=kd>func</span><span class=p>()</span> <span class=kt>error</span> <span class=p>{</span> <span class=nx>locker</span><span class=p>.</span><span class=nf>Read</span><span class=p>();</span> <span class=k>return</span> <span class=kc>nil</span> <span class=p>})</span>
</span></span><span class=line><span class=cl>	<span class=nx>group</span><span class=p>.</span><span class=nf>Go</span><span class=p>(</span><span class=kd>func</span><span class=p>()</span> <span class=kt>error</span> <span class=p>{</span> <span class=nx>locker</span><span class=p>.</span><span class=nf>Read</span><span class=p>();</span> <span class=k>return</span> <span class=kc>nil</span> <span class=p>})</span>
</span></span><span class=line><span class=cl>	<span class=nx>group</span><span class=p>.</span><span class=nf>Go</span><span class=p>(</span><span class=kd>func</span><span class=p>()</span> <span class=kt>error</span> <span class=p>{</span> <span class=nx>locker</span><span class=p>.</span><span class=nf>Read</span><span class=p>();</span> <span class=k>return</span> <span class=kc>nil</span> <span class=p>})</span>
</span></span><span class=line><span class=cl>	<span class=nx>group</span><span class=p>.</span><span class=nf>Go</span><span class=p>(</span><span class=kd>func</span><span class=p>()</span> <span class=kt>error</span> <span class=p>{</span> <span class=nx>locker</span><span class=p>.</span><span class=nf>Write</span><span class=p>(</span><span class=mi>101</span><span class=p>);</span> <span class=k>return</span> <span class=kc>nil</span> <span class=p>})</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>group</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The output is as follows</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>$ go run locker.go
</span></span><span class=line><span class=cl>2017/09/08 12:26:32 101 written after 1.005058824s
</span></span><span class=line><span class=cl>2017/09/08 12:26:33 101 read after 1.50770225s
</span></span><span class=line><span class=cl>2017/09/08 12:26:33 101 read after 1.507769109s
</span></span><span class=line><span class=cl>2017/09/08 12:26:33 101 read after 1.50773587s
</span></span><span class=line><span class=cl>2017/09/08 12:26:34 42 written after 2.511968581s
</span></span></code></pre></div><p>Note that the last go routine actually managed to acquire the lock first, after which the three readers managed to acquire the lock, then finally the last writer. Now if we interleave the read and write access, adding a sleep between the kick-off of each go routine to ensure that the preceding thread has time to acquire the lock:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>delay</span> <span class=p>=</span> <span class=mi>1</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span>
</span></span><span class=line><span class=cl>	<span class=nx>started</span> <span class=p>=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>group</span> <span class=o>:=</span> <span class=nb>new</span><span class=p>(</span><span class=nx>errgroup</span><span class=p>.</span><span class=nx>Group</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>locker</span> <span class=o>:=</span> <span class=nb>new</span><span class=p>(</span><span class=nx>Locker</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Straight forward, write three reads and a write
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>group</span><span class=p>.</span><span class=nf>Go</span><span class=p>(</span><span class=kd>func</span><span class=p>()</span> <span class=kt>error</span> <span class=p>{</span> <span class=nx>locker</span><span class=p>.</span><span class=nf>Write</span><span class=p>(</span><span class=mi>42</span><span class=p>);</span> <span class=k>return</span> <span class=kc>nil</span> <span class=p>})</span>
</span></span><span class=line><span class=cl>	<span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>10</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Millisecond</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>group</span><span class=p>.</span><span class=nf>Go</span><span class=p>(</span><span class=kd>func</span><span class=p>()</span> <span class=kt>error</span> <span class=p>{</span> <span class=nx>locker</span><span class=p>.</span><span class=nf>Read</span><span class=p>();</span> <span class=k>return</span> <span class=kc>nil</span> <span class=p>})</span>
</span></span><span class=line><span class=cl>	<span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>10</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Millisecond</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>group</span><span class=p>.</span><span class=nf>Go</span><span class=p>(</span><span class=kd>func</span><span class=p>()</span> <span class=kt>error</span> <span class=p>{</span> <span class=nx>locker</span><span class=p>.</span><span class=nf>Write</span><span class=p>(</span><span class=mi>101</span><span class=p>);</span> <span class=k>return</span> <span class=kc>nil</span> <span class=p>})</span>
</span></span><span class=line><span class=cl>	<span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>10</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Millisecond</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>group</span><span class=p>.</span><span class=nf>Go</span><span class=p>(</span><span class=kd>func</span><span class=p>()</span> <span class=kt>error</span> <span class=p>{</span> <span class=nx>locker</span><span class=p>.</span><span class=nf>Read</span><span class=p>();</span> <span class=k>return</span> <span class=kc>nil</span> <span class=p>})</span>
</span></span><span class=line><span class=cl>	<span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>10</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Millisecond</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>group</span><span class=p>.</span><span class=nf>Go</span><span class=p>(</span><span class=kd>func</span><span class=p>()</span> <span class=kt>error</span> <span class=p>{</span> <span class=nx>locker</span><span class=p>.</span><span class=nf>Write</span><span class=p>(</span><span class=mi>3</span><span class=p>);</span> <span class=k>return</span> <span class=kc>nil</span> <span class=p>})</span>
</span></span><span class=line><span class=cl>	<span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>10</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Millisecond</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>group</span><span class=p>.</span><span class=nf>Go</span><span class=p>(</span><span class=kd>func</span><span class=p>()</span> <span class=kt>error</span> <span class=p>{</span> <span class=nx>locker</span><span class=p>.</span><span class=nf>Read</span><span class=p>();</span> <span class=k>return</span> <span class=kc>nil</span> <span class=p>})</span>
</span></span><span class=line><span class=cl>	<span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>10</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Millisecond</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>group</span><span class=p>.</span><span class=nf>Go</span><span class=p>(</span><span class=kd>func</span><span class=p>()</span> <span class=kt>error</span> <span class=p>{</span> <span class=nx>locker</span><span class=p>.</span><span class=nf>Write</span><span class=p>(</span><span class=mi>18</span><span class=p>);</span> <span class=k>return</span> <span class=kc>nil</span> <span class=p>})</span>
</span></span><span class=line><span class=cl>	<span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>10</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Millisecond</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>group</span><span class=p>.</span><span class=nf>Go</span><span class=p>(</span><span class=kd>func</span><span class=p>()</span> <span class=kt>error</span> <span class=p>{</span> <span class=nx>locker</span><span class=p>.</span><span class=nf>Read</span><span class=p>();</span> <span class=k>return</span> <span class=kc>nil</span> <span class=p>})</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>group</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>We get the following output:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>go run locker.go
</span></span><span class=line><span class=cl>2017/09/08 12:29:28 42 written after 1.000178155s
</span></span><span class=line><span class=cl>2017/09/08 12:29:28 42 read after 1.500703007s
</span></span><span class=line><span class=cl>2017/09/08 12:29:28 42 read after 1.500691088s
</span></span><span class=line><span class=cl>2017/09/08 12:29:28 42 read after 1.500756144s
</span></span><span class=line><span class=cl>2017/09/08 12:29:28 42 read after 1.500648159s
</span></span><span class=line><span class=cl>2017/09/08 12:29:28 42 read after 1.500762323s
</span></span><span class=line><span class=cl>2017/09/08 12:29:28 42 read after 1.500679533s
</span></span><span class=line><span class=cl>2017/09/08 12:29:28 42 read after 1.500795204s
</span></span><span class=line><span class=cl>2017/09/08 12:29:29 101 written after 2.500971593s
</span></span><span class=line><span class=cl>2017/09/08 12:29:30 3 written after 3.505325487s
</span></span><span class=line><span class=cl>2017/09/08 12:29:31 18 written after 4.50594131s
</span></span></code></pre></div><p>This suggests that the reads continue to acquire locks as long as the <code>Locker</code> is read locked, forcing the writes to happen at the end.</p><p>I found one Stack Overflow post: <a href=https://stackoverflow.com/questions/36548702/read-preferring-rw-mutex-lock-in-golang>“Read preferring RW mutex lock in Golang”</a> that seems to suggest that <code>sync.RWMutex</code> can implement both read and write preferred locking, but doesn&rsquo;t really give an explanation about how external callers can implement it.</p><p>Finally consider the following:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>delay</span> <span class=p>=</span> <span class=mi>1</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span>
</span></span><span class=line><span class=cl>	<span class=nx>started</span> <span class=p>=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>group</span> <span class=o>:=</span> <span class=nb>new</span><span class=p>(</span><span class=nx>errgroup</span><span class=p>.</span><span class=nx>Group</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>locker</span> <span class=o>:=</span> <span class=nb>new</span><span class=p>(</span><span class=nx>Locker</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Straight forward, write three reads and a write
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>group</span><span class=p>.</span><span class=nf>Go</span><span class=p>(</span><span class=kd>func</span><span class=p>()</span> <span class=kt>error</span> <span class=p>{</span> <span class=nx>locker</span><span class=p>.</span><span class=nf>Write</span><span class=p>(</span><span class=mi>42</span><span class=p>);</span> <span class=k>return</span> <span class=kc>nil</span> <span class=p>})</span>
</span></span><span class=line><span class=cl>	<span class=nx>group</span><span class=p>.</span><span class=nf>Go</span><span class=p>(</span><span class=kd>func</span><span class=p>()</span> <span class=kt>error</span> <span class=p>{</span> <span class=nx>locker</span><span class=p>.</span><span class=nf>Write</span><span class=p>(</span><span class=mi>101</span><span class=p>);</span> <span class=k>return</span> <span class=kc>nil</span> <span class=p>})</span>
</span></span><span class=line><span class=cl>	<span class=nx>group</span><span class=p>.</span><span class=nf>Go</span><span class=p>(</span><span class=kd>func</span><span class=p>()</span> <span class=kt>error</span> <span class=p>{</span> <span class=nx>locker</span><span class=p>.</span><span class=nf>Write</span><span class=p>(</span><span class=mi>3</span><span class=p>);</span> <span class=k>return</span> <span class=kc>nil</span> <span class=p>})</span>
</span></span><span class=line><span class=cl>	<span class=nx>group</span><span class=p>.</span><span class=nf>Go</span><span class=p>(</span><span class=kd>func</span><span class=p>()</span> <span class=kt>error</span> <span class=p>{</span> <span class=nx>locker</span><span class=p>.</span><span class=nf>Write</span><span class=p>(</span><span class=mi>18</span><span class=p>);</span> <span class=k>return</span> <span class=kc>nil</span> <span class=p>})</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>22</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>group</span><span class=p>.</span><span class=nf>Go</span><span class=p>(</span><span class=kd>func</span><span class=p>()</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>locker</span><span class=p>.</span><span class=nf>Read</span><span class=p>()</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>		<span class=p>})</span>
</span></span><span class=line><span class=cl>		<span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>delay</span> <span class=o>/</span> <span class=mi>4</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>group</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Given the loop issuing 22 read locks that sleep only a quarter of the time of the write lock, we might expect that this code will issue 22 read locks then all the write locks will occur at the end (and if we put this in a forever loop, then the writes would never occur). However, the output of this is as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>2017/09/08 12:43:40 18 written after 1.004461829s
</span></span><span class=line><span class=cl>2017/09/08 12:43:40 18 read after 1.508343716s
</span></span><span class=line><span class=cl>2017/09/08 12:43:40 18 read after 1.50842899s
</span></span><span class=line><span class=cl>2017/09/08 12:43:40 18 read after 1.508362345s
</span></span><span class=line><span class=cl>2017/09/08 12:43:40 18 read after 1.508339659s
</span></span><span class=line><span class=cl>2017/09/08 12:43:40 18 read after 1.50852229s
</span></span><span class=line><span class=cl>2017/09/08 12:43:41 42 written after 2.513789339s
</span></span><span class=line><span class=cl>2017/09/08 12:43:42 42 read after 3.0163191s
</span></span><span class=line><span class=cl>2017/09/08 12:43:42 42 read after 3.016330534s
</span></span><span class=line><span class=cl>2017/09/08 12:43:42 42 read after 3.016355628s
</span></span><span class=line><span class=cl>2017/09/08 12:43:42 42 read after 3.016371381s
</span></span><span class=line><span class=cl>2017/09/08 12:43:42 42 read after 3.016316992s
</span></span><span class=line><span class=cl>2017/09/08 12:43:43 3 written after 4.017954589s
</span></span><span class=line><span class=cl>2017/09/08 12:43:43 3 read after 4.518495233s
</span></span><span class=line><span class=cl>2017/09/08 12:43:43 3 read after 4.518523255s
</span></span><span class=line><span class=cl>2017/09/08 12:43:43 3 read after 4.518537387s
</span></span><span class=line><span class=cl>2017/09/08 12:43:43 3 read after 4.518540397s
</span></span><span class=line><span class=cl>2017/09/08 12:43:43 3 read after 4.518543262s
</span></span><span class=line><span class=cl>2017/09/08 12:43:43 3 read after 4.51863128s
</span></span><span class=line><span class=cl>2017/09/08 12:43:44 101 written after 5.521872765s
</span></span><span class=line><span class=cl>2017/09/08 12:43:45 101 read after 6.023207828s
</span></span><span class=line><span class=cl>2017/09/08 12:43:45 101 read after 6.023225272s
</span></span><span class=line><span class=cl>2017/09/08 12:43:45 101 read after 6.023249529s
</span></span><span class=line><span class=cl>2017/09/08 12:43:45 101 read after 6.023190828s
</span></span><span class=line><span class=cl>2017/09/08 12:43:45 101 read after 6.023243032s
</span></span><span class=line><span class=cl>2017/09/08 12:43:45 101 read after 6.023190457s
</span></span><span class=line><span class=cl>2017/09/08 12:43:45 101 read after 6.04455716s
</span></span><span class=line><span class=cl>2017/09/08 12:43:45 101 read after 6.29457923s
</span></span></code></pre></div><p>What Go implements is actually something else: read locks can only be acquired <em>so long as the original read lock is maintained</em> (the word “initial” being critical in the documentation). As soon as the first read lock is released, then the queued write-lock gets priority. The first read lock lasts approximately 500ms; this means that there is enough time for between 4-5 other locks to acquire a read lock, as soon as the first read lock completes, the write is given priority.</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://bbengfort.github.io/2017/09/lock-diagnostics/><span class=title>« Prev</span><br><span>Lock Diagnostics in Go</span>
</a><a class=next href=https://bbengfort.github.io/2017/09/message-throughput/><span class=title>Next »</span><br><span>Messaging Throughput gRPC vs. ZMQ</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://bbengfort.github.io/>Libelli</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>