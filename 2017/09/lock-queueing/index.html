<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Lock Queuing in Go | Libelli</title><meta name=keywords content><meta name=description content="In Go, you can use sync.Mutex and sync.RWMutex objects to create thread-safe data structures in memory as discussed in [“Synchronizing Structs for Safe Concurrency in Go”]({% post_url 2017-02-21-synchronizing-structs %}). When using the sync.RWMutex in Go, there are two kinds of locks: read locks and write locks. The basic difference is that many read locks can be acquired at the same time, but only one write lock can be acquired at at time."><meta name=author content="Benjamin Bengfort"><link rel=canonical href=https://bbengfort.github.io/2017/09/lock-queueing/><link crossorigin=anonymous href=/assets/css/stylesheet.min.d0c0348c2d0cff14148d0e347258519d8df2ce53ce5ac32c7bd9a549182cb8ae.css integrity="sha256-0MA0jC0M/xQUjQ40clhRnY3yzlPOWsMse9mlSRgsuK4=" rel="preload stylesheet" as=style><link rel=preload href=/icon.png as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><link rel=icon href=https://bbengfort.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://bbengfort.github.io/icon.png><link rel=icon type=image/png sizes=32x32 href=https://bbengfort.github.io/icon.png><link rel=apple-touch-icon href=https://bbengfort.github.io/apple-touch-icon-precomposed.png><link rel=mask-icon href=https://bbengfort.github.io/icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.79.0"><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-8096804-11','auto');ga('send','pageview');}</script><meta property="og:title" content="Lock Queuing in Go"><meta property="og:description" content="In Go, you can use sync.Mutex and sync.RWMutex objects to create thread-safe data structures in memory as discussed in [“Synchronizing Structs for Safe Concurrency in Go”]({% post_url 2017-02-21-synchronizing-structs %}). When using the sync.RWMutex in Go, there are two kinds of locks: read locks and write locks. The basic difference is that many read locks can be acquired at the same time, but only one write lock can be acquired at at time."><meta property="og:type" content="article"><meta property="og:url" content="https://bbengfort.github.io/2017/09/lock-queueing/"><meta property="og:image" content="https://bbengfort.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-09-08T11:31:19+00:00"><meta property="article:modified_time" content="2017-09-08T11:31:19+00:00"><meta property="og:site_name" content="Libelli"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://bbengfort.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Lock Queuing in Go"><meta name=twitter:description content="In Go, you can use sync.Mutex and sync.RWMutex objects to create thread-safe data structures in memory as discussed in [“Synchronizing Structs for Safe Concurrency in Go”]({% post_url 2017-02-21-synchronizing-structs %}). When using the sync.RWMutex in Go, there are two kinds of locks: read locks and write locks. The basic difference is that many read locks can be acquired at the same time, but only one write lock can be acquired at at time."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://bbengfort.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Lock Queuing in Go","item":"https://bbengfort.github.io/2017/09/lock-queueing/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Lock Queuing in Go","name":"Lock Queuing in Go","description":"In Go, you can use sync.Mutex and sync.RWMutex objects to create thread-safe data structures in memory as discussed in [“Synchronizing Structs for Safe Concurrency in Go”]({% post_url 2017-02-21-synchronizing-structs %}). When using the sync.RWMutex in Go, there are two kinds of locks: read locks and write locks. The basic difference is that many read locks can be acquired at the same time, but only one write lock can be acquired at at time.","keywords":[],"articleBody":"In Go, you can use sync.Mutex and sync.RWMutex objects to create thread-safe data structures in memory as discussed in [“Synchronizing Structs for Safe Concurrency in Go”]({% post_url 2017-02-21-synchronizing-structs %}). When using the sync.RWMutex in Go, there are two kinds of locks: read locks and write locks. The basic difference is that many read locks can be acquired at the same time, but only one write lock can be acquired at at time.\nThis means that if a thread attempts to acquire a read lock on an object that is already read locked, then it will not block and it will acquire its own read lock. If a thread attempts to acquire a read or a write lock on a write locked object, then it will block until it is unlocked (as will a write lock acquisition on a read locked object).\nGranting a lock can be prioritized depending on different policies for accesses. Priorities balance the trade-off between concurrency and starvation as follows:\n  Read-Preferring RW allows new read locks to be acquired as long as the lock is read-locked, forcing the write-lock acquirer to wait until there are no more read-locks. In high contention environments, this might lead to write-starvation.\n  Write-Preferring RW prevents a read-lock acquisition if a writer is queued and waiting for the lock. This reduces concurrency, because new read locks have to wait for the write lock, but prevents starvation.\n  So which of these does Go implement? According to the documentation:\n If a goroutine holds a RWMutex for reading and another goroutine might call Lock, no goroutine should expect to be able to acquire a read lock until the initial read lock is released. In particular, this prohibits recursive read locking. This is to ensure that the lock eventually becomes available; a blocked Lock call excludes new readers from acquiring the lock. — godoc\n My initial read of this made me think that Go implements write-preferring mutexes. However, this was not the behavior that I observed.\nConsider the following locker:\nvar delay time.Duration var started time.Time // Locker holds values that are threadsafe type Locker struct { sync.RWMutex value uint64 // the current value of the locker \taccess time.Time // time of the last access } // Write to the value of the locker in a threadsafe fashion. func (l *Locker) Write(value uint64) { l.Lock() defer l.Unlock() // Arbitrary amount of work \ttime.Sleep(delay) l.value = value l.access = time.Now() l.log(\"written\") } // Read the value of the locker in a threadsafe fasion. func (l *Locker) Read() uint64 { l.RLock() defer l.RUnlock() // Arbirtray amount of work \ttime.Sleep(delay / 2) l.access = time.Now() l.log(\"read\") return l.value } // Log the access (not thread-safe) func (l *Locker) log(method string) { after := l.access.Sub(started) log.Printf( \"%d %s after %s\\n\", l.value, method, after, ) } This locker holds a value and logs all accesses to it after the start time. If we run a few threads to read and write to it we can see concurrent reads in action:\nfunc main() { delay = 1 * time.Second started = time.Now() group := new(errgroup.Group) locker := new(Locker) // Straight forward, write three reads and a write \tgroup.Go(func() error { locker.Write(42); return nil }) group.Go(func() error { locker.Read(); return nil }) group.Go(func() error { locker.Read(); return nil }) group.Go(func() error { locker.Read(); return nil }) group.Go(func() error { locker.Write(101); return nil }) group.Wait() } The output is as follows\n$ go run locker.go 2017/09/08 12:26:32 101 written after 1.005058824s 2017/09/08 12:26:33 101 read after 1.50770225s 2017/09/08 12:26:33 101 read after 1.507769109s 2017/09/08 12:26:33 101 read after 1.50773587s 2017/09/08 12:26:34 42 written after 2.511968581s Note that the last go routine actually managed to acquire the lock first, after which the three readers managed to acquire the lock, then finally the last writer. Now if we interleave the read and write access, adding a sleep between the kick-off of each go routine to ensure that the preceding thread has time to acquire the lock:\nfunc main() { delay = 1 * time.Second started = time.Now() group := new(errgroup.Group) locker := new(Locker) // Straight forward, write three reads and a write \tgroup.Go(func() error { locker.Write(42); return nil }) time.Sleep(10 * time.Millisecond) group.Go(func() error { locker.Read(); return nil }) time.Sleep(10 * time.Millisecond) group.Go(func() error { locker.Write(101); return nil }) time.Sleep(10 * time.Millisecond) group.Go(func() error { locker.Read(); return nil }) time.Sleep(10 * time.Millisecond) group.Go(func() error { locker.Write(3); return nil }) time.Sleep(10 * time.Millisecond) group.Go(func() error { locker.Read(); return nil }) time.Sleep(10 * time.Millisecond) group.Go(func() error { locker.Write(18); return nil }) time.Sleep(10 * time.Millisecond) group.Go(func() error { locker.Read(); return nil }) group.Wait() } We get the following output:\ngo run locker.go 2017/09/08 12:29:28 42 written after 1.000178155s 2017/09/08 12:29:28 42 read after 1.500703007s 2017/09/08 12:29:28 42 read after 1.500691088s 2017/09/08 12:29:28 42 read after 1.500756144s 2017/09/08 12:29:28 42 read after 1.500648159s 2017/09/08 12:29:28 42 read after 1.500762323s 2017/09/08 12:29:28 42 read after 1.500679533s 2017/09/08 12:29:28 42 read after 1.500795204s 2017/09/08 12:29:29 101 written after 2.500971593s 2017/09/08 12:29:30 3 written after 3.505325487s 2017/09/08 12:29:31 18 written after 4.50594131s This suggests that the reads continue to acquire locks as long as the Locker is read locked, forcing the writes to happen at the end.\nI found one Stack Overflow post: “Read preferring RW mutex lock in Golang” that seems to suggest that sync.RWMutex can implement both read and write preferred locking, but doesn’t really give an explanation about how external callers can implement it.\nFinally consider the following:\nfunc main() { delay = 1 * time.Second started = time.Now() group := new(errgroup.Group) locker := new(Locker) // Straight forward, write three reads and a write \tgroup.Go(func() error { locker.Write(42); return nil }) group.Go(func() error { locker.Write(101); return nil }) group.Go(func() error { locker.Write(3); return nil }) group.Go(func() error { locker.Write(18); return nil }) for i := 0; i 22; i++ { group.Go(func() error { locker.Read() return nil }) time.Sleep(delay / 4) } group.Wait() } Given the loop issuing 22 read locks that sleep only a quarter of the time of the write lock, we might expect that this code will issue 22 read locks then all the write locks will occur at the end (and if we put this in a forever loop, then the writes would never occur). However, the output of this is as follows:\n2017/09/08 12:43:40 18 written after 1.004461829s 2017/09/08 12:43:40 18 read after 1.508343716s 2017/09/08 12:43:40 18 read after 1.50842899s 2017/09/08 12:43:40 18 read after 1.508362345s 2017/09/08 12:43:40 18 read after 1.508339659s 2017/09/08 12:43:40 18 read after 1.50852229s 2017/09/08 12:43:41 42 written after 2.513789339s 2017/09/08 12:43:42 42 read after 3.0163191s 2017/09/08 12:43:42 42 read after 3.016330534s 2017/09/08 12:43:42 42 read after 3.016355628s 2017/09/08 12:43:42 42 read after 3.016371381s 2017/09/08 12:43:42 42 read after 3.016316992s 2017/09/08 12:43:43 3 written after 4.017954589s 2017/09/08 12:43:43 3 read after 4.518495233s 2017/09/08 12:43:43 3 read after 4.518523255s 2017/09/08 12:43:43 3 read after 4.518537387s 2017/09/08 12:43:43 3 read after 4.518540397s 2017/09/08 12:43:43 3 read after 4.518543262s 2017/09/08 12:43:43 3 read after 4.51863128s 2017/09/08 12:43:44 101 written after 5.521872765s 2017/09/08 12:43:45 101 read after 6.023207828s 2017/09/08 12:43:45 101 read after 6.023225272s 2017/09/08 12:43:45 101 read after 6.023249529s 2017/09/08 12:43:45 101 read after 6.023190828s 2017/09/08 12:43:45 101 read after 6.023243032s 2017/09/08 12:43:45 101 read after 6.023190457s 2017/09/08 12:43:45 101 read after 6.04455716s 2017/09/08 12:43:45 101 read after 6.29457923s What Go implements is actually something else: read locks can only be acquired so long as the original read lock is maintained (the word “initial” being critical in the documentation). As soon as the first read lock is released, then the queued write-lock gets priority. The first read lock lasts approximately 500ms; this means that there is enough time for between 4-5 other locks to acquire a read lock, as soon as the first read lock completes, the write is given priority.\n","wordCount":"1296","inLanguage":"en","datePublished":"2017-09-08T11:31:19Z","dateModified":"2017-09-08T11:31:19Z","author":{"@type":"Person","name":"Benjamin Bengfort"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://bbengfort.github.io/2017/09/lock-queueing/"},"publisher":{"@type":"Organization","name":"Libelli","logo":{"@type":"ImageObject","url":"https://bbengfort.github.io/favicon.ico"}}}</script></head><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme: #1d1e20;--entry: #2e2e33;--primary: rgba(255, 255, 255, 0.84);--secondary: rgba(255, 255, 255, 0.56);--tertiary: rgba(255, 255, 255, 0.16);--content: rgba(255, 255, 255, 0.74);--hljs-bg: #2e2e33;--code-bg: #37383e;--border: #333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://bbengfort.github.io accesskey=h title="Libelli (Alt + H)"><img src=/icon.png alt=logo aria-label=logo height=35>Libelli</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://bbengfort.github.io/archive/ title=archive><span>archive</span></a></li><li><a href=https://bbengfort.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://bbengfort.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://bbengfort.github.io/about/ title=about><span>about</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Lock Queuing in Go</h1><div class=post-meta>September 8, 2017&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Benjamin Bengfort</div></header><div class=post-content><p>In Go, you can use <code>sync.Mutex</code> and <code>sync.RWMutex</code> objects to create thread-safe data structures in memory as discussed in [“Synchronizing Structs for Safe Concurrency in Go”]({% post_url 2017-02-21-synchronizing-structs %}). When using the <code>sync.RWMutex</code> in Go, there are two kinds of locks: read locks and write locks. The basic difference is that many read locks can be acquired at the same time, but only one write lock can be acquired at at time.</p><p>This means that if a thread attempts to acquire a read lock on an object that is already read locked, then it will not block and it will acquire its own read lock. If a thread attempts to acquire a read or a write lock on a write locked object, then it will block until it is unlocked (as will a write lock acquisition on a read locked object).</p><p>Granting a lock can be prioritized depending on different <a href=https://en.wikipedia.org/wiki/Readers%E2%80%93writer_lock>policies for accesses</a>. Priorities balance the trade-off between concurrency and starvation as follows:</p><ol><li><p><em>Read-Preferring RW</em> allows new read locks to be acquired as long as the lock is read-locked, forcing the write-lock acquirer to wait until there are no more read-locks. In high contention environments, this might lead to write-starvation.</p></li><li><p><em>Write-Preferring RW</em> prevents a read-lock acquisition if a writer is queued and waiting for the lock. This reduces concurrency, because new read locks have to wait for the write lock, but prevents starvation.</p></li></ol><p>So which of these does Go implement? According to the documentation:</p><blockquote><p>If a goroutine holds a RWMutex for reading and another goroutine might call Lock, no goroutine should expect to be able to acquire a read lock until the initial read lock is released. In particular, this prohibits recursive read locking. This is to ensure that the lock eventually becomes available; a blocked Lock call excludes new readers from acquiring the lock. <a href=https://golang.org/pkg/sync/#RWMutex>— godoc</a></p></blockquote><p>My initial read of this made me think that Go implements write-preferring mutexes. However, this was not the behavior that I observed.</p><p>Consider the following locker:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>delay</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Duration</span>
<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>started</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Time</span>

<span style=color:#75715e>// Locker holds values that are threadsafe
</span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Locker</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>RWMutex</span>
	<span style=color:#a6e22e>value</span>  <span style=color:#66d9ef>uint64</span>    <span style=color:#75715e>// the current value of the locker
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>access</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Time</span> <span style=color:#75715e>// time of the last access
</span><span style=color:#75715e></span>}

<span style=color:#75715e>// Write to the value of the locker in a threadsafe fashion.
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>l</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Locker</span>) <span style=color:#a6e22e>Write</span>(<span style=color:#a6e22e>value</span> <span style=color:#66d9ef>uint64</span>) {
	<span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>Lock</span>()
	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>Unlock</span>()

	<span style=color:#75715e>// Arbitrary amount of work
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#a6e22e>delay</span>)

	<span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>value</span> = <span style=color:#a6e22e>value</span>
	<span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>access</span> = <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>()
	<span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;written&#34;</span>)
}

<span style=color:#75715e>// Read the value of the locker in a threadsafe fasion.
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>l</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Locker</span>) <span style=color:#a6e22e>Read</span>() <span style=color:#66d9ef>uint64</span> {
	<span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>RLock</span>()
	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>RUnlock</span>()

	<span style=color:#75715e>// Arbirtray amount of work
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#a6e22e>delay</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>)
	<span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>access</span> = <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>()
	<span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;read&#34;</span>)
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>value</span>
}

<span style=color:#75715e>// Log the access (not thread-safe)
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>l</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Locker</span>) <span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>method</span> <span style=color:#66d9ef>string</span>) {
	<span style=color:#a6e22e>after</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>access</span>.<span style=color:#a6e22e>Sub</span>(<span style=color:#a6e22e>started</span>)
	<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Printf</span>(
		<span style=color:#e6db74>&#34;%d %s after %s\n&#34;</span>, <span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>value</span>, <span style=color:#a6e22e>method</span>, <span style=color:#a6e22e>after</span>,
	)
}
</code></pre></div><p>This locker holds a value and logs all accesses to it after the start time. If we run a few threads to read and write to it we can see concurrent reads in action:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#a6e22e>delay</span> = <span style=color:#ae81ff>1</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>
	<span style=color:#a6e22e>started</span> = <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>()
	<span style=color:#a6e22e>group</span> <span style=color:#f92672>:=</span> new(<span style=color:#a6e22e>errgroup</span>.<span style=color:#a6e22e>Group</span>)
	<span style=color:#a6e22e>locker</span> <span style=color:#f92672>:=</span> new(<span style=color:#a6e22e>Locker</span>)

	<span style=color:#75715e>// Straight forward, write three reads and a write
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>group</span>.<span style=color:#a6e22e>Go</span>(<span style=color:#66d9ef>func</span>() <span style=color:#66d9ef>error</span> { <span style=color:#a6e22e>locker</span>.<span style=color:#a6e22e>Write</span>(<span style=color:#ae81ff>42</span>); <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span> })
	<span style=color:#a6e22e>group</span>.<span style=color:#a6e22e>Go</span>(<span style=color:#66d9ef>func</span>() <span style=color:#66d9ef>error</span> { <span style=color:#a6e22e>locker</span>.<span style=color:#a6e22e>Read</span>(); <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span> })
	<span style=color:#a6e22e>group</span>.<span style=color:#a6e22e>Go</span>(<span style=color:#66d9ef>func</span>() <span style=color:#66d9ef>error</span> { <span style=color:#a6e22e>locker</span>.<span style=color:#a6e22e>Read</span>(); <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span> })
	<span style=color:#a6e22e>group</span>.<span style=color:#a6e22e>Go</span>(<span style=color:#66d9ef>func</span>() <span style=color:#66d9ef>error</span> { <span style=color:#a6e22e>locker</span>.<span style=color:#a6e22e>Read</span>(); <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span> })
	<span style=color:#a6e22e>group</span>.<span style=color:#a6e22e>Go</span>(<span style=color:#66d9ef>func</span>() <span style=color:#66d9ef>error</span> { <span style=color:#a6e22e>locker</span>.<span style=color:#a6e22e>Write</span>(<span style=color:#ae81ff>101</span>); <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span> })

	<span style=color:#a6e22e>group</span>.<span style=color:#a6e22e>Wait</span>()
}
</code></pre></div><p>The output is as follows</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>$ go run locker.go
2017/09/08 12:26:32 101 written after 1.005058824s
2017/09/08 12:26:33 101 read after 1.50770225s
2017/09/08 12:26:33 101 read after 1.507769109s
2017/09/08 12:26:33 101 read after 1.50773587s
2017/09/08 12:26:34 42 written after 2.511968581s
</code></pre></div><p>Note that the last go routine actually managed to acquire the lock first, after which the three readers managed to acquire the lock, then finally the last writer. Now if we interleave the read and write access, adding a sleep between the kick-off of each go routine to ensure that the preceding thread has time to acquire the lock:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#a6e22e>delay</span> = <span style=color:#ae81ff>1</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>
	<span style=color:#a6e22e>started</span> = <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>()
	<span style=color:#a6e22e>group</span> <span style=color:#f92672>:=</span> new(<span style=color:#a6e22e>errgroup</span>.<span style=color:#a6e22e>Group</span>)
	<span style=color:#a6e22e>locker</span> <span style=color:#f92672>:=</span> new(<span style=color:#a6e22e>Locker</span>)

	<span style=color:#75715e>// Straight forward, write three reads and a write
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>group</span>.<span style=color:#a6e22e>Go</span>(<span style=color:#66d9ef>func</span>() <span style=color:#66d9ef>error</span> { <span style=color:#a6e22e>locker</span>.<span style=color:#a6e22e>Write</span>(<span style=color:#ae81ff>42</span>); <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span> })
	<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#ae81ff>10</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Millisecond</span>)
	<span style=color:#a6e22e>group</span>.<span style=color:#a6e22e>Go</span>(<span style=color:#66d9ef>func</span>() <span style=color:#66d9ef>error</span> { <span style=color:#a6e22e>locker</span>.<span style=color:#a6e22e>Read</span>(); <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span> })
	<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#ae81ff>10</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Millisecond</span>)
	<span style=color:#a6e22e>group</span>.<span style=color:#a6e22e>Go</span>(<span style=color:#66d9ef>func</span>() <span style=color:#66d9ef>error</span> { <span style=color:#a6e22e>locker</span>.<span style=color:#a6e22e>Write</span>(<span style=color:#ae81ff>101</span>); <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span> })
	<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#ae81ff>10</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Millisecond</span>)
	<span style=color:#a6e22e>group</span>.<span style=color:#a6e22e>Go</span>(<span style=color:#66d9ef>func</span>() <span style=color:#66d9ef>error</span> { <span style=color:#a6e22e>locker</span>.<span style=color:#a6e22e>Read</span>(); <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span> })
	<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#ae81ff>10</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Millisecond</span>)
	<span style=color:#a6e22e>group</span>.<span style=color:#a6e22e>Go</span>(<span style=color:#66d9ef>func</span>() <span style=color:#66d9ef>error</span> { <span style=color:#a6e22e>locker</span>.<span style=color:#a6e22e>Write</span>(<span style=color:#ae81ff>3</span>); <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span> })
	<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#ae81ff>10</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Millisecond</span>)
	<span style=color:#a6e22e>group</span>.<span style=color:#a6e22e>Go</span>(<span style=color:#66d9ef>func</span>() <span style=color:#66d9ef>error</span> { <span style=color:#a6e22e>locker</span>.<span style=color:#a6e22e>Read</span>(); <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span> })
	<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#ae81ff>10</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Millisecond</span>)
	<span style=color:#a6e22e>group</span>.<span style=color:#a6e22e>Go</span>(<span style=color:#66d9ef>func</span>() <span style=color:#66d9ef>error</span> { <span style=color:#a6e22e>locker</span>.<span style=color:#a6e22e>Write</span>(<span style=color:#ae81ff>18</span>); <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span> })
	<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#ae81ff>10</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Millisecond</span>)
	<span style=color:#a6e22e>group</span>.<span style=color:#a6e22e>Go</span>(<span style=color:#66d9ef>func</span>() <span style=color:#66d9ef>error</span> { <span style=color:#a6e22e>locker</span>.<span style=color:#a6e22e>Read</span>(); <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span> })

	<span style=color:#a6e22e>group</span>.<span style=color:#a6e22e>Wait</span>()
}
</code></pre></div><p>We get the following output:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>go run locker.go
2017/09/08 12:29:28 42 written after 1.000178155s
2017/09/08 12:29:28 42 read after 1.500703007s
2017/09/08 12:29:28 42 read after 1.500691088s
2017/09/08 12:29:28 42 read after 1.500756144s
2017/09/08 12:29:28 42 read after 1.500648159s
2017/09/08 12:29:28 42 read after 1.500762323s
2017/09/08 12:29:28 42 read after 1.500679533s
2017/09/08 12:29:28 42 read after 1.500795204s
2017/09/08 12:29:29 101 written after 2.500971593s
2017/09/08 12:29:30 3 written after 3.505325487s
2017/09/08 12:29:31 18 written after 4.50594131s
</code></pre></div><p>This suggests that the reads continue to acquire locks as long as the <code>Locker</code> is read locked, forcing the writes to happen at the end.</p><p>I found one Stack Overflow post: <a href=https://stackoverflow.com/questions/36548702/read-preferring-rw-mutex-lock-in-golang>“Read preferring RW mutex lock in Golang”</a> that seems to suggest that <code>sync.RWMutex</code> can implement both read and write preferred locking, but doesn&rsquo;t really give an explanation about how external callers can implement it.</p><p>Finally consider the following:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#a6e22e>delay</span> = <span style=color:#ae81ff>1</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>
	<span style=color:#a6e22e>started</span> = <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>()
	<span style=color:#a6e22e>group</span> <span style=color:#f92672>:=</span> new(<span style=color:#a6e22e>errgroup</span>.<span style=color:#a6e22e>Group</span>)
	<span style=color:#a6e22e>locker</span> <span style=color:#f92672>:=</span> new(<span style=color:#a6e22e>Locker</span>)

	<span style=color:#75715e>// Straight forward, write three reads and a write
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>group</span>.<span style=color:#a6e22e>Go</span>(<span style=color:#66d9ef>func</span>() <span style=color:#66d9ef>error</span> { <span style=color:#a6e22e>locker</span>.<span style=color:#a6e22e>Write</span>(<span style=color:#ae81ff>42</span>); <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span> })
	<span style=color:#a6e22e>group</span>.<span style=color:#a6e22e>Go</span>(<span style=color:#66d9ef>func</span>() <span style=color:#66d9ef>error</span> { <span style=color:#a6e22e>locker</span>.<span style=color:#a6e22e>Write</span>(<span style=color:#ae81ff>101</span>); <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span> })
	<span style=color:#a6e22e>group</span>.<span style=color:#a6e22e>Go</span>(<span style=color:#66d9ef>func</span>() <span style=color:#66d9ef>error</span> { <span style=color:#a6e22e>locker</span>.<span style=color:#a6e22e>Write</span>(<span style=color:#ae81ff>3</span>); <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span> })
	<span style=color:#a6e22e>group</span>.<span style=color:#a6e22e>Go</span>(<span style=color:#66d9ef>func</span>() <span style=color:#66d9ef>error</span> { <span style=color:#a6e22e>locker</span>.<span style=color:#a6e22e>Write</span>(<span style=color:#ae81ff>18</span>); <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span> })

	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#ae81ff>22</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
		<span style=color:#a6e22e>group</span>.<span style=color:#a6e22e>Go</span>(<span style=color:#66d9ef>func</span>() <span style=color:#66d9ef>error</span> {
			<span style=color:#a6e22e>locker</span>.<span style=color:#a6e22e>Read</span>()
			<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
		})
		<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#a6e22e>delay</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>4</span>)
	}

	<span style=color:#a6e22e>group</span>.<span style=color:#a6e22e>Wait</span>()
}
</code></pre></div><p>Given the loop issuing 22 read locks that sleep only a quarter of the time of the write lock, we might expect that this code will issue 22 read locks then all the write locks will occur at the end (and if we put this in a forever loop, then the writes would never occur). However, the output of this is as follows:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>2017/09/08 12:43:40 18 written after 1.004461829s
2017/09/08 12:43:40 18 read after 1.508343716s
2017/09/08 12:43:40 18 read after 1.50842899s
2017/09/08 12:43:40 18 read after 1.508362345s
2017/09/08 12:43:40 18 read after 1.508339659s
2017/09/08 12:43:40 18 read after 1.50852229s
2017/09/08 12:43:41 42 written after 2.513789339s
2017/09/08 12:43:42 42 read after 3.0163191s
2017/09/08 12:43:42 42 read after 3.016330534s
2017/09/08 12:43:42 42 read after 3.016355628s
2017/09/08 12:43:42 42 read after 3.016371381s
2017/09/08 12:43:42 42 read after 3.016316992s
2017/09/08 12:43:43 3 written after 4.017954589s
2017/09/08 12:43:43 3 read after 4.518495233s
2017/09/08 12:43:43 3 read after 4.518523255s
2017/09/08 12:43:43 3 read after 4.518537387s
2017/09/08 12:43:43 3 read after 4.518540397s
2017/09/08 12:43:43 3 read after 4.518543262s
2017/09/08 12:43:43 3 read after 4.51863128s
2017/09/08 12:43:44 101 written after 5.521872765s
2017/09/08 12:43:45 101 read after 6.023207828s
2017/09/08 12:43:45 101 read after 6.023225272s
2017/09/08 12:43:45 101 read after 6.023249529s
2017/09/08 12:43:45 101 read after 6.023190828s
2017/09/08 12:43:45 101 read after 6.023243032s
2017/09/08 12:43:45 101 read after 6.023190457s
2017/09/08 12:43:45 101 read after 6.04455716s
2017/09/08 12:43:45 101 read after 6.29457923s
</code></pre></div><p>What Go implements is actually something else: read locks can only be acquired <em>so long as the original read lock is maintained</em> (the word “initial” being critical in the documentation). As soon as the first read lock is released, then the queued write-lock gets priority. The first read lock lasts approximately 500ms; this means that there is enough time for between 4-5 other locks to acquire a read lock, as soon as the first read lock completes, the write is given priority.</p></div><footer class=post-footer></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://bbengfort.github.io>Libelli</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById('menu')
menu.scrollLeft=localStorage.getItem("menu-scroll-position");menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft);}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);if(!window.matchMedia('(prefers-reduced-motion: reduce)').matches){document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});}else{document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();}
if(id==="top"){history.replaceState(null,null," ");}else{history.pushState(null,null,`#${id}`);}});});</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script></body></html>