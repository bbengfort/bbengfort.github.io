<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Rapid FS Walks with ErrGroup | Libelli</title><meta name=keywords content><meta name=description content="I&rsquo;ve been looking for a way to quickly scan a file system and gather information about the files in directories contained within. I had been doing this with multiprocessing in Python, but figured Go could speed up my performance by a lot. What I discovered when I went down this path was the sync.ErrGroup, an extension of the sync.WaitGroup that helps manage the complexity of multiple go routines but also includes error handling!"><meta name=author content="Benjamin Bengfort"><link rel=canonical href=https://bbengfort.github.io/2017/08/rapid-fs-walk/><link crossorigin=anonymous href=/assets/css/stylesheet.min.d0c0348c2d0cff14148d0e347258519d8df2ce53ce5ac32c7bd9a549182cb8ae.css integrity="sha256-0MA0jC0M/xQUjQ40clhRnY3yzlPOWsMse9mlSRgsuK4=" rel="preload stylesheet" as=style><link rel=preload href=/icon.png as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><link rel=icon href=https://bbengfort.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://bbengfort.github.io/icon.png><link rel=icon type=image/png sizes=32x32 href=https://bbengfort.github.io/icon.png><link rel=apple-touch-icon href=https://bbengfort.github.io/apple-touch-icon-precomposed.png><link rel=mask-icon href=https://bbengfort.github.io/icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.79.0"><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-8096804-11','auto');ga('send','pageview');}</script><meta property="og:title" content="Rapid FS Walks with ErrGroup"><meta property="og:description" content="I&rsquo;ve been looking for a way to quickly scan a file system and gather information about the files in directories contained within. I had been doing this with multiprocessing in Python, but figured Go could speed up my performance by a lot. What I discovered when I went down this path was the sync.ErrGroup, an extension of the sync.WaitGroup that helps manage the complexity of multiple go routines but also includes error handling!"><meta property="og:type" content="article"><meta property="og:url" content="https://bbengfort.github.io/2017/08/rapid-fs-walk/"><meta property="og:image" content="https://bbengfort.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-08-18T15:33:35+00:00"><meta property="article:modified_time" content="2017-08-18T15:33:35+00:00"><meta property="og:site_name" content="Libelli"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://bbengfort.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Rapid FS Walks with ErrGroup"><meta name=twitter:description content="I&rsquo;ve been looking for a way to quickly scan a file system and gather information about the files in directories contained within. I had been doing this with multiprocessing in Python, but figured Go could speed up my performance by a lot. What I discovered when I went down this path was the sync.ErrGroup, an extension of the sync.WaitGroup that helps manage the complexity of multiple go routines but also includes error handling!"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://bbengfort.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Rapid FS Walks with ErrGroup","item":"https://bbengfort.github.io/2017/08/rapid-fs-walk/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Rapid FS Walks with ErrGroup","name":"Rapid FS Walks with ErrGroup","description":"I\u0026rsquo;ve been looking for a way to quickly scan a file system and gather information about the files in directories contained within. I had been doing this with multiprocessing in Python, but figured Go could speed up my performance by a lot. What I discovered when I went down this path was the sync.ErrGroup, an extension of the sync.WaitGroup that helps manage the complexity of multiple go routines but also includes error handling!","keywords":[],"articleBody":"I’ve been looking for a way to quickly scan a file system and gather information about the files in directories contained within. I had been doing this with multiprocessing in Python, but figured Go could speed up my performance by a lot. What I discovered when I went down this path was the sync.ErrGroup, an extension of the sync.WaitGroup that helps manage the complexity of multiple go routines but also includes error handling!\nThe end result of this exploration was a utility called urfs — which you can install on your system to take a uniform random sample of files in a directory or to compute the number of files and bytes per directory. This utility is also extensible to a large number of functionality that requires rapid walking of a file system like search or other utilities.\nThis post is therefore a bit of a walkthrough on using sync.ErrGroup for scanning a file system and applying arbitrary functions. First a couple of types:\ntype WalkFunc func(path string) (string, error) type FSWalker struct { Workers int SkipHidden bool SkipDirs bool Match string root string paths chan string nPaths uint64 results chan string nResults uint64 group *errgroup.Group ctx context.Context started time.Time duration time.Duration } The first type is a generic function that can be passed to the Walk method of the FSWalker. The FSWalker maintains state with a variety of channels, and of course the errgroup.Group object. The SkipHidden, SkipDirs, and Match properties allow us to filter path types being passed to Walk.\nTo initialize FSWalker:\nfunc (fs *FSWalker) Init(ctx context.Context) { // Set up FSWalker defaults \tfs.Workers = DefaultWorkers fs.SkipHidden = true fs.SkipDirs = true fs.Match = \"*\" // Create the context for the errgroup \tif ctx == nil { // Create a new context \tctx = context.Background() deadline, ok := fs.ctx.Deadline() if ok { ctx, _ = context.WithDeadline(ctx, deadline) } } // Create the err group  fs.group, fs.ctx = errgroup.WithContext(ctx) // Create channels and instantiate other statistics variables \tfs.paths = make(chan string, DefaultBuffer) fs.results = make(chan string, DefaultBuffer) fs.nPaths = 0 fs.nResults = 0 fs.started = time.Time{} fs.duration = time.Duration(0) } Ok, so we’re doing a lot of work here, but things get paid off in the Walk function where we keep track of the number of paths we’ve seen at a root directory, passing them off to a WalkFunc using a variety of Go routines:\nfunc (fs *FSWalker) Walk(path string, walkFn WalkFunc) error { // Compute the duration of the walk \tfs.started = time.Now() defer func() { fs.duration = time.Since(fs.started) }() // Set the root path for the walk \tfs.root = path // Launch the goroutine that populates the paths \tfs.group.Go(func() error { // Ensure that the channel is closed when all paths loaded  defer close(fs.paths) // Apply the path filter to the filepath.Walk function  return filepath.Walk(fs.root, fs.filterPaths) }) // Create the worker function and allocate pool \tworker := fs.worker(walkFn) for w := 0; w fs.Workers; w++ { fs.group.Go(worker) } // Wait for the workers to complete, then close the results channel \tgo func() { fs.group.Wait() close(fs.results) }() // Start gathering the results \tfor _ = range fs.results { fs.nResults++ } return fs.group.Wait() } So this is a lot of code, let’s step through it. The first thing we do is set the started time to now, and defer a function to compute the duration as the difference between the time at the end of the function and the start function. We also set the root value. We then launch a go routine in the ErrGroup by using fs.group.Go(func) — this function must have the signature func() error, so we use an anonymous function to kick off the filepath.Walk, which starts walking the directory structure, adding paths that match the filter criteria to a buffered channel called fs.paths, more on this later. This channel must be closed on complete so that our worker go routines complete, more on that later.\nNext we create a worker function using our worker method and walk function. The workers read paths off the fs.paths channel, and apply the walkFn to each path individually. Note that we use a pool-like structure here, limiting the number of workers to 5000 — this is so we don’t get a “too many files open” error when we exhaust the number of file descriptors since Go has unlimited go routines. The worker definitions is here:\nfunc (fs *FSWalker) worker(walkFn WalkFunc) func() error { return func() error { // Apply the function all paths in the channel \tfor path := range fs.paths { // avoid race condition \tp := path // apply the walk function to the path and return errors \tr, err := walkFn(p) if err != nil { return err } // store the result and check the context \tif r != \"\" { select { case fs.results  r: case fs.ctx.Done(): return fs.ctx.Err() } } } return nil } } As you can see, the worker function just creates a closure with the signature of our ErrGroup function, so that we can pass it to the wait group. All the worker function does is range over the paths channel, applying the path to the walkFn.\nFinally, we kick off another go routine that waits until all the workers have stopped, and when it does, we close our results channel. We do this so that we can start gathering results, immediately; we don’t have to wait. We can do this by simply ranging over the results channel and adding the number of results. A final wait at the end means that we can wait for all go routines to complete.\nLastly the filter function. We want to ignore files and directories that are hidden, e.g. start with a “.” or a “~” on Unix systems. We also want to be able to pass a glob like matcher, e.g. \"*.txt\" to only match text files. The filter function is here:\n// Internal filter paths function that is passed to filepath.Walk func (fs *FSWalker) filterPaths(path string, info os.FileInfo, err error) error { // Propagate any errors \tif err != nil { return err } // Check to ensure that no mode bits are set \tif !info.Mode().IsRegular() { return nil } // Get the name of the file without the complete path \tname := info.Name() // Skip hidden files or directories if required. \tif fs.SkipHidden { if strings.HasPrefix(name, \".\") || strings.HasPrefix(name, \"~\") { return nil } } // Skip directories if required \tif fs.SkipDirs { if info.IsDir() { return nil } } // Check to see if the pattern matches the file \tmatch, err := filepath.Match(fs.Match, name) if err != nil { return err } else if !match { return nil } // Increment the total number of paths we've seen. \tatomic.AddUint64(\u0026fs.nPaths, 1) select { case fs.paths  path: case fs.ctx.Done(): return fs.ctx.Err() } return nil } And that’s it, with this simple framework, you can apply an arbitrary walkFn to all paths in a directory, matching a specific criteria. The big win here is to manage all of the go routines using the ErrGroup and a context.Context object.\nThe following post: Run strikingly fast parallel file searches in Go with sync.ErrGroup by Brian Ketelsen was the primary inspiration for the use of sync.ErrGroup.\n","wordCount":"1206","inLanguage":"en","datePublished":"2017-08-18T15:33:35Z","dateModified":"2017-08-18T15:33:35Z","author":{"@type":"Person","name":"Benjamin Bengfort"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://bbengfort.github.io/2017/08/rapid-fs-walk/"},"publisher":{"@type":"Organization","name":"Libelli","logo":{"@type":"ImageObject","url":"https://bbengfort.github.io/favicon.ico"}}}</script></head><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme: #1d1e20;--entry: #2e2e33;--primary: rgba(255, 255, 255, 0.84);--secondary: rgba(255, 255, 255, 0.56);--tertiary: rgba(255, 255, 255, 0.16);--content: rgba(255, 255, 255, 0.74);--hljs-bg: #2e2e33;--code-bg: #37383e;--border: #333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://bbengfort.github.io accesskey=h title="Libelli (Alt + H)"><img src=/icon.png alt=logo aria-label=logo height=35>Libelli</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://bbengfort.github.io/archive/ title=archive><span>archive</span></a></li><li><a href=https://bbengfort.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://bbengfort.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://bbengfort.github.io/about/ title=about><span>about</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Rapid FS Walks with ErrGroup</h1><div class=post-meta>August 18, 2017&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Benjamin Bengfort</div></header><div class=post-content><p>I&rsquo;ve been looking for a way to quickly scan a file system and gather information about the files in directories contained within. I had been doing this with multiprocessing in Python, but figured Go could speed up my performance by a lot. What I discovered when I went down this path was the <a href=https://godoc.org/golang.org/x/sync/errgroup><code>sync.ErrGroup</code></a>, an extension of the <code>sync.WaitGroup</code> that helps manage the complexity of multiple go routines but also includes error handling!</p><p>The end result of this exploration was a utility called <a href=https://github.com/bbengfort/urfs>urfs</a> — which you can install on your system to take a uniform random sample of files in a directory or to compute the number of files and bytes per directory. This utility is also extensible to a large number of functionality that requires rapid walking of a file system like search or other utilities.</p><p>This post is therefore a bit of a walkthrough on using <code>sync.ErrGroup</code> for scanning a file system and applying arbitrary functions. First a couple of types:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>WalkFunc</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>path</span> <span style=color:#66d9ef>string</span>) (<span style=color:#66d9ef>string</span>, <span style=color:#66d9ef>error</span>)

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>FSWalker</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>Workers</span>    <span style=color:#66d9ef>int</span>             
	<span style=color:#a6e22e>SkipHidden</span> <span style=color:#66d9ef>bool</span>            
	<span style=color:#a6e22e>SkipDirs</span>   <span style=color:#66d9ef>bool</span>            
	<span style=color:#a6e22e>Match</span>      <span style=color:#66d9ef>string</span>          
	<span style=color:#a6e22e>root</span>       <span style=color:#66d9ef>string</span>          
	<span style=color:#a6e22e>paths</span>      <span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>string</span>     
	<span style=color:#a6e22e>nPaths</span>     <span style=color:#66d9ef>uint64</span>          
	<span style=color:#a6e22e>results</span>    <span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>string</span>     
	<span style=color:#a6e22e>nResults</span>   <span style=color:#66d9ef>uint64</span>        
	<span style=color:#a6e22e>group</span>      <span style=color:#f92672>*</span><span style=color:#a6e22e>errgroup</span>.<span style=color:#a6e22e>Group</span>
	<span style=color:#a6e22e>ctx</span>        <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>
	<span style=color:#a6e22e>started</span>    <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Time</span>       
	<span style=color:#a6e22e>duration</span>   <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Duration</span>   
}
</code></pre></div><p>The first type is a generic function that can be passed to the <code>Walk</code> method of the <code>FSWalker</code>. The <code>FSWalker</code> maintains state with a variety of channels, and of course the <code>errgroup.Group</code> object. The SkipHidden, SkipDirs, and Match properties allow us to filter path types being passed to Walk.</p><p>To initialize <code>FSWalker</code>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>fs</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>FSWalker</span>) <span style=color:#a6e22e>Init</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>) {
	<span style=color:#75715e>// Set up FSWalker defaults
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>Workers</span> = <span style=color:#a6e22e>DefaultWorkers</span>
	<span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>SkipHidden</span> = <span style=color:#66d9ef>true</span>
	<span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>SkipDirs</span> = <span style=color:#66d9ef>true</span>
	<span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>Match</span> = <span style=color:#e6db74>&#34;*&#34;</span>

    <span style=color:#75715e>// Create the context for the errgroup
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ctx</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#75715e>// Create a new context
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>ctx</span> = <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Background</span>()
		<span style=color:#a6e22e>deadline</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>Deadline</span>()
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ok</span> {
			<span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>_</span> = <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>WithDeadline</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>deadline</span>)
		}
	}

    <span style=color:#75715e>// Create the err group
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>group</span>, <span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>ctx</span> = <span style=color:#a6e22e>errgroup</span>.<span style=color:#a6e22e>WithContext</span>(<span style=color:#a6e22e>ctx</span>)

    <span style=color:#75715e>// Create channels and instantiate other statistics variables
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>paths</span> = make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>DefaultBuffer</span>)
	<span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>results</span> = make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>DefaultBuffer</span>)
	<span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>nPaths</span> = <span style=color:#ae81ff>0</span>
	<span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>nResults</span> = <span style=color:#ae81ff>0</span>
	<span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>started</span> = <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Time</span>{}
	<span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>duration</span> = <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Duration</span>(<span style=color:#ae81ff>0</span>)
}
</code></pre></div><p>Ok, so we&rsquo;re doing a lot of work here, but things get paid off in the Walk function where we keep track of the number of paths we&rsquo;ve seen at a root directory, passing them off to a <code>WalkFunc</code> using a variety of Go routines:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>fs</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>FSWalker</span>) <span style=color:#a6e22e>Walk</span>(<span style=color:#a6e22e>path</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>walkFn</span> <span style=color:#a6e22e>WalkFunc</span>) <span style=color:#66d9ef>error</span> {
	<span style=color:#75715e>// Compute the duration of the walk
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>started</span> = <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>()
	<span style=color:#66d9ef>defer</span> <span style=color:#66d9ef>func</span>() { <span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>duration</span> = <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Since</span>(<span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>started</span>) }()

	<span style=color:#75715e>// Set the root path for the walk
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>root</span> = <span style=color:#a6e22e>path</span>

	<span style=color:#75715e>// Launch the goroutine that populates the paths
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>group</span>.<span style=color:#a6e22e>Go</span>(<span style=color:#66d9ef>func</span>() <span style=color:#66d9ef>error</span> {
        <span style=color:#75715e>// Ensure that the channel is closed when all paths loaded
</span><span style=color:#75715e></span>    	<span style=color:#66d9ef>defer</span> close(<span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>paths</span>)

        <span style=color:#75715e>// Apply the path filter to the filepath.Walk function
</span><span style=color:#75715e></span>    	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>filepath</span>.<span style=color:#a6e22e>Walk</span>(<span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>root</span>, <span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>filterPaths</span>)
    })

	<span style=color:#75715e>// Create the worker function and allocate pool
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>worker</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>worker</span>(<span style=color:#a6e22e>walkFn</span>)
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>w</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>w</span> &lt; <span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>Workers</span>; <span style=color:#a6e22e>w</span><span style=color:#f92672>++</span> {
		<span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>group</span>.<span style=color:#a6e22e>Go</span>(<span style=color:#a6e22e>worker</span>)
	}

	<span style=color:#75715e>// Wait for the workers to complete, then close the results channel
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() {
		<span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>group</span>.<span style=color:#a6e22e>Wait</span>()
		close(<span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>results</span>)
	}()

	<span style=color:#75715e>// Start gathering the results
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span> = <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>results</span> {
		<span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>nResults</span><span style=color:#f92672>++</span>
	}

	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>group</span>.<span style=color:#a6e22e>Wait</span>()
}
</code></pre></div><p>So this is a lot of code, let&rsquo;s step through it. The first thing we do is set the started time to now, and defer a function to compute the duration as the difference between the time at the end of the function and the start function. We also set the root value. We then launch a go routine in the <code>ErrGroup</code> by using <code>fs.group.Go(func)</code> — this function must have the signature <code>func() error</code>, so we use an anonymous function to kick off the <code>filepath.Walk</code>, which starts walking the directory structure, adding paths that match the filter criteria to a buffered channel called <code>fs.paths</code>, more on this later. This channel must be closed on complete so that our worker go routines complete, more on that later.</p><p>Next we create a worker function using our worker method and walk function. The workers read paths off the <code>fs.paths</code> channel, and apply the walkFn to each path individually. Note that we use a pool-like structure here, limiting the number of workers to 5000 — this is so we don&rsquo;t get a &ldquo;too many files open&rdquo; error when we exhaust the number of file descriptors since Go has unlimited go routines. The worker definitions is here:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>fs</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>FSWalker</span>) <span style=color:#a6e22e>worker</span>(<span style=color:#a6e22e>walkFn</span> <span style=color:#a6e22e>WalkFunc</span>) <span style=color:#66d9ef>func</span>() <span style=color:#66d9ef>error</span> {
	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>func</span>() <span style=color:#66d9ef>error</span> {
		<span style=color:#75715e>// Apply the function all paths in the channel
</span><span style=color:#75715e></span>		<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>path</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>paths</span> {
			<span style=color:#75715e>// avoid race condition
</span><span style=color:#75715e></span>			<span style=color:#a6e22e>p</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>path</span>

			<span style=color:#75715e>// apply the walk function to the path and return errors
</span><span style=color:#75715e></span>			<span style=color:#a6e22e>r</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>walkFn</span>(<span style=color:#a6e22e>p</span>)
			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
				<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
			}

			<span style=color:#75715e>// store the result and check the context
</span><span style=color:#75715e></span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>r</span> <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#34;&#34;</span> {

				<span style=color:#66d9ef>select</span> {
				<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>results</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>r</span>:
				<span style=color:#66d9ef>case</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>Done</span>():
					<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>Err</span>()
				}
			}

		}
		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
	}
}
</code></pre></div><p>As you can see, the worker function just creates a closure with the signature of our <code>ErrGroup</code> function, so that we can pass it to the wait group. All the worker function does is range over the paths channel, applying the path to the <code>walkFn</code>.</p><p>Finally, we kick off another go routine that waits until all the workers have stopped, and when it does, we close our results channel. We do this so that we can start gathering results, immediately; we don&rsquo;t have to wait. We can do this by simply ranging over the results channel and adding the number of results. A final wait at the end means that we can wait for all go routines to complete.</p><p>Lastly the filter function. We want to ignore files and directories that are hidden, e.g. start with a &ldquo;.&rdquo; or a &ldquo;~&rdquo; on Unix systems. We also want to be able to pass a glob like matcher, e.g. <code>"*.txt"</code> to only match text files. The filter function is here:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// Internal filter paths function that is passed to filepath.Walk
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>fs</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>FSWalker</span>) <span style=color:#a6e22e>filterPaths</span>(<span style=color:#a6e22e>path</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>info</span> <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>FileInfo</span>, <span style=color:#a6e22e>err</span> <span style=color:#66d9ef>error</span>) <span style=color:#66d9ef>error</span> {
	<span style=color:#75715e>// Propagate any errors
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
	}

	<span style=color:#75715e>// Check to ensure that no mode bits are set
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>info</span>.<span style=color:#a6e22e>Mode</span>().<span style=color:#a6e22e>IsRegular</span>() {
		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
	}

	<span style=color:#75715e>// Get the name of the file without the complete path
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>name</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>info</span>.<span style=color:#a6e22e>Name</span>()

	<span style=color:#75715e>// Skip hidden files or directories if required.
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>SkipHidden</span> {
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>strings</span>.<span style=color:#a6e22e>HasPrefix</span>(<span style=color:#a6e22e>name</span>, <span style=color:#e6db74>&#34;.&#34;</span>) <span style=color:#f92672>||</span> <span style=color:#a6e22e>strings</span>.<span style=color:#a6e22e>HasPrefix</span>(<span style=color:#a6e22e>name</span>, <span style=color:#e6db74>&#34;~&#34;</span>) {
			<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
		}
	}

	<span style=color:#75715e>// Skip directories if required
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>SkipDirs</span> {
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>info</span>.<span style=color:#a6e22e>IsDir</span>() {
			<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
		}
	}

	<span style=color:#75715e>// Check to see if the pattern matches the file
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>match</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>filepath</span>.<span style=color:#a6e22e>Match</span>(<span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>Match</span>, <span style=color:#a6e22e>name</span>)
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
	} <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>match</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
	}

	<span style=color:#75715e>// Increment the total number of paths we&#39;ve seen.
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>AddUint64</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>nPaths</span>, <span style=color:#ae81ff>1</span>)

	<span style=color:#66d9ef>select</span> {
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>paths</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>path</span>:
	<span style=color:#66d9ef>case</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>Done</span>():
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>Err</span>()
	}

	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
}
</code></pre></div><p>And that&rsquo;s it, with this simple framework, you can apply an arbitrary <code>walkFn</code> to all paths in a directory, matching a specific criteria. The big win here is to manage all of the go routines using the <code>ErrGroup</code> and a <code>context.Context</code> object.</p><p>The following post: <a href=https://www.oreilly.com/learning/run-strikingly-fast-parallel-file-searches-in-go-with-sync-errgroup>Run strikingly fast parallel file searches in Go with sync.ErrGroup</a> by <a href=https://www.oreilly.com/people/7e856-brian-ketelsen>Brian Ketelsen</a> was the primary inspiration for the use of sync.ErrGroup.</p></div><footer class=post-footer></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://bbengfort.github.io>Libelli</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById('menu')
menu.scrollLeft=localStorage.getItem("menu-scroll-position");menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft);}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);if(!window.matchMedia('(prefers-reduced-motion: reduce)').matches){document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});}else{document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();}
if(id==="top"){history.replaceState(null,null," ");}else{history.pushState(null,null,`#${id}`);}});});</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script></body></html>