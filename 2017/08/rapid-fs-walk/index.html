<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Rapid FS Walks with ErrGroup | Libelli</title><meta name=keywords content><meta name=description content="I&rsquo;ve been looking for a way to quickly scan a file system and gather information about the files in directories contained within. I had been doing this with multiprocessing in Python, but figured Go could speed up my performance by a lot. What I discovered when I went down this path was the sync.ErrGroup, an extension of the sync.WaitGroup that helps manage the complexity of multiple go routines but also includes error handling!"><meta name=author content="Benjamin Bengfort"><link rel=canonical href=https://bbengfort.github.io/2017/08/rapid-fs-walk/><link crossorigin=anonymous href=/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe+FVUFzPh7U=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://bbengfort.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://bbengfort.github.io/icon.png><link rel=icon type=image/png sizes=32x32 href=https://bbengfort.github.io/icon.png><link rel=apple-touch-icon href=https://bbengfort.github.io/apple-touch-icon-precomposed.png><link rel=mask-icon href=https://bbengfort.github.io/icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-D3BE7EHHVP"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-D3BE7EHHVP",{anonymize_ip:!1})}</script><meta property="og:title" content="Rapid FS Walks with ErrGroup"><meta property="og:description" content="I&rsquo;ve been looking for a way to quickly scan a file system and gather information about the files in directories contained within. I had been doing this with multiprocessing in Python, but figured Go could speed up my performance by a lot. What I discovered when I went down this path was the sync.ErrGroup, an extension of the sync.WaitGroup that helps manage the complexity of multiple go routines but also includes error handling!"><meta property="og:type" content="article"><meta property="og:url" content="https://bbengfort.github.io/2017/08/rapid-fs-walk/"><meta property="og:image" content="https://bbengfort.github.io/bear.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-08-18T15:33:35+00:00"><meta property="article:modified_time" content="2017-08-18T15:33:35+00:00"><meta property="og:site_name" content="Libelli"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://bbengfort.github.io/bear.png"><meta name=twitter:title content="Rapid FS Walks with ErrGroup"><meta name=twitter:description content="I&rsquo;ve been looking for a way to quickly scan a file system and gather information about the files in directories contained within. I had been doing this with multiprocessing in Python, but figured Go could speed up my performance by a lot. What I discovered when I went down this path was the sync.ErrGroup, an extension of the sync.WaitGroup that helps manage the complexity of multiple go routines but also includes error handling!"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://bbengfort.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Rapid FS Walks with ErrGroup","item":"https://bbengfort.github.io/2017/08/rapid-fs-walk/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Rapid FS Walks with ErrGroup","name":"Rapid FS Walks with ErrGroup","description":"I\u0026rsquo;ve been looking for a way to quickly scan a file system and gather information about the files in directories contained within. I had been doing this with multiprocessing in Python, but figured Go could speed up my performance by a lot. What I discovered when I went down this path was the sync.ErrGroup, an extension of the sync.WaitGroup that helps manage the complexity of multiple go routines but also includes error handling!","keywords":[],"articleBody":"I’ve been looking for a way to quickly scan a file system and gather information about the files in directories contained within. I had been doing this with multiprocessing in Python, but figured Go could speed up my performance by a lot. What I discovered when I went down this path was the sync.ErrGroup, an extension of the sync.WaitGroup that helps manage the complexity of multiple go routines but also includes error handling!\nThe end result of this exploration was a utility called urfs — which you can install on your system to take a uniform random sample of files in a directory or to compute the number of files and bytes per directory. This utility is also extensible to a large number of functionality that requires rapid walking of a file system like search or other utilities.\nThis post is therefore a bit of a walkthrough on using sync.ErrGroup for scanning a file system and applying arbitrary functions. First a couple of types:\ntype WalkFunc func(path string) (string, error) type FSWalker struct { Workers int SkipHidden bool SkipDirs bool Match string root string paths chan string nPaths uint64 results chan string nResults uint64 group *errgroup.Group ctx context.Context started time.Time duration time.Duration } The first type is a generic function that can be passed to the Walk method of the FSWalker. The FSWalker maintains state with a variety of channels, and of course the errgroup.Group object. The SkipHidden, SkipDirs, and Match properties allow us to filter path types being passed to Walk.\nTo initialize FSWalker:\nfunc (fs *FSWalker) Init(ctx context.Context) { // Set up FSWalker defaults fs.Workers = DefaultWorkers fs.SkipHidden = true fs.SkipDirs = true fs.Match = \"*\" // Create the context for the errgroup if ctx == nil { // Create a new context ctx = context.Background() deadline, ok := fs.ctx.Deadline() if ok { ctx, _ = context.WithDeadline(ctx, deadline) } } // Create the err group fs.group, fs.ctx = errgroup.WithContext(ctx) // Create channels and instantiate other statistics variables fs.paths = make(chan string, DefaultBuffer) fs.results = make(chan string, DefaultBuffer) fs.nPaths = 0 fs.nResults = 0 fs.started = time.Time{} fs.duration = time.Duration(0) } Ok, so we’re doing a lot of work here, but things get paid off in the Walk function where we keep track of the number of paths we’ve seen at a root directory, passing them off to a WalkFunc using a variety of Go routines:\nfunc (fs *FSWalker) Walk(path string, walkFn WalkFunc) error { // Compute the duration of the walk fs.started = time.Now() defer func() { fs.duration = time.Since(fs.started) }() // Set the root path for the walk fs.root = path // Launch the goroutine that populates the paths fs.group.Go(func() error { // Ensure that the channel is closed when all paths loaded defer close(fs.paths) // Apply the path filter to the filepath.Walk function return filepath.Walk(fs.root, fs.filterPaths) }) // Create the worker function and allocate pool worker := fs.worker(walkFn) for w := 0; w \u003c fs.Workers; w++ { fs.group.Go(worker) } // Wait for the workers to complete, then close the results channel go func() { fs.group.Wait() close(fs.results) }() // Start gathering the results for _ = range fs.results { fs.nResults++ } return fs.group.Wait() } So this is a lot of code, let’s step through it. The first thing we do is set the started time to now, and defer a function to compute the duration as the difference between the time at the end of the function and the start function. We also set the root value. We then launch a go routine in the ErrGroup by using fs.group.Go(func) — this function must have the signature func() error, so we use an anonymous function to kick off the filepath.Walk, which starts walking the directory structure, adding paths that match the filter criteria to a buffered channel called fs.paths, more on this later. This channel must be closed on complete so that our worker go routines complete, more on that later.\nNext we create a worker function using our worker method and walk function. The workers read paths off the fs.paths channel, and apply the walkFn to each path individually. Note that we use a pool-like structure here, limiting the number of workers to 5000 — this is so we don’t get a “too many files open” error when we exhaust the number of file descriptors since Go has unlimited go routines. The worker definitions is here:\nfunc (fs *FSWalker) worker(walkFn WalkFunc) func() error { return func() error { // Apply the function all paths in the channel for path := range fs.paths { // avoid race condition p := path // apply the walk function to the path and return errors r, err := walkFn(p) if err != nil { return err } // store the result and check the context if r != \"\" { select { case fs.results \u003c- r: case \u003c-fs.ctx.Done(): return fs.ctx.Err() } } } return nil } } As you can see, the worker function just creates a closure with the signature of our ErrGroup function, so that we can pass it to the wait group. All the worker function does is range over the paths channel, applying the path to the walkFn.\nFinally, we kick off another go routine that waits until all the workers have stopped, and when it does, we close our results channel. We do this so that we can start gathering results, immediately; we don’t have to wait. We can do this by simply ranging over the results channel and adding the number of results. A final wait at the end means that we can wait for all go routines to complete.\nLastly the filter function. We want to ignore files and directories that are hidden, e.g. start with a “.” or a “~” on Unix systems. We also want to be able to pass a glob like matcher, e.g. \"*.txt\" to only match text files. The filter function is here:\n// Internal filter paths function that is passed to filepath.Walk func (fs *FSWalker) filterPaths(path string, info os.FileInfo, err error) error { // Propagate any errors if err != nil { return err } // Check to ensure that no mode bits are set if !info.Mode().IsRegular() { return nil } // Get the name of the file without the complete path name := info.Name() // Skip hidden files or directories if required. if fs.SkipHidden { if strings.HasPrefix(name, \".\") || strings.HasPrefix(name, \"~\") { return nil } } // Skip directories if required if fs.SkipDirs { if info.IsDir() { return nil } } // Check to see if the pattern matches the file match, err := filepath.Match(fs.Match, name) if err != nil { return err } else if !match { return nil } // Increment the total number of paths we've seen. atomic.AddUint64(\u0026fs.nPaths, 1) select { case fs.paths \u003c- path: case \u003c-fs.ctx.Done(): return fs.ctx.Err() } return nil } And that’s it, with this simple framework, you can apply an arbitrary walkFn to all paths in a directory, matching a specific criteria. The big win here is to manage all of the go routines using the ErrGroup and a context.Context object.\nThe following post: Run strikingly fast parallel file searches in Go with sync.ErrGroup by Brian Ketelsen was the primary inspiration for the use of sync.ErrGroup.\n","wordCount":"1206","inLanguage":"en","datePublished":"2017-08-18T15:33:35Z","dateModified":"2017-08-18T15:33:35Z","author":{"@type":"Person","name":"Benjamin Bengfort"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://bbengfort.github.io/2017/08/rapid-fs-walk/"},"publisher":{"@type":"Organization","name":"Libelli","logo":{"@type":"ImageObject","url":"https://bbengfort.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bbengfort.github.io accesskey=h title="Libelli (Alt + H)"><img src=https://bbengfort.github.io/icon.png alt aria-label=logo height=35>Libelli</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://bbengfort.github.io/archive/ title=archive><span>archive</span></a></li><li><a href=https://bbengfort.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://bbengfort.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://bbengfort.github.io/about/ title=about><span>about</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://bbengfort.github.io>Home</a>&nbsp;»&nbsp;<a href=https://bbengfort.github.io/posts/>Posts</a></div><h1 class=post-title>Rapid FS Walks with ErrGroup</h1><div class=post-meta><span title='2017-08-18 15:33:35 +0000 UTC'>August 18, 2017</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1206 words&nbsp;·&nbsp;Benjamin Bengfort&nbsp;|&nbsp;<a href=https://github.com/bbengfort/bbengfort.github.io/tree/main/content/posts/2017-08-18-rapid-fs-walk.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>I&rsquo;ve been looking for a way to quickly scan a file system and gather information about the files in directories contained within. I had been doing this with multiprocessing in Python, but figured Go could speed up my performance by a lot. What I discovered when I went down this path was the <a href=https://godoc.org/golang.org/x/sync/errgroup><code>sync.ErrGroup</code></a>, an extension of the <code>sync.WaitGroup</code> that helps manage the complexity of multiple go routines but also includes error handling!</p><p>The end result of this exploration was a utility called <a href=https://github.com/bbengfort/urfs>urfs</a> — which you can install on your system to take a uniform random sample of files in a directory or to compute the number of files and bytes per directory. This utility is also extensible to a large number of functionality that requires rapid walking of a file system like search or other utilities.</p><p>This post is therefore a bit of a walkthrough on using <code>sync.ErrGroup</code> for scanning a file system and applying arbitrary functions. First a couple of types:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>WalkFunc</span> <span class=kd>func</span><span class=p>(</span><span class=nx>path</span> <span class=kt>string</span><span class=p>)</span> <span class=p>(</span><span class=kt>string</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>FSWalker</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>Workers</span>    <span class=kt>int</span>             
</span></span><span class=line><span class=cl>	<span class=nx>SkipHidden</span> <span class=kt>bool</span>            
</span></span><span class=line><span class=cl>	<span class=nx>SkipDirs</span>   <span class=kt>bool</span>            
</span></span><span class=line><span class=cl>	<span class=nx>Match</span>      <span class=kt>string</span>          
</span></span><span class=line><span class=cl>	<span class=nx>root</span>       <span class=kt>string</span>          
</span></span><span class=line><span class=cl>	<span class=nx>paths</span>      <span class=kd>chan</span> <span class=kt>string</span>     
</span></span><span class=line><span class=cl>	<span class=nx>nPaths</span>     <span class=kt>uint64</span>          
</span></span><span class=line><span class=cl>	<span class=nx>results</span>    <span class=kd>chan</span> <span class=kt>string</span>     
</span></span><span class=line><span class=cl>	<span class=nx>nResults</span>   <span class=kt>uint64</span>        
</span></span><span class=line><span class=cl>	<span class=nx>group</span>      <span class=o>*</span><span class=nx>errgroup</span><span class=p>.</span><span class=nx>Group</span>
</span></span><span class=line><span class=cl>	<span class=nx>ctx</span>        <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span>
</span></span><span class=line><span class=cl>	<span class=nx>started</span>    <span class=nx>time</span><span class=p>.</span><span class=nx>Time</span>       
</span></span><span class=line><span class=cl>	<span class=nx>duration</span>   <span class=nx>time</span><span class=p>.</span><span class=nx>Duration</span>   
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The first type is a generic function that can be passed to the <code>Walk</code> method of the <code>FSWalker</code>. The <code>FSWalker</code> maintains state with a variety of channels, and of course the <code>errgroup.Group</code> object. The SkipHidden, SkipDirs, and Match properties allow us to filter path types being passed to Walk.</p><p>To initialize <code>FSWalker</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>fs</span> <span class=o>*</span><span class=nx>FSWalker</span><span class=p>)</span> <span class=nf>Init</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// Set up FSWalker defaults
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>fs</span><span class=p>.</span><span class=nx>Workers</span> <span class=p>=</span> <span class=nx>DefaultWorkers</span>
</span></span><span class=line><span class=cl>	<span class=nx>fs</span><span class=p>.</span><span class=nx>SkipHidden</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>	<span class=nx>fs</span><span class=p>.</span><span class=nx>SkipDirs</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>	<span class=nx>fs</span><span class=p>.</span><span class=nx>Match</span> <span class=p>=</span> <span class=s>&#34;*&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Create the context for the errgroup
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>ctx</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Create a new context
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>ctx</span> <span class=p>=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>Background</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=nx>deadline</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>fs</span><span class=p>.</span><span class=nx>ctx</span><span class=p>.</span><span class=nf>Deadline</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>ok</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>ctx</span><span class=p>,</span> <span class=nx>_</span> <span class=p>=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>WithDeadline</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>deadline</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Create the err group
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>fs</span><span class=p>.</span><span class=nx>group</span><span class=p>,</span> <span class=nx>fs</span><span class=p>.</span><span class=nx>ctx</span> <span class=p>=</span> <span class=nx>errgroup</span><span class=p>.</span><span class=nf>WithContext</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Create channels and instantiate other statistics variables
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>fs</span><span class=p>.</span><span class=nx>paths</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>DefaultBuffer</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>fs</span><span class=p>.</span><span class=nx>results</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>DefaultBuffer</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>fs</span><span class=p>.</span><span class=nx>nPaths</span> <span class=p>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>	<span class=nx>fs</span><span class=p>.</span><span class=nx>nResults</span> <span class=p>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>	<span class=nx>fs</span><span class=p>.</span><span class=nx>started</span> <span class=p>=</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Time</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>	<span class=nx>fs</span><span class=p>.</span><span class=nx>duration</span> <span class=p>=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Duration</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Ok, so we&rsquo;re doing a lot of work here, but things get paid off in the Walk function where we keep track of the number of paths we&rsquo;ve seen at a root directory, passing them off to a <code>WalkFunc</code> using a variety of Go routines:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>fs</span> <span class=o>*</span><span class=nx>FSWalker</span><span class=p>)</span> <span class=nf>Walk</span><span class=p>(</span><span class=nx>path</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>walkFn</span> <span class=nx>WalkFunc</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// Compute the duration of the walk
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>fs</span><span class=p>.</span><span class=nx>started</span> <span class=p>=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span> <span class=nx>fs</span><span class=p>.</span><span class=nx>duration</span> <span class=p>=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Since</span><span class=p>(</span><span class=nx>fs</span><span class=p>.</span><span class=nx>started</span><span class=p>)</span> <span class=p>}()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Set the root path for the walk
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>fs</span><span class=p>.</span><span class=nx>root</span> <span class=p>=</span> <span class=nx>path</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Launch the goroutine that populates the paths
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>fs</span><span class=p>.</span><span class=nx>group</span><span class=p>.</span><span class=nf>Go</span><span class=p>(</span><span class=kd>func</span><span class=p>()</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Ensure that the channel is closed when all paths loaded
</span></span></span><span class=line><span class=cl><span class=c1></span>    	<span class=k>defer</span> <span class=nb>close</span><span class=p>(</span><span class=nx>fs</span><span class=p>.</span><span class=nx>paths</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// Apply the path filter to the filepath.Walk function
</span></span></span><span class=line><span class=cl><span class=c1></span>    	<span class=k>return</span> <span class=nx>filepath</span><span class=p>.</span><span class=nf>Walk</span><span class=p>(</span><span class=nx>fs</span><span class=p>.</span><span class=nx>root</span><span class=p>,</span> <span class=nx>fs</span><span class=p>.</span><span class=nx>filterPaths</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>})</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Create the worker function and allocate pool
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>worker</span> <span class=o>:=</span> <span class=nx>fs</span><span class=p>.</span><span class=nf>worker</span><span class=p>(</span><span class=nx>walkFn</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>w</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>w</span> <span class=p>&lt;</span> <span class=nx>fs</span><span class=p>.</span><span class=nx>Workers</span><span class=p>;</span> <span class=nx>w</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>fs</span><span class=p>.</span><span class=nx>group</span><span class=p>.</span><span class=nf>Go</span><span class=p>(</span><span class=nx>worker</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Wait for the workers to complete, then close the results channel
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>fs</span><span class=p>.</span><span class=nx>group</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=nb>close</span><span class=p>(</span><span class=nx>fs</span><span class=p>.</span><span class=nx>results</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Start gathering the results
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>for</span> <span class=nx>_</span> <span class=p>=</span> <span class=k>range</span> <span class=nx>fs</span><span class=p>.</span><span class=nx>results</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>fs</span><span class=p>.</span><span class=nx>nResults</span><span class=o>++</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>fs</span><span class=p>.</span><span class=nx>group</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>So this is a lot of code, let&rsquo;s step through it. The first thing we do is set the started time to now, and defer a function to compute the duration as the difference between the time at the end of the function and the start function. We also set the root value. We then launch a go routine in the <code>ErrGroup</code> by using <code>fs.group.Go(func)</code> — this function must have the signature <code>func() error</code>, so we use an anonymous function to kick off the <code>filepath.Walk</code>, which starts walking the directory structure, adding paths that match the filter criteria to a buffered channel called <code>fs.paths</code>, more on this later. This channel must be closed on complete so that our worker go routines complete, more on that later.</p><p>Next we create a worker function using our worker method and walk function. The workers read paths off the <code>fs.paths</code> channel, and apply the walkFn to each path individually. Note that we use a pool-like structure here, limiting the number of workers to 5000 — this is so we don&rsquo;t get a &ldquo;too many files open&rdquo; error when we exhaust the number of file descriptors since Go has unlimited go routines. The worker definitions is here:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>fs</span> <span class=o>*</span><span class=nx>FSWalker</span><span class=p>)</span> <span class=nf>worker</span><span class=p>(</span><span class=nx>walkFn</span> <span class=nx>WalkFunc</span><span class=p>)</span> <span class=kd>func</span><span class=p>()</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kd>func</span><span class=p>()</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Apply the function all paths in the channel
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>for</span> <span class=nx>path</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>fs</span><span class=p>.</span><span class=nx>paths</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=c1>// avoid race condition
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=nx>p</span> <span class=o>:=</span> <span class=nx>path</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>			<span class=c1>// apply the walk function to the path and return errors
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=nx>r</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nf>walkFn</span><span class=p>(</span><span class=nx>p</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>			<span class=c1>// store the result and check the context
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=k>if</span> <span class=nx>r</span> <span class=o>!=</span> <span class=s>&#34;&#34;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>				<span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=k>case</span> <span class=nx>fs</span><span class=p>.</span><span class=nx>results</span> <span class=o>&lt;-</span> <span class=nx>r</span><span class=p>:</span>
</span></span><span class=line><span class=cl>				<span class=k>case</span> <span class=o>&lt;-</span><span class=nx>fs</span><span class=p>.</span><span class=nx>ctx</span><span class=p>.</span><span class=nf>Done</span><span class=p>():</span>
</span></span><span class=line><span class=cl>					<span class=k>return</span> <span class=nx>fs</span><span class=p>.</span><span class=nx>ctx</span><span class=p>.</span><span class=nf>Err</span><span class=p>()</span>
</span></span><span class=line><span class=cl>				<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>As you can see, the worker function just creates a closure with the signature of our <code>ErrGroup</code> function, so that we can pass it to the wait group. All the worker function does is range over the paths channel, applying the path to the <code>walkFn</code>.</p><p>Finally, we kick off another go routine that waits until all the workers have stopped, and when it does, we close our results channel. We do this so that we can start gathering results, immediately; we don&rsquo;t have to wait. We can do this by simply ranging over the results channel and adding the number of results. A final wait at the end means that we can wait for all go routines to complete.</p><p>Lastly the filter function. We want to ignore files and directories that are hidden, e.g. start with a &ldquo;.&rdquo; or a &ldquo;~&rdquo; on Unix systems. We also want to be able to pass a glob like matcher, e.g. <code>"*.txt"</code> to only match text files. The filter function is here:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Internal filter paths function that is passed to filepath.Walk
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>fs</span> <span class=o>*</span><span class=nx>FSWalker</span><span class=p>)</span> <span class=nf>filterPaths</span><span class=p>(</span><span class=nx>path</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>info</span> <span class=nx>os</span><span class=p>.</span><span class=nx>FileInfo</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// Propagate any errors
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Check to ensure that no mode bits are set
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=p>!</span><span class=nx>info</span><span class=p>.</span><span class=nf>Mode</span><span class=p>().</span><span class=nf>IsRegular</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Get the name of the file without the complete path
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>name</span> <span class=o>:=</span> <span class=nx>info</span><span class=p>.</span><span class=nf>Name</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Skip hidden files or directories if required.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>fs</span><span class=p>.</span><span class=nx>SkipHidden</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>strings</span><span class=p>.</span><span class=nf>HasPrefix</span><span class=p>(</span><span class=nx>name</span><span class=p>,</span> <span class=s>&#34;.&#34;</span><span class=p>)</span> <span class=o>||</span> <span class=nx>strings</span><span class=p>.</span><span class=nf>HasPrefix</span><span class=p>(</span><span class=nx>name</span><span class=p>,</span> <span class=s>&#34;~&#34;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Skip directories if required
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>fs</span><span class=p>.</span><span class=nx>SkipDirs</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>info</span><span class=p>.</span><span class=nf>IsDir</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Check to see if the pattern matches the file
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>match</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>filepath</span><span class=p>.</span><span class=nf>Match</span><span class=p>(</span><span class=nx>fs</span><span class=p>.</span><span class=nx>Match</span><span class=p>,</span> <span class=nx>name</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>!</span><span class=nx>match</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Increment the total number of paths we&#39;ve seen.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>atomic</span><span class=p>.</span><span class=nf>AddUint64</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>fs</span><span class=p>.</span><span class=nx>nPaths</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=nx>fs</span><span class=p>.</span><span class=nx>paths</span> <span class=o>&lt;-</span> <span class=nx>path</span><span class=p>:</span>
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=o>&lt;-</span><span class=nx>fs</span><span class=p>.</span><span class=nx>ctx</span><span class=p>.</span><span class=nf>Done</span><span class=p>():</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>fs</span><span class=p>.</span><span class=nx>ctx</span><span class=p>.</span><span class=nf>Err</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>And that&rsquo;s it, with this simple framework, you can apply an arbitrary <code>walkFn</code> to all paths in a directory, matching a specific criteria. The big win here is to manage all of the go routines using the <code>ErrGroup</code> and a <code>context.Context</code> object.</p><p>The following post: <a href=https://www.oreilly.com/learning/run-strikingly-fast-parallel-file-searches-in-go-with-sync-errgroup>Run strikingly fast parallel file searches in Go with sync.ErrGroup</a> by <a href=https://www.oreilly.com/people/7e856-brian-ketelsen>Brian Ketelsen</a> was the primary inspiration for the use of sync.ErrGroup.</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://bbengfort.github.io/2017/08/online-distribution/><span class=title>« Prev</span><br><span>Online Distribution</span></a>
<a class=next href=https://bbengfort.github.io/2017/08/buffered-writes/><span class=title>Next »</span><br><span>Buffered Write Performance</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://bbengfort.github.io>Libelli</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>