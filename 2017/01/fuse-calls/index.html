<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>FUSE Calls on Go Writes | Libelli</title><meta name=keywords content><meta name=description content="For close-to-open consistency, we need to be able to implement a file system that can detect atomic changes to a single file. Most programming languages implement open() and close() methods for files - but what they are really modifying is the access of a handle to an open file that the operating system provides. Writes are buffered in an asynchronous fashion so that the operating system and user program don&rsquo;t have to wait for the spinning disk to figure itself out before carrying on."><meta name=author content="Benjamin Bengfort"><link rel=canonical href=https://bbengfort.github.io/2017/01/fuse-calls/><link crossorigin=anonymous href=/assets/css/stylesheet.min.2d6dbfc6e0f8a1db1c9d082a76dc11d094328cf63f247bbc2421dfaa7f2bb170.css integrity="sha256-LW2/xuD4odscnQgqdtwR0JQyjPY/JHu8JCHfqn8rsXA=" rel="preload stylesheet" as=style><link rel=preload href=/icon.png as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://bbengfort.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://bbengfort.github.io/icon.png><link rel=icon type=image/png sizes=32x32 href=https://bbengfort.github.io/icon.png><link rel=apple-touch-icon href=https://bbengfort.github.io/apple-touch-icon-precomposed.png><link rel=mask-icon href=https://bbengfort.github.io/icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.110.0"><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-8096804-11","auto"),ga("send","pageview"))</script><meta property="og:title" content="FUSE Calls on Go Writes"><meta property="og:description" content="For close-to-open consistency, we need to be able to implement a file system that can detect atomic changes to a single file. Most programming languages implement open() and close() methods for files - but what they are really modifying is the access of a handle to an open file that the operating system provides. Writes are buffered in an asynchronous fashion so that the operating system and user program don&rsquo;t have to wait for the spinning disk to figure itself out before carrying on."><meta property="og:type" content="article"><meta property="og:url" content="https://bbengfort.github.io/2017/01/fuse-calls/"><meta property="og:image" content="https://bbengfort.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-01-26T20:04:40+00:00"><meta property="article:modified_time" content="2017-01-26T20:04:40+00:00"><meta property="og:site_name" content="Libelli"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://bbengfort.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="FUSE Calls on Go Writes"><meta name=twitter:description content="For close-to-open consistency, we need to be able to implement a file system that can detect atomic changes to a single file. Most programming languages implement open() and close() methods for files - but what they are really modifying is the access of a handle to an open file that the operating system provides. Writes are buffered in an asynchronous fashion so that the operating system and user program don&rsquo;t have to wait for the spinning disk to figure itself out before carrying on."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://bbengfort.github.io/posts/"},{"@type":"ListItem","position":3,"name":"FUSE Calls on Go Writes","item":"https://bbengfort.github.io/2017/01/fuse-calls/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"FUSE Calls on Go Writes","name":"FUSE Calls on Go Writes","description":"For close-to-open consistency, we need to be able to implement a file system that can detect atomic changes to a single file. Most programming languages implement open() and close() methods for files - but what they are really modifying is the access of a handle to an open file that the operating system provides. Writes are buffered in an asynchronous fashion so that the operating system and user program don\u0026rsquo;t have to wait for the spinning disk to figure itself out before carrying on.","keywords":[],"articleBody":"For close-to-open consistency, we need to be able to implement a file system that can detect atomic changes to a single file. Most programming languages implement open() and close() methods for files - but what they are really modifying is the access of a handle to an open file that the operating system provides. Writes are buffered in an asynchronous fashion so that the operating system and user program don’t have to wait for the spinning disk to figure itself out before carrying on. Additional file calls such as sync() and flush() give the user the ability to hint to the OS about what should happen relative to the state of data and the disk, but the OS provides no guarantees that will happen.\nWe use the FUSE library provided by bazil.org/fuse to implement a file system in user space. FUSE receives kernel calls to file system methods and passes them to a server - developers can write handlers for requests and return responses. Unfortunately, while there is an Open() method that returns the handle to an open file, there is no equivalent Close() method. Instead FUSE allows external processes to make calls to Read(), Write(), Flush(), and Fsync(). This led us to the obvious question - when reading and writing files, what calls are being made to the file system?\nTo answer this question, we wrote a Go program that wrote random data to a file. There are many ways to write to a file, as explained by Go by Example. So we implemented several methods (discussed below). We then ran the data writer program into a file on an in-memory FUSE server that logged different calls. The results are shown below:\nThe bottom line is that Fsync() is on called when the user program calls it - essential for Vim and Emacs, but a hint only. Flush() is always called at close, and Write() is called many times from open to close. The names on the Y-axis describe the various methods of writing to a file I will discuss next.\nThe first step is to generate random data with n bytes. To do this, I chose to write random alphabetic characters to the file, along with a couple of white space characters. The Go function used to implement this is as follows:\nvar letterRunes = []rune(\"abcdefghijklmnopqrstuvwxyz\\n \") func randString(n int) string { b := make([]rune, n) // Make a rune slice of length n // For every position in b, assign a random rune for i := range b { b[i] = letterRunes[rand.Intn(len(letterRunes))] } // Convert the rune to a string and return return string(b) } The easiest method to write data to a file is to use the ioutil package - just supply a path, data, and a file mode and ioutil will do all the rest. This is the common mechanism I use for reading and writing files, so we were very interested to see how Go handled files from the file system perspective. Implementing this function is easy:\ndata := []byte(randString(1.049e+8)) err := ioutil.WriteFile(\"test.txt\", data, 0644) All we have to do is create a 100MB slice of random data and send it to test.txt - easy! Under the hood, it appears that Go is writing blocks of 1,048,576 (1MB) to the file at a time, then calling access, attrs, and flushing the data. A snippet of the log output shows the sequence of actions:\n... wrote 1048576 bytes offset by 100663296 to file 2 wrote 1048576 bytes offset by 101711872 to file 2 wrote 1048576 bytes offset by 102760448 to file 2 wrote 1048576 bytes offset by 103809024 to file 2 wrote 42400 bytes offset by 104857600 to file 2 access called on node 2 getting attrs on node 2 flush file 2 (dirty: true, contains 104900000) getting attrs on node 2 ... The ioutil package appears to be just a wrapper function around the standard mechanism of opening the file, writing, syncing, and closing the file. We call this the “dump” method since we’re just sticking the data all into disk at once. However, even though we call Write() with the complete data slice, only 1MB is passed to the FUSE Write handler at a time.\nfobj, err := os.Create(\"test.txt\") check(err) defer fobj.Close() _, err = fobj.Write([]byte(randString(1.049e+8))) check(err) fobj.Sync() Note the last call to fobj.Sync(), if we omit this call (dump no sync) then FUSE never sees an fsync event and all is well. No matter what, though, Flush is called (probably by fobj.Close()). Since Go is clearly doing some chunking and writing, my last thought was to try to do my own chunking, below Go’s 1MB chunks and see if any arbitrary fsync calls occurred as Go was managing the handle to the open file.\nfobj, err := os.Create(path) check(err) defer fobj.Close() nbytes := 1.049e+8 chunks := 524288 for i := 0; i \u003c nbytes; i += chunks { var n int if nbytes-i \u003c chunks { n = nbytes - i } else { n = chunks } _, err = fobj.Write([]byte(randString(n))) check(err) err = fobj.Sync() check(err) } However, as shown in the graph, fsync was only called if it was directly called by the user code. Note that on our file system, it took between 6 and 10 seconds to write the 100MB file to disk. There was plenty of occasion for Go’s routine functionality (garbage collection, etc.) to run during the processing of the file.\nFor more information to experiment with different calls, check out the complete write.go command on Gist.\n","wordCount":"921","inLanguage":"en","datePublished":"2017-01-26T20:04:40Z","dateModified":"2017-01-26T20:04:40Z","author":{"@type":"Person","name":"Benjamin Bengfort"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://bbengfort.github.io/2017/01/fuse-calls/"},"publisher":{"@type":"Organization","name":"Libelli","logo":{"@type":"ImageObject","url":"https://bbengfort.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://bbengfort.github.io accesskey=h title="Libelli (Alt + H)"><img src=/icon.png alt=logo aria-label=logo height=35>Libelli</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://bbengfort.github.io/archive/ title=archive><span>archive</span></a></li><li><a href=https://bbengfort.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://bbengfort.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://bbengfort.github.io/about/ title=about><span>about</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>FUSE Calls on Go Writes</h1><div class=post-meta>January 26, 2017&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Benjamin Bengfort</div></header><div class=post-content><p>For close-to-open consistency, we need to be able to implement a file system that can detect atomic changes to a single file. Most programming languages implement <code>open()</code> and <code>close()</code> methods for files - but what they are really modifying is the access of a <em>handle</em> to an open file that the operating system provides. Writes are buffered in an asynchronous fashion so that the operating system and user program don&rsquo;t have to wait for the spinning disk to figure itself out before carrying on. Additional file calls such as <code>sync()</code> and <code>flush()</code> give the user the ability to hint to the OS about what should happen relative to the state of data and the disk, but the OS provides no guarantees that will happen.</p><p>We use the FUSE library provided by <a href=https://github.com/bazil/fuse>bazil.org/fuse</a> to implement a file system in user space. FUSE receives kernel calls to file system methods and passes them to a server - developers can write handlers for requests and return responses. Unfortunately, while there is an <code>Open()</code> method that returns the handle to an open file, there is no equivalent <code>Close()</code> method. Instead FUSE allows external processes to make calls to <code>Read()</code>, <code>Write()</code>, <code>Flush()</code>, and <code>Fsync()</code>. This led us to the obvious question - when reading and writing files, what calls are being made to the file system?</p><p>To answer this question, we wrote a Go program that wrote random data to a file. There are many ways to <a href=https://gobyexample.com/writing-files>write to a file</a>, as explained by Go by Example. So we implemented several methods (discussed below). We then ran the data writer program into a file on an in-memory FUSE server that logged different calls. The results are shown below:</p><p><img loading=lazy src=/images/2017-01-26-fuse-calls.png alt="FUSE Calls"></p><p>The bottom line is that <code>Fsync()</code> is on called when the user program calls it - essential for Vim and Emacs, but a hint only. <code>Flush()</code> is always called at close, and <code>Write()</code> is called many times from open to close. The names on the Y-axis describe the various methods of writing to a file I will discuss next.</p><p>The first step is to generate random data with n bytes. To do this, I chose to write random alphabetic characters to the file, along with a couple of white space characters. The Go function used to implement this is as follows:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>letterRunes</span> = []rune(<span style=color:#e6db74>&#34;abcdefghijklmnopqrstuvwxyz\n &#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>randString</span>(<span style=color:#a6e22e>n</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>string</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>b</span> <span style=color:#f92672>:=</span> make([]<span style=color:#66d9ef>rune</span>, <span style=color:#a6e22e>n</span>) <span style=color:#75715e>// Make a rune slice of length n
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// For every position in b, assign a random rune
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>b</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>b</span>[<span style=color:#a6e22e>i</span>] = <span style=color:#a6e22e>letterRunes</span>[<span style=color:#a6e22e>rand</span>.<span style=color:#a6e22e>Intn</span>(len(<span style=color:#a6e22e>letterRunes</span>))]
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Convert the rune to a string and return
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>return</span> string(<span style=color:#a6e22e>b</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The easiest method to write data to a file is to use the <code>ioutil</code> package - just supply a path, data, and a file mode and <code>ioutil</code> will do all the rest. This is the common mechanism I use for reading and writing files, so we were very interested to see how Go handled files from the file system perspective. Implementing this function is easy:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>data</span> <span style=color:#f92672>:=</span> []byte(<span style=color:#a6e22e>randString</span>(<span style=color:#ae81ff>1.049e+8</span>))
</span></span><span style=display:flex><span><span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ioutil</span>.<span style=color:#a6e22e>WriteFile</span>(<span style=color:#e6db74>&#34;test.txt&#34;</span>, <span style=color:#a6e22e>data</span>, <span style=color:#ae81ff>0644</span>)
</span></span></code></pre></div><p>All we have to do is create a 100MB slice of random data and send it to test.txt - easy! Under the hood, it appears that Go is writing blocks of 1,048,576 (1MB) to the file at a time, then calling access, attrs, and flushing the data. A snippet of the log output shows the sequence of actions:</p><pre tabindex=0><code>...
wrote 1048576 bytes offset by 100663296 to file 2
wrote 1048576 bytes offset by 101711872 to file 2
wrote 1048576 bytes offset by 102760448 to file 2
wrote 1048576 bytes offset by 103809024 to file 2
wrote 42400 bytes offset by 104857600 to file 2
access called on node 2
getting attrs on node 2
flush file 2 (dirty: true, contains 104900000)
getting attrs on node 2
...
</code></pre><p>The <code>ioutil</code> package appears to be just a wrapper function around the standard mechanism of opening the file, writing, syncing, and closing the file. We call this the &ldquo;dump&rdquo; method since we&rsquo;re just sticking the data all into disk at once. However, even though we call <code>Write()</code> with the complete data slice, only 1MB is passed to the FUSE Write handler at a time.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>fobj</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Create</span>(<span style=color:#e6db74>&#34;test.txt&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>check</span>(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>fobj</span>.<span style=color:#a6e22e>Close</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>fobj</span>.<span style=color:#a6e22e>Write</span>([]byte(<span style=color:#a6e22e>randString</span>(<span style=color:#ae81ff>1.049e+8</span>)))
</span></span><span style=display:flex><span><span style=color:#a6e22e>check</span>(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>fobj</span>.<span style=color:#a6e22e>Sync</span>()
</span></span></code></pre></div><p>Note the last call to <code>fobj.Sync()</code>, if we omit this call (dump no sync) then FUSE never sees an fsync event and all is well. No matter what, though, Flush is called (probably by <code>fobj.Close()</code>). Since Go is clearly doing some chunking and writing, my last thought was to try to do my own chunking, below Go&rsquo;s 1MB chunks and see if any arbitrary fsync calls occurred as Go was managing the handle to the open file.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>fobj</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Create</span>(<span style=color:#a6e22e>path</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>check</span>(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>fobj</span>.<span style=color:#a6e22e>Close</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>nbytes</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>1.049e+8</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>chunks</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>524288</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>nbytes</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>chunks</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>n</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>nbytes</span><span style=color:#f92672>-</span><span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>chunks</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>n</span> = <span style=color:#a6e22e>nbytes</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>i</span>
</span></span><span style=display:flex><span>	} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>n</span> = <span style=color:#a6e22e>chunks</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>fobj</span>.<span style=color:#a6e22e>Write</span>([]byte(<span style=color:#a6e22e>randString</span>(<span style=color:#a6e22e>n</span>)))
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>check</span>(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>fobj</span>.<span style=color:#a6e22e>Sync</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>check</span>(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>However, as shown in the graph, fsync was only called if it was directly called by the user code. Note that on our file system, it took between 6 and 10 seconds to write the 100MB file to disk. There was plenty of occasion for Go&rsquo;s routine functionality (garbage collection, etc.) to run during the processing of the file.</p><p>For more information to experiment with different calls, check out the complete <a href=https://gist.github.com/bbengfort/3c0cdfc21050bc3eed06fc93b05f7cd9>write.go command</a> on Gist.</p></div><footer class=post-footer></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://bbengfort.github.io>Libelli</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById("menu");menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>