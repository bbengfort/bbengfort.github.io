<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Resolving Matplotlib Colors | Libelli</title><meta name=keywords content><meta name=description content="One of the challenges we&rsquo;ve been dealing with in the Yellowbrick library is the proper resolution of colors, a problem that seems to have parallels in matplotlib as well. The issue is that colors can be described by the user in a variety of ways, then that description has to be parsed and rendered as specific colors. To name a few color specifications that exist in matplotlib:
 None: choose a reasonable default color The name of the color, e."><meta name=author content="Benjamin Bengfort"><link rel=canonical href=https://bbengfort.github.io/2017/01/resolving-matplotlib-colors/><link crossorigin=anonymous href=/assets/css/stylesheet.min.d0c0348c2d0cff14148d0e347258519d8df2ce53ce5ac32c7bd9a549182cb8ae.css integrity="sha256-0MA0jC0M/xQUjQ40clhRnY3yzlPOWsMse9mlSRgsuK4=" rel="preload stylesheet" as=style><link rel=preload href=/icon.png as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><link rel=icon href=https://bbengfort.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://bbengfort.github.io/icon.png><link rel=icon type=image/png sizes=32x32 href=https://bbengfort.github.io/icon.png><link rel=apple-touch-icon href=https://bbengfort.github.io/apple-touch-icon-precomposed.png><link rel=mask-icon href=https://bbengfort.github.io/icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.79.0"><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-8096804-11','auto');ga('send','pageview');}</script><meta property="og:title" content="Resolving Matplotlib Colors"><meta property="og:description" content="One of the challenges we&rsquo;ve been dealing with in the Yellowbrick library is the proper resolution of colors, a problem that seems to have parallels in matplotlib as well. The issue is that colors can be described by the user in a variety of ways, then that description has to be parsed and rendered as specific colors. To name a few color specifications that exist in matplotlib:
 None: choose a reasonable default color The name of the color, e."><meta property="og:type" content="article"><meta property="og:url" content="https://bbengfort.github.io/2017/01/resolving-matplotlib-colors/"><meta property="og:image" content="https://bbengfort.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-01-17T14:52:50+00:00"><meta property="article:modified_time" content="2017-01-17T14:52:50+00:00"><meta property="og:site_name" content="Libelli"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://bbengfort.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Resolving Matplotlib Colors"><meta name=twitter:description content="One of the challenges we&rsquo;ve been dealing with in the Yellowbrick library is the proper resolution of colors, a problem that seems to have parallels in matplotlib as well. The issue is that colors can be described by the user in a variety of ways, then that description has to be parsed and rendered as specific colors. To name a few color specifications that exist in matplotlib:
 None: choose a reasonable default color The name of the color, e."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://bbengfort.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Resolving Matplotlib Colors","item":"https://bbengfort.github.io/2017/01/resolving-matplotlib-colors/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Resolving Matplotlib Colors","name":"Resolving Matplotlib Colors","description":"One of the challenges we\u0026rsquo;ve been dealing with in the Yellowbrick library is the proper resolution of colors, a problem that seems to have parallels in matplotlib as well. The issue is that colors can be described by the user in a variety of ways, then that description has to be parsed and rendered as specific colors. To name a few color specifications that exist in matplotlib:\n None: choose a reasonable default color The name of the color, e.","keywords":[],"articleBody":"One of the challenges we’ve been dealing with in the Yellowbrick library is the proper resolution of colors, a problem that seems to have parallels in matplotlib as well. The issue is that colors can be described by the user in a variety of ways, then that description has to be parsed and rendered as specific colors. To name a few color specifications that exist in matplotlib:\n None: choose a reasonable default color The name of the color, e.g. \"b\" or \"blue\" The hex code of the color e.g. \"#377eb8\" The RGB or RGBA tuples of the color, e.g. (0.0078, 0.4470, 0.6353) A greyscale intensity string, e.g. \"0.76\".  The pyplot api documentation sums it up as follows:\n In addition, you can specify colors in many weird and wonderful ways, including full names (‘green’), hex strings ('#008000'), RGB or RGBA tuples ((0,1,0,1)) or grayscale intensities as a string (‘0.8’). Of these, the string specifications can be used in place of a fmt group, but the tuple forms can be used only as kwargs.\n Things get even weirder and slightly less wonderful when you need to specify multiple colors. To name a few methods:\n A list of colors whose elements are one of the above color representations. The name of a color map object, e.g. \"viridis\" A color cycle object (e.g. a fixed length group of colors that repeats)  Matplotlib Colormap objects resolve scalar values to RGBA mappings and are typically used by name via the matplotlib.cm.get_cmap function. They come in three varieties: Sequential, Diverging, and Qualitative. Sequential and Diverging color maps are used to indicate continuous, ordered data by changing the saturation or hue in incremental steps. Qualitative colormaps are used when no ordering or relationship is required such as in categorical data values.\nTrying to generalize this across methodologies is downright difficult. So instead let’s look at a specific problem. Given a dataset, X, whose shape is (n,d) where n is the number of points and d is the number of dimensions, and a target vector, y, create a figure that shows the distribution or relationship of points defined by X, differentiated by their target y. If d is 1 then we can use a histogram, if d is 2 or 3 we can use a scatter plot, and if d = 3, then we need RadViz or Parallel Coordinates. If y is discrete, e.g. classes then we need a color map whose length is the number of classes, probably a qualitative colormap. If y is continuous, then we need to perform binning or assign values according to a sequential or diverging color map.\nSo, problem number one is detecting if y is discrete or continuous. There is no automatic way of determining this, so besides having the user directly specify the behavior, I have instead created the following rule-based functions:\ndef is_discrete(vec): \"\"\" Returns True if the given vector contains categorical values. \"\"\" # Convert the vector to an numpy array if it isn't already. vec = np.array(vec) if vec.ndim != 1: raise ValueError(\"can only handle 1-dimensional vectors\") # Check the array dtype if vec.dtype.kind in {'b', 'S', 'U'}: return True if vec.dtype.kind in {'f', 'c'}: return False # For vectors of = than 50 elements if vec.shape[0] = 50: if np.unique(vec).shape[0]  20: return True return False # For vectors of else: elems = Counter(vec) if len(elems.keys())  20 and all([c  1 for c in elems.values()]): return True return False # Raise exception if we've made it to this point. raise ValueError( \"could not determine if vector is discrete or continuous\" ) def is_continuous(vec): \"\"\" Returns True if the given vector contains continuous values. To keep things simple, this is currently implemented as not is_discrete(). \"\"\" return not is_discrete(vec) The rules for determining discrete/categorical values are as follows:\n If it is a string type - True If it’s a bool type - True If it is a floating point type - False If  50 samples then if there are 20 or fewer discrete values If  These rules are arbitrary but work on the following test cases:\ndatasets = ( np.random.normal(10, 1, 100), # Normally distributed floats np.random.randint(0, 100, 100), # Random integers np.random.uniform(0, 1, 1000), # Small uniform numbers np.random.randint(0, 1, 100), # Binary data (0 and 1) np.random.randint(1, 4, 100), # Three integer clases (1, 2, 3) np.random.choice(list('ABC'), 100), # String classes ) for d in datasets: print(is_discrete(d)) The next step is to determine how best to assign colors for continuous vs. discrete values. One typical use case is to directly assign color values using the target variable, then provide a colormap for color assignment as shown:\n# Create some data sets. X = np.random.normal(10, 1, (100, 2)) yc = np.random.normal(10, 1, 100) yd = np.random.randint(1, 4, 100) f, (ax1, ax2) = plt.subplots(1, 2, sharey=True, figsize=(9,4)) # Plot the Continuous Target ax1.scatter(X[:,0], X[:,1], c=yc, cmap='inferno') # Plot the Discrete Target ax2.scatter(X[:,0], X[:,1], c=yd, cmap='Set1') Alternatively, the colors can be directly assigned by creating a list of colors. This brings us to our larger problem - how do we create a list of colors in a meaningful way to assign our colormap appropriately? One solution is to use the matplotlib.colors.ListedColormap object which takes a list of colors and can convert a dataset to that list as follows:\n If the input data is in (0,1) - then uses a percentage to assign the color If the input data is an integer, then uses it as an index to fetch the color  This means that some work has to be done ahead of time, e.g. discretizing the values or normalizing them.\nf, (ax1, ax2) = plt.subplots(1, 2, sharey=True, figsize=(9,4)) # Plot the Continuous Target norm = col.Normalize(vmin=yc.min(), vmax=yc.max()) cmap = col.ListedColormap([ \"#ffffcc\", \"#ffeda0\", \"#fed976\", \"#feb24c\", \"#fd8d3c\", \"#fc4e2a\", \"#e31a1c\", \"#bd0026\", \"#800026\" ]) ax1.scatter(X[:,0], X[:,1], c=cmap(norm(yc))) # Plot the Discrete Target cmap = col.ListedColormap([ \"#34495e\", \"#2ecc71\", \"#e74c3c\", \"#9b59b6\", \"#f4d03f\", \"#3498db\" ]) ax2.scatter(X[:,0], X[:,1], c=cmap(yd), cmap='Set1') Note that in the above function, the indices 1-3 are used (not the 0 index) since the classes were 1-ordered.\nClearly color handling is tricky, but hopefully these notes will provide us with a reference when we need to continue to resolve these issues developing yellowbrick.\n","wordCount":"1054","inLanguage":"en","datePublished":"2017-01-17T14:52:50Z","dateModified":"2017-01-17T14:52:50Z","author":{"@type":"Person","name":"Benjamin Bengfort"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://bbengfort.github.io/2017/01/resolving-matplotlib-colors/"},"publisher":{"@type":"Organization","name":"Libelli","logo":{"@type":"ImageObject","url":"https://bbengfort.github.io/favicon.ico"}}}</script></head><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme: #1d1e20;--entry: #2e2e33;--primary: rgba(255, 255, 255, 0.84);--secondary: rgba(255, 255, 255, 0.56);--tertiary: rgba(255, 255, 255, 0.16);--content: rgba(255, 255, 255, 0.74);--hljs-bg: #2e2e33;--code-bg: #37383e;--border: #333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://bbengfort.github.io accesskey=h title="Libelli (Alt + H)"><img src=/icon.png alt=logo aria-label=logo height=35>Libelli</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://bbengfort.github.io/archive/ title=archive><span>archive</span></a></li><li><a href=https://bbengfort.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://bbengfort.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://bbengfort.github.io/about/ title=about><span>about</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Resolving Matplotlib Colors</h1><div class=post-meta>January 17, 2017&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Benjamin Bengfort</div></header><div class=post-content><p>One of the challenges we&rsquo;ve been dealing with in the Yellowbrick library is the proper resolution of colors, a problem that seems to have parallels in <code>matplotlib</code> as well. The issue is that colors can be described by the user in a variety of ways, then that description has to be parsed and rendered as specific colors. To name a few color specifications that exist in <code>matplotlib</code>:</p><ol><li>None: choose a reasonable default color</li><li>The name of the color, e.g. <code>"b"</code> or <code>"blue"</code></li><li>The hex code of the color e.g. <code>"#377eb8"</code></li><li>The RGB or RGBA tuples of the color, e.g. <code>(0.0078, 0.4470, 0.6353)</code></li><li>A greyscale intensity string, e.g. <code>"0.76"</code>.</li></ol><p>The <a href=http://matplotlib.org/api/pyplot_api.html>pyplot api documentation</a> sums it up as follows:</p><blockquote><p>In addition, you can specify colors in many weird and wonderful ways, including full names (&lsquo;green&rsquo;), hex strings ('#008000'), RGB or RGBA tuples ((0,1,0,1)) or grayscale intensities as a string (&lsquo;0.8&rsquo;). Of these, the string specifications can be used in place of a fmt group, but the tuple forms can be used only as kwargs.</p></blockquote><p>Things get even weirder and slightly less wonderful when you need to specify <em>multiple</em> colors. To name a few methods:</p><ol><li>A list of colors whose elements are one of the above color representations.</li><li>The name of a color map object, e.g. <code>"viridis"</code></li><li>A color cycle object (e.g. a fixed length group of colors that repeats)</li></ol><p>Matplotlib <code>Colormap</code> objects resolve scalar values to RGBA mappings and are typically used by name via the <code>matplotlib.cm.get_cmap</code> function. They come in three varieties: Sequential, Diverging, and Qualitative. Sequential and Diverging color maps are used to indicate continuous, ordered data by changing the saturation or hue in incremental steps. Qualitative colormaps are used when no ordering or relationship is required such as in categorical data values.</p><p>Trying to generalize this across methodologies is downright difficult. So instead let&rsquo;s look at a specific problem. Given a dataset, X, whose shape is <code>(n,d)</code> where <code>n</code> is the number of points and <code>d</code> is the number of dimensions, and a target vector, y, create a figure that shows the distribution or relationship of points defined by X, differentiated by their target y. If <code>d</code> is 1 then we can use a histogram, if <code>d</code> is 2 or 3 we can use a scatter plot, and if <code>d</code> >= 3, then we need RadViz or Parallel Coordinates. If y is discrete, e.g. classes then we need a color map whose length is the number of classes, probably a qualitative colormap. If y is continuous, then we need to perform binning or assign values according to a sequential or diverging color map.</p><p>So, problem number one is detecting if y is discrete or continuous. There is no automatic way of determining this, so besides having the user directly specify the behavior, I have instead created the following rule-based functions:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>is_discrete</span>(vec):
    <span style=color:#e6db74>&#34;&#34;&#34;
</span><span style=color:#e6db74>    Returns True if the given vector contains categorical values.
</span><span style=color:#e6db74>    &#34;&#34;&#34;</span>

    <span style=color:#75715e># Convert the vector to an numpy array if it isn&#39;t already.</span>
    vec <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>array(vec)

    <span style=color:#66d9ef>if</span> vec<span style=color:#f92672>.</span>ndim <span style=color:#f92672>!=</span> <span style=color:#ae81ff>1</span>:
        <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>ValueError</span>(<span style=color:#e6db74>&#34;can only handle 1-dimensional vectors&#34;</span>)

    <span style=color:#75715e># Check the array dtype</span>
    <span style=color:#66d9ef>if</span> vec<span style=color:#f92672>.</span>dtype<span style=color:#f92672>.</span>kind <span style=color:#f92672>in</span> {<span style=color:#e6db74>&#39;b&#39;</span>, <span style=color:#e6db74>&#39;S&#39;</span>, <span style=color:#e6db74>&#39;U&#39;</span>}:
        <span style=color:#66d9ef>return</span> True

    <span style=color:#66d9ef>if</span> vec<span style=color:#f92672>.</span>dtype<span style=color:#f92672>.</span>kind <span style=color:#f92672>in</span> {<span style=color:#e6db74>&#39;f&#39;</span>, <span style=color:#e6db74>&#39;c&#39;</span>}:
        <span style=color:#66d9ef>return</span> False

    <span style=color:#75715e># For vectors of &gt;= than 50 elements</span>
    <span style=color:#66d9ef>if</span> vec<span style=color:#f92672>.</span>shape[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>50</span>:
        <span style=color:#66d9ef>if</span> np<span style=color:#f92672>.</span>unique(vec)<span style=color:#f92672>.</span>shape[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>20</span>:
            <span style=color:#66d9ef>return</span> True
        <span style=color:#66d9ef>return</span> False

    <span style=color:#75715e># For vectors of &lt; than 50 elements</span>
    <span style=color:#66d9ef>else</span>:
        elems <span style=color:#f92672>=</span> Counter(vec)
        <span style=color:#66d9ef>if</span> len(elems<span style=color:#f92672>.</span>keys()) <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>20</span> <span style=color:#f92672>and</span> all([c <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>for</span> c <span style=color:#f92672>in</span> elems<span style=color:#f92672>.</span>values()]):
            <span style=color:#66d9ef>return</span> True
        <span style=color:#66d9ef>return</span> False

    <span style=color:#75715e># Raise exception if we&#39;ve made it to this point.</span>
    <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>ValueError</span>(
        <span style=color:#e6db74>&#34;could not determine if vector is discrete or continuous&#34;</span>
    )


<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>is_continuous</span>(vec):
    <span style=color:#e6db74>&#34;&#34;&#34;
</span><span style=color:#e6db74>    Returns True if the given vector contains continuous values. To
</span><span style=color:#e6db74>    keep things simple, this is currently implemented as not
</span><span style=color:#e6db74>    is_discrete().
</span><span style=color:#e6db74>    &#34;&#34;&#34;</span>
    <span style=color:#66d9ef>return</span> <span style=color:#f92672>not</span> is_discrete(vec)
</code></pre></div><p>The rules for determining discrete/categorical values are as follows:</p><ol><li>If it is a string type - True</li><li>If it&rsquo;s a bool type - True</li><li>If it is a floating point type - False</li><li>If > 50 samples then if there are 20 or fewer discrete values</li><li>If &lt; 50 samples, then if there are 20 or fewer discrete samples that
are represented more than once each.</li></ol><p>These rules are arbitrary but work on the following test cases:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>datasets <span style=color:#f92672>=</span> (
    np<span style=color:#f92672>.</span>random<span style=color:#f92672>.</span>normal(<span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>100</span>),   <span style=color:#75715e># Normally distributed floats</span>
    np<span style=color:#f92672>.</span>random<span style=color:#f92672>.</span>randint(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>100</span>, <span style=color:#ae81ff>100</span>), <span style=color:#75715e># Random integers</span>
    np<span style=color:#f92672>.</span>random<span style=color:#f92672>.</span>uniform(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1000</span>),  <span style=color:#75715e># Small uniform numbers</span>
    np<span style=color:#f92672>.</span>random<span style=color:#f92672>.</span>randint(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>100</span>),   <span style=color:#75715e># Binary data (0 and 1)</span>
    np<span style=color:#f92672>.</span>random<span style=color:#f92672>.</span>randint(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>100</span>),   <span style=color:#75715e># Three integer clases (1, 2, 3)</span>
    np<span style=color:#f92672>.</span>random<span style=color:#f92672>.</span>choice(list(<span style=color:#e6db74>&#39;ABC&#39;</span>), <span style=color:#ae81ff>100</span>),   <span style=color:#75715e># String classes</span>
)

<span style=color:#66d9ef>for</span> d <span style=color:#f92672>in</span> datasets:
    <span style=color:#66d9ef>print</span>(is_discrete(d))
</code></pre></div><p>The next step is to determine how best to assign colors for continuous vs. discrete values. One typical use case is to directly assign color values using the target variable, then provide a colormap for color assignment as shown:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#75715e># Create some data sets.</span>
X  <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>random<span style=color:#f92672>.</span>normal(<span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>1</span>, (<span style=color:#ae81ff>100</span>, <span style=color:#ae81ff>2</span>))
yc <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>random<span style=color:#f92672>.</span>normal(<span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>100</span>)
yd <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>random<span style=color:#f92672>.</span>randint(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>100</span>)
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>f, (ax1, ax2) <span style=color:#f92672>=</span> plt<span style=color:#f92672>.</span>subplots(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, sharey<span style=color:#f92672>=</span>True, figsize<span style=color:#f92672>=</span>(<span style=color:#ae81ff>9</span>,<span style=color:#ae81ff>4</span>))

<span style=color:#75715e># Plot the Continuous Target</span>
ax1<span style=color:#f92672>.</span>scatter(X[:,<span style=color:#ae81ff>0</span>], X[:,<span style=color:#ae81ff>1</span>], c<span style=color:#f92672>=</span>yc, cmap<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;inferno&#39;</span>)

<span style=color:#75715e># Plot the Discrete Target</span>
ax2<span style=color:#f92672>.</span>scatter(X[:,<span style=color:#ae81ff>0</span>], X[:,<span style=color:#ae81ff>1</span>], c<span style=color:#f92672>=</span>yd, cmap<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;Set1&#39;</span>)
</code></pre></div><p><img loading=lazy src=/images//2017-01-17-output_7_1.png alt="Output of Colormap Method"></p><p>Alternatively, the colors can be directly assigned by creating a list of colors. This brings us to our larger problem - how do we create a list of colors in a meaningful way to assign our colormap appropriately? One solution is to use the <code>matplotlib.colors.ListedColormap</code> object which takes a list of colors and can convert a dataset to that list as follows:</p><ol><li>If the input data is in (0,1) - then uses a percentage to assign the color</li><li>If the input data is an integer, then uses it as an index to fetch the color</li></ol><p>This means that some work has to be done ahead of time, e.g. discretizing the values or normalizing them.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>f, (ax1, ax2) <span style=color:#f92672>=</span> plt<span style=color:#f92672>.</span>subplots(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, sharey<span style=color:#f92672>=</span>True, figsize<span style=color:#f92672>=</span>(<span style=color:#ae81ff>9</span>,<span style=color:#ae81ff>4</span>))

<span style=color:#75715e># Plot the Continuous Target</span>
norm <span style=color:#f92672>=</span> col<span style=color:#f92672>.</span>Normalize(vmin<span style=color:#f92672>=</span>yc<span style=color:#f92672>.</span>min(), vmax<span style=color:#f92672>=</span>yc<span style=color:#f92672>.</span>max())
cmap <span style=color:#f92672>=</span> col<span style=color:#f92672>.</span>ListedColormap([
    <span style=color:#e6db74>&#34;#ffffcc&#34;</span>, <span style=color:#e6db74>&#34;#ffeda0&#34;</span>, <span style=color:#e6db74>&#34;#fed976&#34;</span>, <span style=color:#e6db74>&#34;#feb24c&#34;</span>, <span style=color:#e6db74>&#34;#fd8d3c&#34;</span>,
    <span style=color:#e6db74>&#34;#fc4e2a&#34;</span>, <span style=color:#e6db74>&#34;#e31a1c&#34;</span>, <span style=color:#e6db74>&#34;#bd0026&#34;</span>, <span style=color:#e6db74>&#34;#800026&#34;</span>
])
ax1<span style=color:#f92672>.</span>scatter(X[:,<span style=color:#ae81ff>0</span>], X[:,<span style=color:#ae81ff>1</span>], c<span style=color:#f92672>=</span>cmap(norm(yc)))

<span style=color:#75715e># Plot the Discrete Target</span>
cmap <span style=color:#f92672>=</span> col<span style=color:#f92672>.</span>ListedColormap([
    <span style=color:#e6db74>&#34;#34495e&#34;</span>, <span style=color:#e6db74>&#34;#2ecc71&#34;</span>, <span style=color:#e6db74>&#34;#e74c3c&#34;</span>, <span style=color:#e6db74>&#34;#9b59b6&#34;</span>, <span style=color:#e6db74>&#34;#f4d03f&#34;</span>, <span style=color:#e6db74>&#34;#3498db&#34;</span>
])
ax2<span style=color:#f92672>.</span>scatter(X[:,<span style=color:#ae81ff>0</span>], X[:,<span style=color:#ae81ff>1</span>], c<span style=color:#f92672>=</span>cmap(yd), cmap<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;Set1&#39;</span>)
</code></pre></div><p><img loading=lazy src=/images/2017-01-17-output_9_1.png alt="Output of ListedColormap Method"></p><p>Note that in the above function, the indices 1-3 are used (not the 0 index) since the classes were 1-ordered.</p><p>Clearly color handling is tricky, but hopefully these notes will provide us with a reference when we need to continue to resolve these issues developing yellowbrick.</p></div><footer class=post-footer></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://bbengfort.github.io>Libelli</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById('menu')
menu.scrollLeft=localStorage.getItem("menu-scroll-position");menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft);}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);if(!window.matchMedia('(prefers-reduced-motion: reduce)').matches){document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});}else{document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();}
if(id==="top"){history.replaceState(null,null," ");}else{history.pushState(null,null,`#${id}`);}});});</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script></body></html>