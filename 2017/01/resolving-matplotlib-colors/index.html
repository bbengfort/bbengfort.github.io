<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Resolving Matplotlib Colors | Libelli</title>
<meta name=keywords content><meta name=description content='One of the challenges we&rsquo;ve been dealing with in the Yellowbrick library is the proper resolution of colors, a problem that seems to have parallels in matplotlib as well. The issue is that colors can be described by the user in a variety of ways, then that description has to be parsed and rendered as specific colors. To name a few color specifications that exist in matplotlib:

None: choose a reasonable default color
The name of the color, e.g. "b" or "blue"
The hex code of the color e.g. "#377eb8"
The RGB or RGBA tuples of the color, e.g. (0.0078, 0.4470, 0.6353)
A greyscale intensity string, e.g. "0.76".

The pyplot api documentation sums it up as follows:'><meta name=author content="Benjamin Bengfort"><link rel=canonical href=https://bbengfort.github.io/2017/01/resolving-matplotlib-colors/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://bbengfort.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://bbengfort.github.io/icon.png><link rel=icon type=image/png sizes=32x32 href=https://bbengfort.github.io/icon.png><link rel=apple-touch-icon href=https://bbengfort.github.io/apple-touch-icon-precomposed.png><link rel=mask-icon href=https://bbengfort.github.io/icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://bbengfort.github.io/2017/01/resolving-matplotlib-colors/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-D3BE7EHHVP"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-D3BE7EHHVP")}</script><meta property="og:title" content="Resolving Matplotlib Colors"><meta property="og:description" content='One of the challenges we&rsquo;ve been dealing with in the Yellowbrick library is the proper resolution of colors, a problem that seems to have parallels in matplotlib as well. The issue is that colors can be described by the user in a variety of ways, then that description has to be parsed and rendered as specific colors. To name a few color specifications that exist in matplotlib:

None: choose a reasonable default color
The name of the color, e.g. "b" or "blue"
The hex code of the color e.g. "#377eb8"
The RGB or RGBA tuples of the color, e.g. (0.0078, 0.4470, 0.6353)
A greyscale intensity string, e.g. "0.76".

The pyplot api documentation sums it up as follows:'><meta property="og:type" content="article"><meta property="og:url" content="https://bbengfort.github.io/2017/01/resolving-matplotlib-colors/"><meta property="og:image" content="https://bbengfort.github.io/bear.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-01-17T14:52:50+00:00"><meta property="article:modified_time" content="2017-01-17T14:52:50+00:00"><meta property="og:site_name" content="Libelli"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://bbengfort.github.io/bear.png"><meta name=twitter:title content="Resolving Matplotlib Colors"><meta name=twitter:description content='One of the challenges we&rsquo;ve been dealing with in the Yellowbrick library is the proper resolution of colors, a problem that seems to have parallels in matplotlib as well. The issue is that colors can be described by the user in a variety of ways, then that description has to be parsed and rendered as specific colors. To name a few color specifications that exist in matplotlib:

None: choose a reasonable default color
The name of the color, e.g. "b" or "blue"
The hex code of the color e.g. "#377eb8"
The RGB or RGBA tuples of the color, e.g. (0.0078, 0.4470, 0.6353)
A greyscale intensity string, e.g. "0.76".

The pyplot api documentation sums it up as follows:'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://bbengfort.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Resolving Matplotlib Colors","item":"https://bbengfort.github.io/2017/01/resolving-matplotlib-colors/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Resolving Matplotlib Colors","name":"Resolving Matplotlib Colors","description":"One of the challenges we\u0026rsquo;ve been dealing with in the Yellowbrick library is the proper resolution of colors, a problem that seems to have parallels in matplotlib as well. The issue is that colors can be described by the user in a variety of ways, then that description has to be parsed and rendered as specific colors. To name a few color specifications that exist in matplotlib:\nNone: choose a reasonable default color The name of the color, e.g. \u0026quot;b\u0026quot; or \u0026quot;blue\u0026quot; The hex code of the color e.g. \u0026quot;#377eb8\u0026quot; The RGB or RGBA tuples of the color, e.g. (0.0078, 0.4470, 0.6353) A greyscale intensity string, e.g. \u0026quot;0.76\u0026quot;. The pyplot api documentation sums it up as follows:\n","keywords":[],"articleBody":"One of the challenges we’ve been dealing with in the Yellowbrick library is the proper resolution of colors, a problem that seems to have parallels in matplotlib as well. The issue is that colors can be described by the user in a variety of ways, then that description has to be parsed and rendered as specific colors. To name a few color specifications that exist in matplotlib:\nNone: choose a reasonable default color The name of the color, e.g. \"b\" or \"blue\" The hex code of the color e.g. \"#377eb8\" The RGB or RGBA tuples of the color, e.g. (0.0078, 0.4470, 0.6353) A greyscale intensity string, e.g. \"0.76\". The pyplot api documentation sums it up as follows:\nIn addition, you can specify colors in many weird and wonderful ways, including full names (‘green’), hex strings (’#008000’), RGB or RGBA tuples ((0,1,0,1)) or grayscale intensities as a string (‘0.8’). Of these, the string specifications can be used in place of a fmt group, but the tuple forms can be used only as kwargs.\nThings get even weirder and slightly less wonderful when you need to specify multiple colors. To name a few methods:\nA list of colors whose elements are one of the above color representations. The name of a color map object, e.g. \"viridis\" A color cycle object (e.g. a fixed length group of colors that repeats) Matplotlib Colormap objects resolve scalar values to RGBA mappings and are typically used by name via the matplotlib.cm.get_cmap function. They come in three varieties: Sequential, Diverging, and Qualitative. Sequential and Diverging color maps are used to indicate continuous, ordered data by changing the saturation or hue in incremental steps. Qualitative colormaps are used when no ordering or relationship is required such as in categorical data values.\nTrying to generalize this across methodologies is downright difficult. So instead let’s look at a specific problem. Given a dataset, X, whose shape is (n,d) where n is the number of points and d is the number of dimensions, and a target vector, y, create a figure that shows the distribution or relationship of points defined by X, differentiated by their target y. If d is 1 then we can use a histogram, if d is 2 or 3 we can use a scatter plot, and if d \u003e= 3, then we need RadViz or Parallel Coordinates. If y is discrete, e.g. classes then we need a color map whose length is the number of classes, probably a qualitative colormap. If y is continuous, then we need to perform binning or assign values according to a sequential or diverging color map.\nSo, problem number one is detecting if y is discrete or continuous. There is no automatic way of determining this, so besides having the user directly specify the behavior, I have instead created the following rule-based functions:\ndef is_discrete(vec): \"\"\" Returns True if the given vector contains categorical values. \"\"\" # Convert the vector to an numpy array if it isn't already. vec = np.array(vec) if vec.ndim != 1: raise ValueError(\"can only handle 1-dimensional vectors\") # Check the array dtype if vec.dtype.kind in {'b', 'S', 'U'}: return True if vec.dtype.kind in {'f', 'c'}: return False # For vectors of \u003e= than 50 elements if vec.shape[0] \u003e= 50: if np.unique(vec).shape[0] \u003c= 20: return True return False # For vectors of \u003c than 50 elements else: elems = Counter(vec) if len(elems.keys()) \u003c= 20 and all([c \u003e 1 for c in elems.values()]): return True return False # Raise exception if we've made it to this point. raise ValueError( \"could not determine if vector is discrete or continuous\" ) def is_continuous(vec): \"\"\" Returns True if the given vector contains continuous values. To keep things simple, this is currently implemented as not is_discrete(). \"\"\" return not is_discrete(vec) The rules for determining discrete/categorical values are as follows:\nIf it is a string type - True If it’s a bool type - True If it is a floating point type - False If \u003e 50 samples then if there are 20 or fewer discrete values If \u003c 50 samples, then if there are 20 or fewer discrete samples that are represented more than once each. These rules are arbitrary but work on the following test cases:\ndatasets = ( np.random.normal(10, 1, 100), # Normally distributed floats np.random.randint(0, 100, 100), # Random integers np.random.uniform(0, 1, 1000), # Small uniform numbers np.random.randint(0, 1, 100), # Binary data (0 and 1) np.random.randint(1, 4, 100), # Three integer clases (1, 2, 3) np.random.choice(list('ABC'), 100), # String classes ) for d in datasets: print(is_discrete(d)) The next step is to determine how best to assign colors for continuous vs. discrete values. One typical use case is to directly assign color values using the target variable, then provide a colormap for color assignment as shown:\n# Create some data sets. X = np.random.normal(10, 1, (100, 2)) yc = np.random.normal(10, 1, 100) yd = np.random.randint(1, 4, 100) f, (ax1, ax2) = plt.subplots(1, 2, sharey=True, figsize=(9,4)) # Plot the Continuous Target ax1.scatter(X[:,0], X[:,1], c=yc, cmap='inferno') # Plot the Discrete Target ax2.scatter(X[:,0], X[:,1], c=yd, cmap='Set1') Alternatively, the colors can be directly assigned by creating a list of colors. This brings us to our larger problem - how do we create a list of colors in a meaningful way to assign our colormap appropriately? One solution is to use the matplotlib.colors.ListedColormap object which takes a list of colors and can convert a dataset to that list as follows:\nIf the input data is in (0,1) - then uses a percentage to assign the color If the input data is an integer, then uses it as an index to fetch the color This means that some work has to be done ahead of time, e.g. discretizing the values or normalizing them.\nf, (ax1, ax2) = plt.subplots(1, 2, sharey=True, figsize=(9,4)) # Plot the Continuous Target norm = col.Normalize(vmin=yc.min(), vmax=yc.max()) cmap = col.ListedColormap([ \"#ffffcc\", \"#ffeda0\", \"#fed976\", \"#feb24c\", \"#fd8d3c\", \"#fc4e2a\", \"#e31a1c\", \"#bd0026\", \"#800026\" ]) ax1.scatter(X[:,0], X[:,1], c=cmap(norm(yc))) # Plot the Discrete Target cmap = col.ListedColormap([ \"#34495e\", \"#2ecc71\", \"#e74c3c\", \"#9b59b6\", \"#f4d03f\", \"#3498db\" ]) ax2.scatter(X[:,0], X[:,1], c=cmap(yd), cmap='Set1') Note that in the above function, the indices 1-3 are used (not the 0 index) since the classes were 1-ordered.\nClearly color handling is tricky, but hopefully these notes will provide us with a reference when we need to continue to resolve these issues developing yellowbrick.\n","wordCount":"1054","inLanguage":"en","image":"https://bbengfort.github.io/bear.png","datePublished":"2017-01-17T14:52:50Z","dateModified":"2017-01-17T14:52:50Z","author":{"@type":"Person","name":"Benjamin Bengfort"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://bbengfort.github.io/2017/01/resolving-matplotlib-colors/"},"publisher":{"@type":"Organization","name":"Libelli","logo":{"@type":"ImageObject","url":"https://bbengfort.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bbengfort.github.io/ accesskey=h title="Libelli (Alt + H)"><img src=https://bbengfort.github.io/icon.png alt aria-label=logo height=35>Libelli</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://bbengfort.github.io/archive/ title=archive><span>archive</span></a></li><li><a href=https://bbengfort.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://bbengfort.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://bbengfort.github.io/about/ title=about><span>about</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://bbengfort.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://bbengfort.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Resolving Matplotlib Colors</h1><div class=post-meta><span title='2017-01-17 14:52:50 +0000 UTC'>January 17, 2017</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;1054 words&nbsp;·&nbsp;Benjamin Bengfort&nbsp;|&nbsp;<a href=https://github.com/bbengfort/bbengfort.github.io/tree/main/content/posts/2017-01-17-resolving-matplotlib-colors.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>One of the challenges we&rsquo;ve been dealing with in the Yellowbrick library is the proper resolution of colors, a problem that seems to have parallels in <code>matplotlib</code> as well. The issue is that colors can be described by the user in a variety of ways, then that description has to be parsed and rendered as specific colors. To name a few color specifications that exist in <code>matplotlib</code>:</p><ol><li>None: choose a reasonable default color</li><li>The name of the color, e.g. <code>"b"</code> or <code>"blue"</code></li><li>The hex code of the color e.g. <code>"#377eb8"</code></li><li>The RGB or RGBA tuples of the color, e.g. <code>(0.0078, 0.4470, 0.6353)</code></li><li>A greyscale intensity string, e.g. <code>"0.76"</code>.</li></ol><p>The <a href=http://matplotlib.org/api/pyplot_api.html>pyplot api documentation</a> sums it up as follows:</p><blockquote><p>In addition, you can specify colors in many weird and wonderful ways, including full names (&lsquo;green&rsquo;), hex strings (&rsquo;#008000&rsquo;), RGB or RGBA tuples ((0,1,0,1)) or grayscale intensities as a string (&lsquo;0.8&rsquo;). Of these, the string specifications can be used in place of a fmt group, but the tuple forms can be used only as kwargs.</p></blockquote><p>Things get even weirder and slightly less wonderful when you need to specify <em>multiple</em> colors. To name a few methods:</p><ol><li>A list of colors whose elements are one of the above color representations.</li><li>The name of a color map object, e.g. <code>"viridis"</code></li><li>A color cycle object (e.g. a fixed length group of colors that repeats)</li></ol><p>Matplotlib <code>Colormap</code> objects resolve scalar values to RGBA mappings and are typically used by name via the <code>matplotlib.cm.get_cmap</code> function. They come in three varieties: Sequential, Diverging, and Qualitative. Sequential and Diverging color maps are used to indicate continuous, ordered data by changing the saturation or hue in incremental steps. Qualitative colormaps are used when no ordering or relationship is required such as in categorical data values.</p><p>Trying to generalize this across methodologies is downright difficult. So instead let&rsquo;s look at a specific problem. Given a dataset, X, whose shape is <code>(n,d)</code> where <code>n</code> is the number of points and <code>d</code> is the number of dimensions, and a target vector, y, create a figure that shows the distribution or relationship of points defined by X, differentiated by their target y. If <code>d</code> is 1 then we can use a histogram, if <code>d</code> is 2 or 3 we can use a scatter plot, and if <code>d</code> >= 3, then we need RadViz or Parallel Coordinates. If y is discrete, e.g. classes then we need a color map whose length is the number of classes, probably a qualitative colormap. If y is continuous, then we need to perform binning or assign values according to a sequential or diverging color map.</p><p>So, problem number one is detecting if y is discrete or continuous. There is no automatic way of determining this, so besides having the user directly specify the behavior, I have instead created the following rule-based functions:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>is_discrete</span><span class=p>(</span><span class=n>vec</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    Returns True if the given vector contains categorical values.
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># Convert the vector to an numpy array if it isn&#39;t already.</span>
</span></span><span class=line><span class=cl>    <span class=n>vec</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=n>vec</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>vec</span><span class=o>.</span><span class=n>ndim</span> <span class=o>!=</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span><span class=s2>&#34;can only handle 1-dimensional vectors&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># Check the array dtype</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>vec</span><span class=o>.</span><span class=n>dtype</span><span class=o>.</span><span class=n>kind</span> <span class=ow>in</span> <span class=p>{</span><span class=s1>&#39;b&#39;</span><span class=p>,</span> <span class=s1>&#39;S&#39;</span><span class=p>,</span> <span class=s1>&#39;U&#39;</span><span class=p>}:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>vec</span><span class=o>.</span><span class=n>dtype</span><span class=o>.</span><span class=n>kind</span> <span class=ow>in</span> <span class=p>{</span><span class=s1>&#39;f&#39;</span><span class=p>,</span> <span class=s1>&#39;c&#39;</span><span class=p>}:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># For vectors of &gt;= than 50 elements</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>vec</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>&gt;=</span> <span class=mi>50</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>np</span><span class=o>.</span><span class=n>unique</span><span class=p>(</span><span class=n>vec</span><span class=p>)</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>&lt;=</span> <span class=mi>20</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># For vectors of &lt; than 50 elements</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>elems</span> <span class=o>=</span> <span class=n>Counter</span><span class=p>(</span><span class=n>vec</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>elems</span><span class=o>.</span><span class=n>keys</span><span class=p>())</span> <span class=o>&lt;=</span> <span class=mi>20</span> <span class=ow>and</span> <span class=nb>all</span><span class=p>([</span><span class=n>c</span> <span class=o>&gt;</span> <span class=mi>1</span> <span class=k>for</span> <span class=n>c</span> <span class=ow>in</span> <span class=n>elems</span><span class=o>.</span><span class=n>values</span><span class=p>()]):</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># Raise exception if we&#39;ve made it to this point.</span>
</span></span><span class=line><span class=cl>    <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;could not determine if vector is discrete or continuous&#34;</span>
</span></span><span class=line><span class=cl>    <span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>is_continuous</span><span class=p>(</span><span class=n>vec</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    Returns True if the given vector contains continuous values. To
</span></span></span><span class=line><span class=cl><span class=s2>    keep things simple, this is currently implemented as not
</span></span></span><span class=line><span class=cl><span class=s2>    is_discrete().
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=ow>not</span> <span class=n>is_discrete</span><span class=p>(</span><span class=n>vec</span><span class=p>)</span>
</span></span></code></pre></div><p>The rules for determining discrete/categorical values are as follows:</p><ol><li>If it is a string type - True</li><li>If it&rsquo;s a bool type - True</li><li>If it is a floating point type - False</li><li>If > 50 samples then if there are 20 or fewer discrete values</li><li>If &lt; 50 samples, then if there are 20 or fewer discrete samples that
are represented more than once each.</li></ol><p>These rules are arbitrary but work on the following test cases:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>datasets</span> <span class=o>=</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>np</span><span class=o>.</span><span class=n>random</span><span class=o>.</span><span class=n>normal</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>100</span><span class=p>),</span>   <span class=c1># Normally distributed floats</span>
</span></span><span class=line><span class=cl>    <span class=n>np</span><span class=o>.</span><span class=n>random</span><span class=o>.</span><span class=n>randint</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>100</span><span class=p>,</span> <span class=mi>100</span><span class=p>),</span> <span class=c1># Random integers</span>
</span></span><span class=line><span class=cl>    <span class=n>np</span><span class=o>.</span><span class=n>random</span><span class=o>.</span><span class=n>uniform</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1000</span><span class=p>),</span>  <span class=c1># Small uniform numbers</span>
</span></span><span class=line><span class=cl>    <span class=n>np</span><span class=o>.</span><span class=n>random</span><span class=o>.</span><span class=n>randint</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>100</span><span class=p>),</span>   <span class=c1># Binary data (0 and 1)</span>
</span></span><span class=line><span class=cl>    <span class=n>np</span><span class=o>.</span><span class=n>random</span><span class=o>.</span><span class=n>randint</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>100</span><span class=p>),</span>   <span class=c1># Three integer clases (1, 2, 3)</span>
</span></span><span class=line><span class=cl>    <span class=n>np</span><span class=o>.</span><span class=n>random</span><span class=o>.</span><span class=n>choice</span><span class=p>(</span><span class=nb>list</span><span class=p>(</span><span class=s1>&#39;ABC&#39;</span><span class=p>),</span> <span class=mi>100</span><span class=p>),</span>   <span class=c1># String classes</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>d</span> <span class=ow>in</span> <span class=n>datasets</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>is_discrete</span><span class=p>(</span><span class=n>d</span><span class=p>))</span>
</span></span></code></pre></div><p>The next step is to determine how best to assign colors for continuous vs. discrete values. One typical use case is to directly assign color values using the target variable, then provide a colormap for color assignment as shown:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># Create some data sets.</span>
</span></span><span class=line><span class=cl><span class=n>X</span>  <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>random</span><span class=o>.</span><span class=n>normal</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=p>(</span><span class=mi>100</span><span class=p>,</span> <span class=mi>2</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=n>yc</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>random</span><span class=o>.</span><span class=n>normal</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>100</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>yd</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>random</span><span class=o>.</span><span class=n>randint</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>100</span><span class=p>)</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>f</span><span class=p>,</span> <span class=p>(</span><span class=n>ax1</span><span class=p>,</span> <span class=n>ax2</span><span class=p>)</span> <span class=o>=</span> <span class=n>plt</span><span class=o>.</span><span class=n>subplots</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=n>sharey</span><span class=o>=</span><span class=kc>True</span><span class=p>,</span> <span class=n>figsize</span><span class=o>=</span><span class=p>(</span><span class=mi>9</span><span class=p>,</span><span class=mi>4</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Plot the Continuous Target</span>
</span></span><span class=line><span class=cl><span class=n>ax1</span><span class=o>.</span><span class=n>scatter</span><span class=p>(</span><span class=n>X</span><span class=p>[:,</span><span class=mi>0</span><span class=p>],</span> <span class=n>X</span><span class=p>[:,</span><span class=mi>1</span><span class=p>],</span> <span class=n>c</span><span class=o>=</span><span class=n>yc</span><span class=p>,</span> <span class=n>cmap</span><span class=o>=</span><span class=s1>&#39;inferno&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Plot the Discrete Target</span>
</span></span><span class=line><span class=cl><span class=n>ax2</span><span class=o>.</span><span class=n>scatter</span><span class=p>(</span><span class=n>X</span><span class=p>[:,</span><span class=mi>0</span><span class=p>],</span> <span class=n>X</span><span class=p>[:,</span><span class=mi>1</span><span class=p>],</span> <span class=n>c</span><span class=o>=</span><span class=n>yd</span><span class=p>,</span> <span class=n>cmap</span><span class=o>=</span><span class=s1>&#39;Set1&#39;</span><span class=p>)</span>
</span></span></code></pre></div><p><img loading=lazy src=/images//2017-01-17-output_7_1.png alt="Output of Colormap Method"></p><p>Alternatively, the colors can be directly assigned by creating a list of colors. This brings us to our larger problem - how do we create a list of colors in a meaningful way to assign our colormap appropriately? One solution is to use the <code>matplotlib.colors.ListedColormap</code> object which takes a list of colors and can convert a dataset to that list as follows:</p><ol><li>If the input data is in (0,1) - then uses a percentage to assign the color</li><li>If the input data is an integer, then uses it as an index to fetch the color</li></ol><p>This means that some work has to be done ahead of time, e.g. discretizing the values or normalizing them.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>f</span><span class=p>,</span> <span class=p>(</span><span class=n>ax1</span><span class=p>,</span> <span class=n>ax2</span><span class=p>)</span> <span class=o>=</span> <span class=n>plt</span><span class=o>.</span><span class=n>subplots</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=n>sharey</span><span class=o>=</span><span class=kc>True</span><span class=p>,</span> <span class=n>figsize</span><span class=o>=</span><span class=p>(</span><span class=mi>9</span><span class=p>,</span><span class=mi>4</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Plot the Continuous Target</span>
</span></span><span class=line><span class=cl><span class=n>norm</span> <span class=o>=</span> <span class=n>col</span><span class=o>.</span><span class=n>Normalize</span><span class=p>(</span><span class=n>vmin</span><span class=o>=</span><span class=n>yc</span><span class=o>.</span><span class=n>min</span><span class=p>(),</span> <span class=n>vmax</span><span class=o>=</span><span class=n>yc</span><span class=o>.</span><span class=n>max</span><span class=p>())</span>
</span></span><span class=line><span class=cl><span class=n>cmap</span> <span class=o>=</span> <span class=n>col</span><span class=o>.</span><span class=n>ListedColormap</span><span class=p>([</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;#ffffcc&#34;</span><span class=p>,</span> <span class=s2>&#34;#ffeda0&#34;</span><span class=p>,</span> <span class=s2>&#34;#fed976&#34;</span><span class=p>,</span> <span class=s2>&#34;#feb24c&#34;</span><span class=p>,</span> <span class=s2>&#34;#fd8d3c&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;#fc4e2a&#34;</span><span class=p>,</span> <span class=s2>&#34;#e31a1c&#34;</span><span class=p>,</span> <span class=s2>&#34;#bd0026&#34;</span><span class=p>,</span> <span class=s2>&#34;#800026&#34;</span>
</span></span><span class=line><span class=cl><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=n>ax1</span><span class=o>.</span><span class=n>scatter</span><span class=p>(</span><span class=n>X</span><span class=p>[:,</span><span class=mi>0</span><span class=p>],</span> <span class=n>X</span><span class=p>[:,</span><span class=mi>1</span><span class=p>],</span> <span class=n>c</span><span class=o>=</span><span class=n>cmap</span><span class=p>(</span><span class=n>norm</span><span class=p>(</span><span class=n>yc</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Plot the Discrete Target</span>
</span></span><span class=line><span class=cl><span class=n>cmap</span> <span class=o>=</span> <span class=n>col</span><span class=o>.</span><span class=n>ListedColormap</span><span class=p>([</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;#34495e&#34;</span><span class=p>,</span> <span class=s2>&#34;#2ecc71&#34;</span><span class=p>,</span> <span class=s2>&#34;#e74c3c&#34;</span><span class=p>,</span> <span class=s2>&#34;#9b59b6&#34;</span><span class=p>,</span> <span class=s2>&#34;#f4d03f&#34;</span><span class=p>,</span> <span class=s2>&#34;#3498db&#34;</span>
</span></span><span class=line><span class=cl><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=n>ax2</span><span class=o>.</span><span class=n>scatter</span><span class=p>(</span><span class=n>X</span><span class=p>[:,</span><span class=mi>0</span><span class=p>],</span> <span class=n>X</span><span class=p>[:,</span><span class=mi>1</span><span class=p>],</span> <span class=n>c</span><span class=o>=</span><span class=n>cmap</span><span class=p>(</span><span class=n>yd</span><span class=p>),</span> <span class=n>cmap</span><span class=o>=</span><span class=s1>&#39;Set1&#39;</span><span class=p>)</span>
</span></span></code></pre></div><p><img loading=lazy src=/images/2017-01-17-output_9_1.png alt="Output of ListedColormap Method"></p><p>Note that in the above function, the indices 1-3 are used (not the 0 index) since the classes were 1-ordered.</p><p>Clearly color handling is tricky, but hopefully these notes will provide us with a reference when we need to continue to resolve these issues developing yellowbrick.</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://bbengfort.github.io/2017/01/generic-json-serialization-go/><span class=title>« Prev</span><br><span>Generic JSON Serialization with Go</span>
</a><a class=next href=https://bbengfort.github.io/2016/12/benchmarking-readlines/><span class=title>Next »</span><br><span>Benchmarking Readline Iterators</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://bbengfort.github.io/>Libelli</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>