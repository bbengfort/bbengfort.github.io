<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>snippets | Libelli</title><meta name=keywords content><meta name=description content="The development journal of @bbengfort including notes and ramblings from his various programming activities."><meta name=author content="Benjamin Bengfort"><link rel=canonical href=https://bbengfort.github.io/categories/snippets/><link crossorigin=anonymous href=/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe+FVUFzPh7U=" rel="preload stylesheet" as=style><link rel=icon href=https://bbengfort.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://bbengfort.github.io/icon.png><link rel=icon type=image/png sizes=32x32 href=https://bbengfort.github.io/icon.png><link rel=apple-touch-icon href=https://bbengfort.github.io/apple-touch-icon-precomposed.png><link rel=mask-icon href=https://bbengfort.github.io/icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://bbengfort.github.io/categories/snippets/index.xml><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-8096804-11","auto"),ga("send","pageview"))</script><meta property="og:title" content="snippets"><meta property="og:description" content="The development journal of @bbengfort including notes and ramblings from his various programming activities."><meta property="og:type" content="website"><meta property="og:url" content="https://bbengfort.github.io/categories/snippets/"><meta property="og:image" content="https://bbengfort.github.io/bear.png"><meta property="og:site_name" content="Libelli"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://bbengfort.github.io/bear.png"><meta name=twitter:title content="snippets"><meta name=twitter:description content="The development journal of @bbengfort including notes and ramblings from his various programming activities."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bbengfort.github.io accesskey=h title="Libelli (Alt + H)"><img src=https://bbengfort.github.io/icon.png alt aria-label=logo height=35>Libelli</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://bbengfort.github.io/archive/ title=archive><span>archive</span></a></li><li><a href=https://bbengfort.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://bbengfort.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://bbengfort.github.io/about/ title=about><span>about</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://bbengfort.github.io>Home</a>&nbsp;»&nbsp;<a href=https://bbengfort.github.io/categories/>Categories</a></div><h1>snippets
<a href=/categories/snippets/index.xml title=RSS aria-label=RSS><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class="post-entry tag-entry"><header class=entry-header><h2>Lock Queuing in Go</h2></header><div class=entry-content><p>In Go, you can use sync.Mutex and sync.RWMutex objects to create thread-safe data structures in memory as discussed in [“Synchronizing Structs for Safe Concurrency in Go”]({% post_url 2017-02-21-synchronizing-structs %}). When using the sync.RWMutex in Go, there are two kinds of locks: read locks and write locks. The basic difference is that many read locks can be acquired at the same time, but only one write lock can be acquired at at time....</p></div><footer class=entry-footer><span title='2017-09-08 11:31:19 +0000 UTC'>September 8, 2017</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1296 words&nbsp;·&nbsp;Benjamin Bengfort</footer><a class=entry-link aria-label="post link to Lock Queuing in Go" href=https://bbengfort.github.io/2017/09/lock-queueing/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>Online Distribution</h2></header><div class=entry-content><p>This post started out as a discussion of a struct in Go that could keep track of online statistics without keeping an array of values. It ended up being a lesson on over-engineering for concurrency.
The spec of the routine was to build a data structure that could keep track of internal statistics of values over time in a space-saving fashion. The primary interface was a method, Update(sample float64), so that a new sample could be passed to the structure, updating internal parameters....</p></div><footer class=entry-footer><span title='2017-08-28 12:49:46 +0000 UTC'>August 28, 2017</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;480 words&nbsp;·&nbsp;Benjamin Bengfort</footer><a class=entry-link aria-label="post link to Online Distribution" href=https://bbengfort.github.io/2017/08/online-distribution/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>Rapid FS Walks with ErrGroup</h2></header><div class=entry-content><p>I’ve been looking for a way to quickly scan a file system and gather information about the files in directories contained within. I had been doing this with multiprocessing in Python, but figured Go could speed up my performance by a lot. What I discovered when I went down this path was the sync.ErrGroup, an extension of the sync.WaitGroup that helps manage the complexity of multiple go routines but also includes error handling!...</p></div><footer class=entry-footer><span title='2017-08-18 15:33:35 +0000 UTC'>August 18, 2017</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1206 words&nbsp;·&nbsp;Benjamin Bengfort</footer><a class=entry-link aria-label="post link to Rapid FS Walks with ErrGroup" href=https://bbengfort.github.io/2017/08/rapid-fs-walk/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>Event Dispatcher in Go</h2></header><div class=entry-content><p>The event dispatcher pattern is extremely common in software design, particularly in languages like JavaScript that are primarily used for user interface work. The dispatcher is an object (usually a mixin to other objects) that can register callback functions for particular events. Then when a dispatch method is called with an event, the dispatcher calls each callback function in order of their registration and passes them a copy of the event....</p></div><footer class=entry-footer><span title='2017-07-21 06:28:45 +0000 UTC'>July 21, 2017</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;468 words&nbsp;·&nbsp;Benjamin Bengfort</footer><a class=entry-link aria-label="post link to Event Dispatcher in Go" href=https://bbengfort.github.io/2017/07/event-dispatcher/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>Lazy Pirate Client</h2></header><div class=entry-content><p>In the [last post]({% post_url 2017-07-13-zmq-basic %}) I discussed a simple REQ/REP pattern for ZMQ. However, by itself REQ/REP is pretty fragile. First, every REQ requires a REP and a server can only handle one request at a time. Moreover, if the server fails in the middle of a reply, then everything is hung. We need more reliable REQ/REP, which is actually the subject of an entire chapter in the ZMQ book....</p></div><footer class=entry-footer><span title='2017-07-14 10:24:15 +0000 UTC'>July 14, 2017</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;331 words&nbsp;·&nbsp;Benjamin Bengfort</footer><a class=entry-link aria-label="post link to Lazy Pirate Client" href=https://bbengfort.github.io/2017/07/lazy-pirate/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>Simple ZMQ Message Passing</h2></header><div class=entry-content><p>There are many ways to create RPCs and send messages between nodes in a distributed system. Typically when we think about messaging, we think about a transport layer (TCP, IP) and a protocol layer (HTTP) along with some message serialization. Perhaps best known are RESTful APIs which allow us to GET, POST, PUT, and DELETE JSON data to a server. Other methods include gRPC which uses HTTP and protocol buffers for interprocess communication....</p></div><footer class=entry-footer><span title='2017-07-13 11:00:27 +0000 UTC'>July 13, 2017</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;355 words&nbsp;·&nbsp;Benjamin Bengfort</footer><a class=entry-link aria-label="post link to Simple ZMQ Message Passing" href=https://bbengfort.github.io/2017/07/zmq-basic/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>PID File Management</h2></header><div class=entry-content><p>In this discussion, I want to propose some code to perform PID file management in a Go program. When a program is backgrounded or daemonized we need some way to communicate with it in order to stop it. All active processes are assigned a unique process id by the operating system and that ID can be used to send signals to the program. Therefore a PID file:
The pid files contains the process id (a number) of a given program....</p></div><footer class=entry-footer><span title='2017-07-11 09:10:44 +0000 UTC'>July 11, 2017</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;432 words&nbsp;·&nbsp;Benjamin Bengfort</footer><a class=entry-link aria-label="post link to PID File Management" href=https://bbengfort.github.io/2017/07/pid-management/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://bbengfort.github.io/categories/snippets/page/3/>«&nbsp;Prev&nbsp;</a>
<a class=next href=https://bbengfort.github.io/categories/snippets/page/5/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2023 <a href=https://bbengfort.github.io>Libelli</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>