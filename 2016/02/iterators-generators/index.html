<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Iterators and Generators | Libelli</title><meta name=keywords content><meta name=description content="This post is an attempt to explain what iterators and generators are in Python, defend the yield statement, and reveal why a library like SimPy is possible. But first some terminology (that specifically targets my friends who Java). Iteration is a syntactic construct that implements a loop over an iterable object. The for statement provides iteration, the while statement may provide iteration. An iterable object is something that implements the iteration protocol (Java folks, read interface)."><meta name=author content="Benjamin Bengfort"><link rel=canonical href=https://bbengfort.github.io/2016/02/iterators-generators/><link crossorigin=anonymous href=/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe+FVUFzPh7U=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://bbengfort.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://bbengfort.github.io/icon.png><link rel=icon type=image/png sizes=32x32 href=https://bbengfort.github.io/icon.png><link rel=apple-touch-icon href=https://bbengfort.github.io/apple-touch-icon-precomposed.png><link rel=mask-icon href=https://bbengfort.github.io/icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-D3BE7EHHVP"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-D3BE7EHHVP",{anonymize_ip:!1})}</script><meta property="og:title" content="Iterators and Generators"><meta property="og:description" content="This post is an attempt to explain what iterators and generators are in Python, defend the yield statement, and reveal why a library like SimPy is possible. But first some terminology (that specifically targets my friends who Java). Iteration is a syntactic construct that implements a loop over an iterable object. The for statement provides iteration, the while statement may provide iteration. An iterable object is something that implements the iteration protocol (Java folks, read interface)."><meta property="og:type" content="article"><meta property="og:url" content="https://bbengfort.github.io/2016/02/iterators-generators/"><meta property="og:image" content="https://bbengfort.github.io/bear.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2016-02-05T22:47:15+00:00"><meta property="article:modified_time" content="2016-02-05T22:47:15+00:00"><meta property="og:site_name" content="Libelli"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://bbengfort.github.io/bear.png"><meta name=twitter:title content="Iterators and Generators"><meta name=twitter:description content="This post is an attempt to explain what iterators and generators are in Python, defend the yield statement, and reveal why a library like SimPy is possible. But first some terminology (that specifically targets my friends who Java). Iteration is a syntactic construct that implements a loop over an iterable object. The for statement provides iteration, the while statement may provide iteration. An iterable object is something that implements the iteration protocol (Java folks, read interface)."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://bbengfort.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Iterators and Generators","item":"https://bbengfort.github.io/2016/02/iterators-generators/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Iterators and Generators","name":"Iterators and Generators","description":"This post is an attempt to explain what iterators and generators are in Python, defend the yield statement, and reveal why a library like SimPy is possible. But first some terminology (that specifically targets my friends who Java). Iteration is a syntactic construct that implements a loop over an iterable object. The for statement provides iteration, the while statement may provide iteration. An iterable object is something that implements the iteration protocol (Java folks, read interface).","keywords":[],"articleBody":"This post is an attempt to explain what iterators and generators are in Python, defend the yield statement, and reveal why a library like SimPy is possible. But first some terminology (that specifically targets my friends who Java). Iteration is a syntactic construct that implements a loop over an iterable object. The for statement provides iteration, the while statement may provide iteration. An iterable object is something that implements the iteration protocol (Java folks, read interface). A generator is a function that produces a sequence of results instead of a single value and is designed to make writing iterable objects easier.\nIterables Iterable objects are constructed by the built-in function, iter, which takes an iterable object and returns an iterator. The Python data model allows you to define custom objects that implement double underscore methods related to the built-in functions and operators. Therefore if you implement an object with an __iter__ method, your object can be passed to the iter built-in.\nThe __iter__ method must return an iterable object, which if it is the same object, can simply return self. Iterable objects must have a next method that is called on every pass of the loop. When iteration is complete, the next method should raise StopIteration. Here is an example of a Dealer iterator that shuffles a deck of cards on iter then deals out cards on each call of next, until there are no more cards left in the deck:\nThe thing to note here is that the object keeps track of its own state, through it’s own pointer value (the “shoe”). This means that the iterable can be “exhausted” without returning any more data. Try the following and see what happens:\ndealer = Dealer() for card in dealer: for card in dealer: print card Note that I also used the shorthand and didn’t call the iter function directly, but let the syntax of the for loop handle it for me. Also note that other built-in functions consume iterables like list which will take the contents of the iterable and store it in memory in a list, or enumerate which will also provide an index of each value in the iterator.\nGenerators Generators are designed to allow you to easily create iterables without having to deal with the iterator interface. Instead you can create a function that does not return but rather yield values. When the yield keyword is used inside a function, a generator is immediately returned that has a next method. Look how simple our dealer is using a generator function:\ndef dealer(): cards = [ u\"{: \u003e2}{}\".format(*card) for card in zip(FACES * len(SUITS), SUITS * len(FACES)) ] random.shuffle(cards) for card in cards: yield card The generator allows us to forget about how to implement an iterable, keep track of state, etc. which greatly simplifies the process. You can get access to the generator directly from the function:\ndealer_generator = dealer() print dealer_generator.next() Or you can simply loop over the function as we’ve been doing so far:\nfor card in dealer(): print card The yield statement is often mistaken for yielding a value instead of simply returning one. What the generator is actually doing is yielding the execution context back to the caller. Whenever the caller calls next() on the generator, the execution is returned directly to the line where the yield was executed. Consider the following example:\ndef surround(n): for idx in xrange(n): print \"above {}\".format(idx) yield idx print \"below {}\".format(idx) for idx in surround(4): print \"around {}\".format(idx) You get output that appears as follows:\nabove 0 around 0 below 0 above 1 around 1 below 1 above 2 around 2 below 2 above 3 around 3 below 3 What is happening here? On the for loop call, a generator is returned, the “above” print statement happens, then control is yielded to the executing context, which prints “around”. That block complete, the loop continues, going to the next cycle, and calls next on the generator, which returns control right after the yield, printing the “below” statement, continuing to the next “above” then yielding, so on and so forth.\nSimPy and Context Generators are incredibly handy for things like comprehensions, memory safe iteration, reading from multiple files simultaneously, and more. However, I want to talk about their ingenious use in the discrete event simulation library, SimPy.\nSimPy allows you to create processes which are essentially generators. These processes can run forever, but they must yield events that occur in the simulation. One very important event is the timeout event that allows time to pass in the simulation. So how would we implement a simple SimPy environment using generators? Consider a blinking light generator:\ndef blinker(env): while True: print 'Blink at {}!'.format(env.now) yield 5 The desired effect is that this prints “Blink” every 5 time steps in the simulation (env in this case is just a SimPy environment). The offset allows us to start blinking lights that blink at different times. Note that this while loop doesn’t terminate, so if we just hit go on this thing, even if we manage to wait 5 (however we do that) then this will go forever, how do we cancel it? Moreover, how do we cancel multiple blinking lights?\nBasically what we can do is we can simply manage the generators for our simulation and call next on them when appropriate, and if we want to terminate, then simply don’t call their next method. Here is a simple implementation:\nfrom collections import defaultdict class BlinkerEnvironment(object): def __init__(self, blinkers=4): self.now = 0 self.blinkers = defaultdict(list) for idx in xrange(blinkers): # schedule blinkers by offset self.blinkers[idx].append(blinker(self)) def run(self, until=100): while self.now \u003c until: if self.now in self.blinkers: for blinker in self.blinkers.pop(self.now): timeout = blinker.next() + self.now self.blinkers[timeout].append(blinker) self.now = min(self.blinkers.keys()) As you can see in this code, the blinkers dictionary is a list of blinkers keyed to the time value that they are supposed to be called again. The environment keeps track of the current timestamp, and initializes 4 blinkers that are offset so that the blinkers aren’t all blinking at the same time.\nThe run method is passed an until argument, which limits how long the simulation goes on. If the current timestamp is in the blinkers schedule, then we go and fetch all the generators for the now value, then call their next method. We reschedule the blinker based on the timeout number that it yields to us, then we increment now by the next scheduled blink to take place (skipping over time steps that don’t matter is what gives discrete event simulation its desired properties). And voila, we’ve implemented a simple simulation using generators!\n","wordCount":"1104","inLanguage":"en","datePublished":"2016-02-05T22:47:15Z","dateModified":"2016-02-05T22:47:15Z","author":{"@type":"Person","name":"Benjamin Bengfort"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://bbengfort.github.io/2016/02/iterators-generators/"},"publisher":{"@type":"Organization","name":"Libelli","logo":{"@type":"ImageObject","url":"https://bbengfort.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bbengfort.github.io accesskey=h title="Libelli (Alt + H)"><img src=https://bbengfort.github.io/icon.png alt aria-label=logo height=35>Libelli</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://bbengfort.github.io/archive/ title=archive><span>archive</span></a></li><li><a href=https://bbengfort.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://bbengfort.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://bbengfort.github.io/about/ title=about><span>about</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://bbengfort.github.io>Home</a>&nbsp;»&nbsp;<a href=https://bbengfort.github.io/posts/>Posts</a></div><h1 class=post-title>Iterators and Generators</h1><div class=post-meta><span title='2016-02-05 22:47:15 +0000 UTC'>February 5, 2016</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1104 words&nbsp;·&nbsp;Benjamin Bengfort&nbsp;|&nbsp;<a href=https://github.com/bbengfort/bbengfort.github.io/tree/main/content/posts/2016-02-05-iterators-generators.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>This post is an attempt to explain what iterators and generators are in Python, defend the <code>yield</code> statement, and reveal why a library like <a href=https://simpy.readthedocs.org/en/latest/>SimPy</a> is possible. But first some terminology (that specifically targets my friends who Java). <em>Iteration</em> is a syntactic construct that implements a loop over an <em>iterable</em> object. The <code>for</code> statement provides <em>iteration</em>, the <code>while</code> statement may provide iteration. An <em>iterable</em> object is something that implements the <em>iteration protocol</em> (Java folks, read interface). A <em>generator</em> is a function that produces a sequence of results instead of a single value and is designed to make writing <em>iterable</em> objects easier.</p><h2 id=iterables>Iterables<a hidden class=anchor aria-hidden=true href=#iterables>#</a></h2><p>Iterable objects are constructed by the built-in function, <code>iter</code>, which takes an iterable object and returns an iterator. The Python <a href=https://docs.python.org/2/reference/datamodel.html>data model</a> allows you to define custom objects that implement double underscore methods related to the built-in functions and operators. Therefore if you implement an object with an <code>__iter__</code> method, your object can be passed to the <code>iter</code> built-in.</p><p>The <code>__iter__</code> method must return an iterable object, which if it is the same object, can simply return <code>self</code>. Iterable objects must have a <code>next</code> method that is called on every pass of the loop. When iteration is complete, the <code>next</code> method should raise <code>StopIteration</code>. Here is an example of a Dealer iterator that shuffles a deck of cards on <code>iter</code> then deals out cards on each call of next, until there are no more cards left in the deck:</p><script type=application/javascript src=https://gist.github.com/bbengfort/b0596990db96b6a7aa82.js></script><p>The thing to note here is that the object keeps track of its own state, through it&rsquo;s own pointer value (the &ldquo;shoe&rdquo;). This means that the iterable can be &ldquo;exhausted&rdquo; without returning any more data. Try the following and see what happens:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>dealer</span> <span class=o>=</span> <span class=n>Dealer</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>card</span> <span class=ow>in</span> <span class=n>dealer</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>card</span> <span class=ow>in</span> <span class=n>dealer</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span> <span class=n>card</span>
</span></span></code></pre></div><p>Note that I also used the shorthand and didn&rsquo;t call the <code>iter</code> function directly, but let the syntax of the for loop handle it for me. Also note that other built-in functions consume iterables like <code>list</code> which will take the contents of the iterable and store it in memory in a list, or <code>enumerate</code> which will also provide an index of each value in the iterator.</p><h2 id=generators>Generators<a hidden class=anchor aria-hidden=true href=#generators>#</a></h2><p>Generators are designed to allow you to easily create iterables without having to deal with the iterator interface. Instead you can create a function that does not <code>return</code> but rather <code>yield</code> values. When the <code>yield</code> keyword is used inside a function, a generator is immediately returned that has a <code>next</code> method. Look how simple our dealer is using a generator function:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>dealer</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=n>cards</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>        <span class=sa>u</span><span class=s2>&#34;</span><span class=si>{: &gt;2}{}</span><span class=s2>&#34;</span><span class=o>.</span><span class=n>format</span><span class=p>(</span><span class=o>*</span><span class=n>card</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>card</span> <span class=ow>in</span> <span class=nb>zip</span><span class=p>(</span><span class=n>FACES</span> <span class=o>*</span> <span class=nb>len</span><span class=p>(</span><span class=n>SUITS</span><span class=p>),</span> <span class=n>SUITS</span> <span class=o>*</span> <span class=nb>len</span><span class=p>(</span><span class=n>FACES</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>random</span><span class=o>.</span><span class=n>shuffle</span><span class=p>(</span><span class=n>cards</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>card</span> <span class=ow>in</span> <span class=n>cards</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>yield</span> <span class=n>card</span>
</span></span></code></pre></div><p>The generator allows us to forget about how to implement an iterable, keep track of state, etc. which greatly simplifies the process. You can get access to the generator directly from the function:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>dealer_generator</span> <span class=o>=</span> <span class=n>dealer</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=nb>print</span> <span class=n>dealer_generator</span><span class=o>.</span><span class=n>next</span><span class=p>()</span>
</span></span></code></pre></div><p>Or you can simply loop over the function as we&rsquo;ve been doing so far:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>for</span> <span class=n>card</span> <span class=ow>in</span> <span class=n>dealer</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span> <span class=n>card</span>
</span></span></code></pre></div><p>The <code>yield</code> statement is often mistaken for yielding a value instead of simply returning one. What the generator is actually doing is yielding the execution context back to the caller. Whenever the caller calls <code>next()</code> on the generator, the execution is returned directly to the line where the yield was executed. Consider the following example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>surround</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>idx</span> <span class=ow>in</span> <span class=n>xrange</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span> <span class=s2>&#34;above </span><span class=si>{}</span><span class=s2>&#34;</span><span class=o>.</span><span class=n>format</span><span class=p>(</span><span class=n>idx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>yield</span> <span class=n>idx</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span> <span class=s2>&#34;below </span><span class=si>{}</span><span class=s2>&#34;</span><span class=o>.</span><span class=n>format</span><span class=p>(</span><span class=n>idx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>idx</span> <span class=ow>in</span> <span class=n>surround</span><span class=p>(</span><span class=mi>4</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span> <span class=s2>&#34;around </span><span class=si>{}</span><span class=s2>&#34;</span><span class=o>.</span><span class=n>format</span><span class=p>(</span><span class=n>idx</span><span class=p>)</span>
</span></span></code></pre></div><p>You get output that appears as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>above 0
</span></span><span class=line><span class=cl>around 0
</span></span><span class=line><span class=cl>below 0
</span></span><span class=line><span class=cl>above 1
</span></span><span class=line><span class=cl>around 1
</span></span><span class=line><span class=cl>below 1
</span></span><span class=line><span class=cl>above 2
</span></span><span class=line><span class=cl>around 2
</span></span><span class=line><span class=cl>below 2
</span></span><span class=line><span class=cl>above 3
</span></span><span class=line><span class=cl>around 3
</span></span><span class=line><span class=cl>below 3
</span></span></code></pre></div><p>What is happening here? On the <code>for</code> loop call, a generator is returned, the &ldquo;above&rdquo; print statement happens, then control is yielded to the executing context, which prints &ldquo;around&rdquo;. That block complete, the loop continues, going to the next cycle, and calls next on the generator, which returns control right after the yield, printing the &ldquo;below&rdquo; statement, continuing to the next &ldquo;above&rdquo; then yielding, so on and so forth.</p><h2 id=simpy-and-context>SimPy and Context<a hidden class=anchor aria-hidden=true href=#simpy-and-context>#</a></h2><p>Generators are incredibly handy for things like comprehensions, memory safe iteration, reading from multiple files simultaneously, and more. However, I want to talk about their ingenious use in the discrete event simulation library, SimPy.</p><p>SimPy allows you to create processes which are essentially generators. These processes can run forever, but they must <code>yield</code> events that occur in the simulation. One very important event is the <code>timeout</code> event that allows time to pass in the simulation. So how would we implement a simple SimPy environment using generators? Consider a blinking light generator:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>blinker</span><span class=p>(</span><span class=n>env</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=kc>True</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span> <span class=s1>&#39;Blink at </span><span class=si>{}</span><span class=s1>!&#39;</span><span class=o>.</span><span class=n>format</span><span class=p>(</span><span class=n>env</span><span class=o>.</span><span class=n>now</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>yield</span> <span class=mi>5</span>
</span></span></code></pre></div><p>The desired effect is that this prints &ldquo;Blink&rdquo; every 5 time steps in the simulation (env in this case is just a SimPy environment). The offset allows us to start blinking lights that blink at different times. Note that this <code>while</code> loop doesn&rsquo;t terminate, so if we just hit go on this thing, even if we manage to wait 5 (however we do that) then this will go forever, how do we cancel it? Moreover, how do we cancel multiple blinking lights?</p><p>Basically what we can do is we can simply manage the generators for our simulation and call <code>next</code> on them when appropriate, and if we want to terminate, then simply don&rsquo;t call their next method. Here is a <a href=https://gist.github.com/bbengfort/dc2aea53d4ca7fdef925>simple implementation</a>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>collections</span> <span class=kn>import</span> <span class=n>defaultdict</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>BlinkerEnvironment</span><span class=p>(</span><span class=nb>object</span><span class=p>):</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>blinkers</span><span class=o>=</span><span class=mi>4</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>now</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>blinkers</span> <span class=o>=</span> <span class=n>defaultdict</span><span class=p>(</span><span class=nb>list</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>idx</span> <span class=ow>in</span> <span class=n>xrange</span><span class=p>(</span><span class=n>blinkers</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=c1># schedule blinkers by offset</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>blinkers</span><span class=p>[</span><span class=n>idx</span><span class=p>]</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>blinker</span><span class=p>(</span><span class=bp>self</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>run</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>until</span><span class=o>=</span><span class=mi>100</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=bp>self</span><span class=o>.</span><span class=n>now</span> <span class=o>&lt;</span> <span class=n>until</span><span class=p>:</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>now</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>blinkers</span><span class=p>:</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=k>for</span> <span class=n>blinker</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>blinkers</span><span class=o>.</span><span class=n>pop</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>now</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                    <span class=n>timeout</span> <span class=o>=</span> <span class=n>blinker</span><span class=o>.</span><span class=n>next</span><span class=p>()</span> <span class=o>+</span> <span class=bp>self</span><span class=o>.</span><span class=n>now</span>
</span></span><span class=line><span class=cl>                    <span class=bp>self</span><span class=o>.</span><span class=n>blinkers</span><span class=p>[</span><span class=n>timeout</span><span class=p>]</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>blinker</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>now</span> <span class=o>=</span> <span class=nb>min</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>blinkers</span><span class=o>.</span><span class=n>keys</span><span class=p>())</span>
</span></span></code></pre></div><p>As you can see in this code, the blinkers dictionary is a list of blinkers keyed to the time value that they are supposed to be called again. The environment keeps track of the current timestamp, and initializes 4 blinkers that are offset so that the blinkers aren&rsquo;t all blinking at the same time.</p><p>The <code>run</code> method is passed an <code>until</code> argument, which limits how long the simulation goes on. If the current timestamp is in the blinkers schedule, then we go and fetch all the generators for the now value, then call their next method. We reschedule the blinker based on the timeout number that it yields to us, then we increment now by the next scheduled blink to take place (skipping over time steps that don&rsquo;t matter is what gives discrete event simulation its desired properties). And voila, we&rsquo;ve implemented a simple simulation using generators!</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://bbengfort.github.io/2016/02/running-on-schedule/><span class=title>« Prev</span><br><span>Running on Schedule</span></a>
<a class=next href=https://bbengfort.github.io/2016/02/intervals-with-threads/><span class=title>Next »</span><br><span>On Interval Calls with Threading</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://bbengfort.github.io>Libelli</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>