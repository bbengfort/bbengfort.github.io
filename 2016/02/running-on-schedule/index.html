<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Running on Schedule | Libelli</title><meta name=keywords content><meta name=description content="Automation with Python is a lovely thing, particularly for very repetitive or long running tasks; but unfortunately someone still has to press the button to make it go. It feels like there should be an easy way to set up a program such that it runs routinely, in the background, without much human intervention. Daemonized services are the route to go in server land; but how do you routinely schedule a process to run on your local computer, which may or may not be turned off1?"><meta name=author content="Benjamin Bengfort"><link rel=canonical href=https://bbengfort.github.io/2016/02/running-on-schedule/><link crossorigin=anonymous href=/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe+FVUFzPh7U=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://bbengfort.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://bbengfort.github.io/icon.png><link rel=icon type=image/png sizes=32x32 href=https://bbengfort.github.io/icon.png><link rel=apple-touch-icon href=https://bbengfort.github.io/apple-touch-icon-precomposed.png><link rel=mask-icon href=https://bbengfort.github.io/icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-D3BE7EHHVP"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-D3BE7EHHVP",{anonymize_ip:!1})}</script><meta property="og:title" content="Running on Schedule"><meta property="og:description" content="Automation with Python is a lovely thing, particularly for very repetitive or long running tasks; but unfortunately someone still has to press the button to make it go. It feels like there should be an easy way to set up a program such that it runs routinely, in the background, without much human intervention. Daemonized services are the route to go in server land; but how do you routinely schedule a process to run on your local computer, which may or may not be turned off1?"><meta property="og:type" content="article"><meta property="og:url" content="https://bbengfort.github.io/2016/02/running-on-schedule/"><meta property="og:image" content="https://bbengfort.github.io/bear.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2016-02-10T09:50:33+00:00"><meta property="article:modified_time" content="2016-02-10T09:50:33+00:00"><meta property="og:site_name" content="Libelli"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://bbengfort.github.io/bear.png"><meta name=twitter:title content="Running on Schedule"><meta name=twitter:description content="Automation with Python is a lovely thing, particularly for very repetitive or long running tasks; but unfortunately someone still has to press the button to make it go. It feels like there should be an easy way to set up a program such that it runs routinely, in the background, without much human intervention. Daemonized services are the route to go in server land; but how do you routinely schedule a process to run on your local computer, which may or may not be turned off1?"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://bbengfort.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Running on Schedule","item":"https://bbengfort.github.io/2016/02/running-on-schedule/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Running on Schedule","name":"Running on Schedule","description":"Automation with Python is a lovely thing, particularly for very repetitive or long running tasks; but unfortunately someone still has to press the button to make it go. It feels like there should be an easy way to set up a program such that it runs routinely, in the background, without much human intervention. Daemonized services are the route to go in server land; but how do you routinely schedule a process to run on your local computer, which may or may not be turned off1?","keywords":[],"articleBody":"Automation with Python is a lovely thing, particularly for very repetitive or long running tasks; but unfortunately someone still has to press the button to make it go. It feels like there should be an easy way to set up a program such that it runs routinely, in the background, without much human intervention. Daemonized services are the route to go in server land; but how do you routinely schedule a process to run on your local computer, which may or may not be turned off1? Moreover, long running daemon processes seem expensive when you just want a quick job to execute routinely.\nLet’s consider the following use case: you’re working on a data analysis project that requires the mashup of two different data sources. The first data source has to be ingested routinely, every hour, and the second has to be fetched sometime after, depending on the result of the first query. Obviously, you don’t want to have to go to your computer and run your service, so your choices are:\nLet the OS run your program for you (launchd or cron) Let an external daemon service run your program (celery or luigi) Create a long running program that mostly sleeps (schedule or sched) Frankly, these aren’t great choices, but they’re the best we’ve got. In this post, I will explore the first and third options in a bit more detail. The second option is the more services-oriented route that you might expect to see on servers rather than on your local machine. I will probably discuss those options in other posts, as I start to use them more frequently in my work.\nThe Infamous Cron There are actually many versions of cron, which was originally studied in the late 1970’s in parallel with research concerning discrete event simulation. The modern version that is typically used is Vixie or ISC cron, named after its original programmer, Paul Vixie who wrote it in 1987. Because of its rich history, maturity, and standard inclusion with most Linux distros, cron is the defacto tool for scheduling periodic tasks in the background.\ncron is a Linux/Unix utility which allows users to execute commands automatically at a specified time and date or periodically on a schedule. While technically cron is a daemon service that is launched when the OS boots, because it is available preinstalled on almost all Linux/Unix systems I believe it is legitimate to talk about it being a part of the operating system. However, it is important to check that the crond daemon is running on your computer, otherwise your scheduled command won’t execute.\nCron Voodoo Working with cron means editing crontab (cron configuration) files. System wide jobs can be installed by modifying /etc/crontab, however users should use the crontab tool if available to create local jobs. The crontab files can contain variables that modify how cron is used, but the most important part are the entry lines that describe when and what to execute. Consider that we have a file called ingest.py, which is installed on the path, in order to run that every five minutes, we would write an entry similar to the following:\n0-59/5 * * * * $HOME/bin/ingest.py \u003e\u003e $HOME/log/ingest.out 2\u003e\u00261 There are two parts to the voodoo of this entry, the schedule and the command. The schedule has five fields: minute, hour, day of month, month, day of week. By specifying a single number, you specify exactly when to run the job. For example to run a job on the first of April at 8:15 AM:\n15 8 1 4 * echo \"April Fools!\" The * stands for “first-last” a short cut for the maximum range. In our first example we used 0-59 to specify that we wanted it to run every minute between the 0th minute and the 59th minute. We could have replaced this with * to shorten the syntax. The / allows us to specify a step, therefore in our example */5 means run every five minutes.\nThe second part is our command. In the ingest example we execute a Python file (which should have a #!/usr/bin/env python at the top of it and have executable permissions) that is in our home directory, in the bin folder. We then append the output to a log file, and redirect the standard error pipe to standard out (so that we can have one log file). It is important to understand where your output is going in order to debug errors and capture messages that are printed to the command line!\nOS X Launchd If you’re working on OS X, the preferred method for creating periodic or timed jobs is to use launchd, though cron is technically available2. Every launchd job is specified by property list (plist) file in XML format, therefore instead of maintaining a single crontab file with all entries, managing launchd jobs is as simple as adding and removing .plist files!\nConfiguring launchd plist files is more expressive than crontab, and allows you to include a lot of information about your background process; for more information see Creating a launchd Property List File. There are four properties that must be included with each configuration: Label to identify your job, ProgramArguments used to launch your job, inetdCompatibility which is specifically for servers, and KeepAlive which specifies if your job launches on demand or must always be running. Our 5 minute ingest.py command is specified as follows:\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003c!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"\u003e ","wordCount":"2079","inLanguage":"en","datePublished":"2016-02-10T09:50:33Z","dateModified":"2016-02-10T09:50:33Z","author":{"@type":"Person","name":"Benjamin Bengfort"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://bbengfort.github.io/2016/02/running-on-schedule/"},"publisher":{"@type":"Organization","name":"Libelli","logo":{"@type":"ImageObject","url":"https://bbengfort.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bbengfort.github.io accesskey=h title="Libelli (Alt + H)"><img src=https://bbengfort.github.io/icon.png alt aria-label=logo height=35>Libelli</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://bbengfort.github.io/archive/ title=archive><span>archive</span></a></li><li><a href=https://bbengfort.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://bbengfort.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://bbengfort.github.io/about/ title=about><span>about</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://bbengfort.github.io>Home</a>&nbsp;»&nbsp;<a href=https://bbengfort.github.io/posts/>Posts</a></div><h1 class=post-title>Running on Schedule</h1><div class=post-meta><span title='2016-02-10 09:50:33 +0000 UTC'>February 10, 2016</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;2079 words&nbsp;·&nbsp;Benjamin Bengfort&nbsp;|&nbsp;<a href=https://github.com/bbengfort/bbengfort.github.io/tree/main/content/posts/2016-02-10-running-on-schedule.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>Automation with Python is a lovely thing, particularly for very repetitive or long running tasks; but unfortunately someone still has to press the button to make it go. It feels like there should be an easy way to set up a program such that it runs routinely, in the background, without much human intervention. Daemonized services are the route to go in server land; but how do you routinely schedule a process to run on your local computer, which may or may not be turned off<a href=#ros-footnote-1>1</a>? Moreover, long running daemon processes seem expensive when you just want a quick job to execute routinely.</p><p>Let&rsquo;s consider the following use case: you&rsquo;re working on a data analysis project that requires the mashup of two different data sources. The first data source has to be ingested routinely, every hour, and the second has to be fetched sometime after, depending on the result of the first query. Obviously, you don&rsquo;t want to have to go to your computer and run your service, so your choices are:</p><ul><li>Let the OS run your program for you (<a href=https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man8/launchd.8.html#//apple_ref/doc/man/8/launchd>launchd</a> or <a href=https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man8/cron.8.html#//apple_ref/doc/man/8/cron>cron</a>)</li><li>Let an external daemon service run your program (<a href=http://docs.celeryproject.org/en/latest/userguide/periodic-tasks.html>celery</a> or <a href=https://github.com/spotify/luigi>luigi</a>)</li><li>Create a long running program that mostly sleeps (<a href=https://github.com/dbader/schedule>schedule</a> or <a href=https://docs.python.org/2/library/sched.html>sched</a>)</li></ul><p>Frankly, these aren&rsquo;t great choices, but they&rsquo;re the best we&rsquo;ve got. In this post, I will explore the first and third options in a bit more detail. The second option is the more services-oriented route that you might expect to see on servers rather than on your local machine. I will probably discuss those options in other posts, as I start to use them more frequently in my work.</p><h2 id=the-infamous-cron>The Infamous Cron<a hidden class=anchor aria-hidden=true href=#the-infamous-cron>#</a></h2><p>There are actually many versions of <code>cron</code>, which was originally studied in the late 1970&rsquo;s in parallel with research concerning discrete event simulation. The modern version that is typically used is Vixie or ISC cron, named after its original programmer, Paul Vixie who wrote it in 1987. Because of its rich history, maturity, and standard inclusion with most Linux distros, <code>cron</code> is the defacto tool for scheduling periodic tasks in the background.</p><p><code>cron</code> is a Linux/Unix utility which allows users to execute commands automatically at a specified time and date or periodically on a schedule. While technically <code>cron</code> is a daemon service that is launched when the OS boots, because it is available preinstalled on almost all Linux/Unix systems I believe it is legitimate to talk about it being a part of the operating system. However, it is important to check that the <code>crond</code> daemon is running on your computer, otherwise your scheduled command won&rsquo;t execute.</p><h3 id=cron-voodoo>Cron Voodoo<a hidden class=anchor aria-hidden=true href=#cron-voodoo>#</a></h3><p>Working with <code>cron</code> means editing <code>crontab</code> (cron configuration) files. System wide jobs can be installed by modifying <code>/etc/crontab</code>, however users should use the <code>crontab</code> tool if available to create local jobs. The <code>crontab</code> files can contain variables that modify how <code>cron</code> is used, but the most important part are the entry lines that describe when and what to execute. Consider that we have a file called <code>ingest.py</code>, which is installed on the path, in order to run that every five minutes, we would write an entry similar to the following:</p><pre tabindex=0><code>0-59/5 * * * *  $HOME/bin/ingest.py &gt;&gt; $HOME/log/ingest.out 2&gt;&amp;1
</code></pre><p>There are two parts to the voodoo of this entry, the schedule and the command. The schedule has five fields: minute, hour, day of month, month, day of week. By specifying a single number, you specify exactly when to run the job. For example to run a job on the first of April at 8:15 AM:</p><pre tabindex=0><code>15 8 1 4 *  echo &#34;April Fools!&#34;
</code></pre><p>The <code>*</code> stands for “first-last” a short cut for the maximum range. In our first example we used <code>0-59</code> to specify that we wanted it to run every minute between the 0th minute and the 59th minute. We could have replaced this with <code>*</code> to shorten the syntax. The <code>/</code> allows us to specify a step, therefore in our example <code>*/5</code> means run every five minutes.</p><p>The second part is our command. In the ingest example we execute a Python file (which should have a <code>#!/usr/bin/env python</code> at the top of it and have executable permissions) that is in our home directory, in the <code>bin</code> folder. We then append the output to a log file, and redirect the standard error pipe to standard out (so that we can have one log file). It is important to understand where your output is going in order to debug errors and capture messages that are printed to the command line!</p><h3 id=os-x-launchd>OS X Launchd<a hidden class=anchor aria-hidden=true href=#os-x-launchd>#</a></h3><p>If you&rsquo;re working on OS X, the preferred method for creating periodic or timed jobs is to use <code>launchd</code>, though <code>cron</code> is technically available<a href=#ros-footnote-2>2</a>. Every <code>launchd</code> job is specified by property list (plist) file in XML format, therefore instead of maintaining a single <code>crontab</code> file with all entries, managing <code>launchd</code> jobs is as simple as adding and removing .plist files!</p><p>Configuring <code>launchd</code> plist files is more expressive than <code>crontab</code>, and allows you to include a lot of information about your background process; for more information see <a href=https://developer.apple.com/library/mac/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingLaunchdJobs.html#//apple_ref/doc/uid/TP40001762-104142>Creating a launchd Property List File</a>. There are four properties that must be included with each configuration: <code>Label</code> to identify your job, <code>ProgramArguments</code> used to launch your job, <code>inetdCompatibility</code> which is specifically for servers, and <code>KeepAlive</code> which specifies if your job launches on demand or must always be running. Our 5 minute <code>ingest.py</code> command is specified as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-xml data-lang=xml><span class=line><span class=cl><span class=cp>&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;</span>
</span></span><span class=line><span class=cl><span class=cp>&lt;!DOCTYPE plist PUBLIC &#34;-//Apple//DTD PLIST 1.0//EN&#34; &#34;http://www.apple.com/DTDs/PropertyList-1.0.dtd&#34;&gt;</span>
</span></span><span class=line><span class=cl><span class=nt>&lt;plist</span> <span class=na>version=</span><span class=s>&#34;1.0&#34;</span><span class=nt>&gt;</span>
</span></span><span class=line><span class=cl><span class=nt>&lt;dict&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nt>&lt;key&gt;</span>Label<span class=nt>&lt;/key&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nt>&lt;string&gt;</span>com.districtdatalabs.ingest<span class=nt>&lt;/string&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nt>&lt;key&gt;</span>ProgramArguments<span class=nt>&lt;/key&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nt>&lt;array&gt;</span>
</span></span><span class=line><span class=cl>        <span class=nt>&lt;string&gt;</span>$HOME/bin/ingest.py<span class=nt>&lt;/string&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nt>&lt;/array&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nt>&lt;key&gt;</span>StandardOutPath<span class=nt>&lt;/key&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nt>&lt;string&gt;</span>$HOME/log/ingest.out<span class=nt>&lt;/string&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nt>&lt;key&gt;</span>StandardErrorPath<span class=nt>&lt;/key&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nt>&lt;string&gt;</span>$HOME/log/ingest.out<span class=nt>&lt;/string&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nt>&lt;key&gt;</span>StartInterval<span class=nt>&lt;/key&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nt>&lt;integer&gt;</span>300<span class=nt>&lt;/integer&gt;</span>
</span></span><span class=line><span class=cl><span class=nt>&lt;/dict&gt;</span>
</span></span><span class=line><span class=cl><span class=nt>&lt;/plist&gt;</span>
</span></span></code></pre></div><p>Although a bit more verbose, <code>launchd</code> configuration gives a bit more flexibility and a bit more readability about what is happening. You can also specify calendar based intervals, or even modify a directory to detect if paths have been changed. After creating the plist file for your ingest command, install it to <code>/Library/LaunchAgents</code> or in the <code>LaunchAgents</code> directory of the user specific <code>Library</code> folder. If you don&rsquo;t want to specify the entire path to the executable, you can symlink ingest.py to <code>/usr/local/libexec</code> as follows:</p><pre tabindex=0><code>$ ln -s $HOME/bin/ingest.py /usr/local/libexec/ingest.py
</code></pre><blockquote><p>On OS X, the term “daemon” is used to specify system-level background processes, where the term “agent” is used to specify per-user background processes<a href=#ros-footnote-3>3</a>. Note that an agent will not run if its assigned user is not logged in. Similarly by installing a <code>launchd</code> plist to <code>/Library/LaunchDaemons</code>, the service will run at the system level.</p></blockquote><h3 id=is-the-computer-on>Is the Computer On?<a hidden class=anchor aria-hidden=true href=#is-the-computer-on>#</a></h3><p>For OS X, if your system is off or asleep, <code>cron</code> jobs will not execute, and will run when the next scheduled time occurs and the computer is turned back on. Similarly, most <code>launchd</code> jobs are skipped if the computer is off or asleep as well. However, if a <code>launchd</code> job is specified by the <code>StartCalendarInterval</code> key, and the computer is asleep when the job should have run, it will run when the computer wakes up. This doesn&rsquo;t count if the computer is off, however.</p><p>It is important to keep in mind when your computer is on and running, and how it might affect your background services. If the computer is always off or asleep at the job&rsquo;s scheduled time, then it will never run.</p><h2 id=scheduling-and-waiting>Scheduling and Waiting<a hidden class=anchor aria-hidden=true href=#scheduling-and-waiting>#</a></h2><p>While <code>cron</code> and <code>launchd</code> are great for scheduling jobs that run periodically, it does have some issues<a href=#ros-footnote-4>4</a>. For example, <code>cron</code> is a per-machine configuration, not an application configuration, which makes it difficult to scale the number of machines that are working together. Both <code>cron</code> and <code>launchd</code> are also difficult to debug and finally, bigger problems can be designed with tools like queues and workers that are easier to work with but not suitable for scheduling with <code>cron</code>.</p><p>The bottom line is that as your program gets more complex, it&rsquo;s better to turn it into a long-running service or daemon with its own built-in scheduler than to let the OS run it every once in a while. Note you&rsquo;ll still use <code>launchd</code> to ensure that the daemon is running in the background, or something like <code>upstart</code> on Linux. In this section we&rsquo;ll look at a program that creates its own delays using the standard library <code>sched</code> and third party <code>schedule</code> utilities.</p><h3 id=python-event-scheduler>Python Event Scheduler<a hidden class=anchor aria-hidden=true href=#python-event-scheduler>#</a></h3><p>The standard library <code>sched</code> module defines a <code>scheduler</code> class that implements general purpose periodic events and callbacks for <em>single process</em> Python programs. The <code>scheduler</code> requires two functions to actually handle the scheduling: a <code>timefunc</code>, which should be a callable without arguments that returns a number that represents the current time and a <code>delayfunc</code> which should accept one argument compatible with the output of the <code>timefunc</code> and should delay that many units. The simplest implementation of our ingest function is as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=ch>#!/usr/bin/env python</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>sched</span><span class=o>,</span> <span class=nn>time</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>ingest</span> <span class=kn>import</span> <span class=n>ingest</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>scheduler</span> <span class=o>=</span> <span class=n>sched</span><span class=o>.</span><span class=n>scheduler</span><span class=p>(</span><span class=n>time</span><span class=o>.</span><span class=n>time</span><span class=p>,</span> <span class=n>time</span><span class=o>.</span><span class=n>sleep</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>ingestion_runner</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    Runs ingestion every 5 minutes for an hour.
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=c1># Pass arguments to ingest function</span>
</span></span><span class=line><span class=cl>    <span class=n>doingest</span> <span class=o>=</span> <span class=k>lambda</span><span class=p>:</span> <span class=n>ingest</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># Set the scheduler to run doingest</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>interval</span> <span class=ow>in</span> <span class=n>xrange</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>60</span><span class=p>,</span> <span class=mi>5</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>scheduler</span><span class=o>.</span><span class=n>enter</span><span class=p>(</span><span class=n>interval</span><span class=o>*</span><span class=mi>60</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=n>doingest</span><span class=p>,</span> <span class=p>())</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># Run the scheduler</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span> <span class=s2>&#34;Ingestion started at </span><span class=si>{}</span><span class=s2>&#34;</span><span class=o>.</span><span class=n>format</span><span class=p>(</span><span class=n>time</span><span class=o>.</span><span class=n>time</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>scheduler</span><span class=o>.</span><span class=n>run</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span> <span class=s2>&#34;Ingestion finished at </span><span class=si>{}</span><span class=s2>&#34;</span><span class=o>.</span><span class=n>format</span><span class=p>(</span><span class=n>time</span><span class=o>.</span><span class=n>time</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=vm>__name__</span> <span class=o>==</span> <span class=s1>&#39;__main__&#39;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>ingestion_runner</span><span class=p>()</span>
</span></span></code></pre></div><p>This style of scheduler basically allows you to create a chain of events ahead of time using the <code>enter</code> method. Then when the scheduler is run, it simply calls <code>time.sleep</code> for the number of seconds before its next scheduled event, executes that event, and then sleeps until the next event. The <code>sched</code> module is really nice to create a complex sequence of events, so that you don&rsquo;t have to do the math about sleeping in between. However, once the schedule is running, it is completely blocking (because of the sleep call), and your program won&rsquo;t be able to do anything (not even catch signals like <code>KeyboardInterrupt</code>) until the next event occurs.</p><h3 id=schedule-api>Schedule API<a hidden class=anchor aria-hidden=true href=#schedule-api>#</a></h3><p>As an alternative to the standard library <code>sched</code>, the third party <code>schedule</code> library allows you to build an in-process scheduler for periodic jobs, without necessarily blocking. Schedule is designed as a lightweight API that runs a callable and pre-determined intervals, and has the most friendly syntax of any of the tools we&rsquo;ve discussed so far. To use <code>schedule</code>, install it with <code>pip</code>:</p><pre tabindex=0><code>$ pip install schedule
</code></pre><p>We can then convert our ingestion runner from above into something a lot less verbose, and which will allow us to sleep on our own terms, and exit if we want to. The <code>schedule</code> ingestion runner is as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=ch>#!/usr/bin/env python</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>sys</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>time</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>schedule</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>ingest</span> <span class=kn>import</span> <span class=n>ingest</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>functools</span> <span class=kn>import</span> <span class=n>partial</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>ingestion_runner</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    Runs the ingest function with the given arguments every 5 minutes.
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=c1># Use partial based method instead of lambda</span>
</span></span><span class=line><span class=cl>    <span class=n>doingest</span> <span class=o>=</span> <span class=n>partial</span><span class=p>(</span><span class=n>ingest</span><span class=p>,</span> <span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># Set the scheduler to do ingest.</span>
</span></span><span class=line><span class=cl>    <span class=n>schedule</span><span class=o>.</span><span class=n>every</span><span class=p>(</span><span class=mi>5</span><span class=p>)</span><span class=o>.</span><span class=n>minutes</span><span class=o>.</span><span class=n>do</span><span class=p>(</span><span class=n>doingest</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># Run the scheduler, with the ability to cancel early</span>
</span></span><span class=line><span class=cl>    <span class=n>counter</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=kc>True</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>try</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>schedule</span><span class=o>.</span><span class=n>run_pending</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=n>counter</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>            <span class=n>time</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>except</span> <span class=p>(</span><span class=ne>KeyboardInterrupt</span><span class=p>,</span> <span class=ne>SystemExit</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nb>print</span> <span class=s2>&#34;Ran ingest </span><span class=si>{}</span><span class=s2> times&#34;</span><span class=o>.</span><span class=n>format</span><span class=p>(</span><span class=n>counter</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>sys</span><span class=o>.</span><span class=n>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=vm>__name__</span> <span class=o>==</span> <span class=s1>&#39;__main__&#39;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>ingestion_runner</span><span class=p>()</span>
</span></span></code></pre></div><p>The <code>schedule</code> api allows us to only block 1 second at a time, which gives us the opportunity to check if someone is trying to exit. Moreover, we don&rsquo;t have to specify or compute exactly when to schedule our job; the <code>every</code> method just keeps the job running as long as we want!</p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>In the context of data science, we&rsquo;re used to saying that we can create automated platforms for performing ingestion, wrangling, model building, etc. However, outside the context of a web application, sometimes it is not clear how to get these tools up and running in an automated fashion. I hope this post presents a <em>simple</em> method for getting routine jobs going on your machine, and that it will enable you to ingest enough data to perform high quality analytics. At the very least, it should serve as a reference to point you towards the tools that you need to know.</p><p>This post is the first in a series where I discuss “software immortality: daemons, schedulers, and programs that live forever”. I hope to continue this discussion with task queues and workers, discuss Celery and other Python projects that let comptuers do a lot of work on your behalf.</p><h3 id=footnotes>Footnotes<a hidden class=anchor aria-hidden=true href=#footnotes>#</a></h3><p>1. Stack Overflow asks: <a href=http://stackoverflow.com/questions/373335/how-do-i-get-a-cron-like-scheduler-in-python>How do I get a Cron like scheduler in Python</a></p><p>2. Mac OS X Daemons and Services: <a href=https://developer.apple.com/library/mac/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/ScheduledJobs.html>Scheduling Timed Jobs</a>.</p><p>3. See <a href=https://developer.apple.com/library/mac/technotes/tn2083/_index.html#//apple_ref/doc/uid/DTS10003794>Daemons and Agents</a> from the Apple Developer Library for more.</p><p>4. Schedule was inspired by Adam Wiggins&rsquo; article, <a href=http://adam.herokuapp.com/past/2010/4/13/rethinking_cron/>Rethinking Cron</a>.</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://bbengfort.github.io/2016/02/observer-pattern/><span class=title>« Prev</span><br><span>Implementing the Observer Pattern with an Event System</span></a>
<a class=next href=https://bbengfort.github.io/2016/02/iterators-generators/><span class=title>Next »</span><br><span>Iterators and Generators</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://bbengfort.github.io>Libelli</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>