<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Simple SQL Query Wrapper | Libelli</title><meta name=keywords content><meta name=description content="Programming with databases is a fact of life for any seasoned programmer (read, “worth their salt”). From embedded databases like SQLite and LevelDB to server databases like PostgreSQL, data management is a fundamental part of any significant project. The first thing I should say here is skip the ORM and learn SQL. SQL is such a powerful tool to query and manage a database, and is far more performant thanks to 40 years of research and development."><meta name=author content="Benjamin Bengfort"><link rel=canonical href=https://bbengfort.github.io/2016/01/query-factory/><link crossorigin=anonymous href=/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe+FVUFzPh7U=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://bbengfort.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://bbengfort.github.io/icon.png><link rel=icon type=image/png sizes=32x32 href=https://bbengfort.github.io/icon.png><link rel=apple-touch-icon href=https://bbengfort.github.io/apple-touch-icon-precomposed.png><link rel=mask-icon href=https://bbengfort.github.io/icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-D3BE7EHHVP"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-D3BE7EHHVP",{anonymize_ip:!1})}</script><meta property="og:title" content="Simple SQL Query Wrapper"><meta property="og:description" content="Programming with databases is a fact of life for any seasoned programmer (read, “worth their salt”). From embedded databases like SQLite and LevelDB to server databases like PostgreSQL, data management is a fundamental part of any significant project. The first thing I should say here is skip the ORM and learn SQL. SQL is such a powerful tool to query and manage a database, and is far more performant thanks to 40 years of research and development."><meta property="og:type" content="article"><meta property="og:url" content="https://bbengfort.github.io/2016/01/query-factory/"><meta property="og:image" content="https://bbengfort.github.io/bear.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2016-01-18T10:52:00+00:00"><meta property="article:modified_time" content="2016-01-18T10:52:00+00:00"><meta property="og:site_name" content="Libelli"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://bbengfort.github.io/bear.png"><meta name=twitter:title content="Simple SQL Query Wrapper"><meta name=twitter:description content="Programming with databases is a fact of life for any seasoned programmer (read, “worth their salt”). From embedded databases like SQLite and LevelDB to server databases like PostgreSQL, data management is a fundamental part of any significant project. The first thing I should say here is skip the ORM and learn SQL. SQL is such a powerful tool to query and manage a database, and is far more performant thanks to 40 years of research and development."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://bbengfort.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Simple SQL Query Wrapper","item":"https://bbengfort.github.io/2016/01/query-factory/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Simple SQL Query Wrapper","name":"Simple SQL Query Wrapper","description":"Programming with databases is a fact of life for any seasoned programmer (read, “worth their salt”). From embedded databases like SQLite and LevelDB to server databases like PostgreSQL, data management is a fundamental part of any significant project. The first thing I should say here is skip the ORM and learn SQL. SQL is such a powerful tool to query and manage a database, and is far more performant thanks to 40 years of research and development.","keywords":[],"articleBody":"Programming with databases is a fact of life for any seasoned programmer (read, “worth their salt”). From embedded databases like SQLite and LevelDB to server databases like PostgreSQL, data management is a fundamental part of any significant project. The first thing I should say here is skip the ORM and learn SQL. SQL is such a powerful tool to query and manage a database, and is far more performant thanks to 40 years of research and development.\nOk, now that we’ve got that out of the way, the question becomes, how do we embed SQL into our programming language of choice? What you’ll typically see in tutorials is the direct embedding of strings into the codebase. While this works, and is nice because now your SQL is also versioned, it can also create many security related complications that I won’t go into as well as an organizational nightmare. So you’ve got to wrap your SQL statements somehow.\nUnfortunately, there is no standard answer for this because there are a lot of questions including connection management for performance; size and frequency of queries, etc. Each use case has it’s own optimization. Therefore, I’d like to look at a simple wrapper for a Query, as shown in the Gist below and discussed after the code.\nAs you can see from the example, we have a routine query where we want to get the orders between a particular time range for a customer identified by their email. Presumably this query will be executed many times in the course of our program, so the factory gives us the ability to run many different queries simultaneously.\nBasically what this method gets us is the wrapping of a parameterized query — e.g. a query that uses PEP 249 string formatting to add arguments on execution. Calls to query’s iterator initiate a connection to the database and execute the query, returning the results of fetch row. By using the factory method, this technique basically gives us the ability to execute many queries with different parameters over the course of program execution, such that each query has a separate connection, cursor, and error handling.\nThere are also two techniques involving the engine and the query that I generally use. The engine in this case connects to a particular database. For a SQLite database you have to specify a path on disk, for a PostgreSQL database a url, username, and password. My preference is to use a database url but you’ll note that the Query object is database-agnostic. Although beyond the scope of this post, a simple Engine can be created as follows:\nimport psycopg2 class PostgreSQLEngine(object): def __init__(self, database, user, password, host, port): self.params = { 'database': database, 'user': user, 'password': password, 'host': host, 'port': port, } def connect(self): return psycopg2.connect(**self.params) def query_factory(sql, **kwargs): def factory(): return Query(sql, PostgreSQLEngine(**kwargs)) return factory You could then create an engine object that reads configuration details from Confire, parses a database URL, or selects from SQLite or PostgreSQL depending on which is available.\nAlso, the Gist uses a query that is embedded as a docstring. I prefer to store my more complex SQL in .sql files and load them from disk. (Smaller queries I might have constants stored in a queries.py or similar). This changes the factory again:\ndef query_factory(path, **kwargs): engine = PostgreSQLEngine(**kwargs) with open(path, 'r') as f: sql = f.read().strip() def factory(): return Query(sql, engine) return factory Advanced implementation of this particular technique will use:\nRow format classes to return Python objects or namedtuples. Context managers to ensure the connection to the database gets closed. A connection pool as the engine to reuse connection objects. Advanced error handling for not found or parameter errors. We do this so much that we plan to create a package called ORMBad which will implement engines and a more advanced query pattern. We just have to get around to doing it!\n","wordCount":"647","inLanguage":"en","datePublished":"2016-01-18T10:52:00Z","dateModified":"2016-01-18T10:52:00Z","author":{"@type":"Person","name":"Benjamin Bengfort"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://bbengfort.github.io/2016/01/query-factory/"},"publisher":{"@type":"Organization","name":"Libelli","logo":{"@type":"ImageObject","url":"https://bbengfort.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bbengfort.github.io accesskey=h title="Libelli (Alt + H)"><img src=https://bbengfort.github.io/icon.png alt aria-label=logo height=35>Libelli</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://bbengfort.github.io/archive/ title=archive><span>archive</span></a></li><li><a href=https://bbengfort.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://bbengfort.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://bbengfort.github.io/about/ title=about><span>about</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://bbengfort.github.io>Home</a>&nbsp;»&nbsp;<a href=https://bbengfort.github.io/posts/>Posts</a></div><h1 class=post-title>Simple SQL Query Wrapper</h1><div class=post-meta><span title='2016-01-18 10:52:00 +0000 UTC'>January 18, 2016</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;647 words&nbsp;·&nbsp;Benjamin Bengfort&nbsp;|&nbsp;<a href=https://github.com/bbengfort/bbengfort.github.io/tree/main/content/posts/2016-01-18-query-factory.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>Programming with databases is a fact of life for any seasoned programmer (read, “worth their salt”). From embedded databases like SQLite and LevelDB to server databases like PostgreSQL, data management is a fundamental part of any significant project. The first thing I should say here is <em>skip the ORM and learn SQL</em>. SQL is such a powerful tool to query and manage a database, and is far more performant thanks to 40 years of research and development.</p><p>Ok, now that we&rsquo;ve got that out of the way, the question becomes, how do we embed SQL into our programming language of choice? What you&rsquo;ll typically see in tutorials is the direct embedding of strings into the codebase. While this works, and is nice because now your SQL is also versioned, it can also create many security related complications that I won&rsquo;t go into as well as an organizational nightmare. So you&rsquo;ve got to wrap your SQL statements somehow.</p><p>Unfortunately, there is no standard answer for this because there are a lot of questions including connection management for performance; size and frequency of queries, etc. Each use case has it&rsquo;s own optimization. Therefore, I&rsquo;d like to look at a simple wrapper for a Query, as shown in the Gist below and discussed after the code.</p><script type=application/javascript src=https://gist.github.com/bbengfort/db78948df3ef87091aac.js></script><p>As you can see from the example, we have a routine query where we want to get the orders between a particular time range for a customer identified by their email. Presumably this query will be executed many times in the course of our program, so the factory gives us the ability to run many different queries simultaneously.</p><p>Basically what this method gets us is the wrapping of a <em>parameterized query</em> — e.g. a query that uses <a href=https://www.python.org/dev/peps/pep-0249/>PEP 249</a> string formatting to add arguments on execution. Calls to query&rsquo;s iterator initiate a connection to the database and execute the query, returning the results of <em>fetch row</em>. By using the factory method, this technique basically gives us the ability to execute many queries with different parameters over the course of program execution, such that each query has a separate connection, cursor, and error handling.</p><p>There are also two techniques involving the <code>engine</code> and the <code>query</code> that I generally use. The <code>engine</code> in this case connects to a particular database. For a SQLite database you have to specify a path on disk, for a PostgreSQL database a url, username, and password. My preference is to use a <a href=https://pypi.python.org/pypi/dj-database-url>database url</a> but you&rsquo;ll note that the <code>Query</code> object is database-agnostic. Although beyond the scope of this post, a simple <code>Engine</code> can be created as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>psycopg2</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>PostgreSQLEngine</span><span class=p>(</span><span class=nb>object</span><span class=p>):</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>database</span><span class=p>,</span> <span class=n>user</span><span class=p>,</span> <span class=n>password</span><span class=p>,</span> <span class=n>host</span><span class=p>,</span> <span class=n>port</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>params</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=s1>&#39;database&#39;</span><span class=p>:</span> <span class=n>database</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=s1>&#39;user&#39;</span><span class=p>:</span> <span class=n>user</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=s1>&#39;password&#39;</span><span class=p>:</span> <span class=n>password</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=s1>&#39;host&#39;</span><span class=p>:</span> <span class=n>host</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=s1>&#39;port&#39;</span><span class=p>:</span> <span class=n>port</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>connect</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>psycopg2</span><span class=o>.</span><span class=n>connect</span><span class=p>(</span><span class=o>**</span><span class=bp>self</span><span class=o>.</span><span class=n>params</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>query_factory</span><span class=p>(</span><span class=n>sql</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>factory</span><span class=p>():</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>Query</span><span class=p>(</span><span class=n>sql</span><span class=p>,</span> <span class=n>PostgreSQLEngine</span><span class=p>(</span><span class=o>**</span><span class=n>kwargs</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>factory</span>
</span></span></code></pre></div><p>You could then create an engine object that reads configuration details from <a href=https://github.com/bbengfort/confire>Confire</a>, parses a database URL, or selects from SQLite or PostgreSQL depending on which is available.</p><p>Also, the Gist uses a query that is embedded as a <a href=https://www.python.org/dev/peps/pep-0257/><code>docstring</code></a>. I prefer to store my more complex SQL in <code>.sql</code> files and load them from disk. (Smaller queries I might have constants stored in a <code>queries.py</code> or similar). This changes the factory again:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>query_factory</span><span class=p>(</span><span class=n>path</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>engine</span> <span class=o>=</span> <span class=n>PostgreSQLEngine</span><span class=p>(</span><span class=o>**</span><span class=n>kwargs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>with</span> <span class=nb>open</span><span class=p>(</span><span class=n>path</span><span class=p>,</span> <span class=s1>&#39;r&#39;</span><span class=p>)</span> <span class=k>as</span> <span class=n>f</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>sql</span> <span class=o>=</span> <span class=n>f</span><span class=o>.</span><span class=n>read</span><span class=p>()</span><span class=o>.</span><span class=n>strip</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>factory</span><span class=p>():</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>Query</span><span class=p>(</span><span class=n>sql</span><span class=p>,</span> <span class=n>engine</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>factory</span>
</span></span></code></pre></div><p>Advanced implementation of this particular technique will use:</p><ul><li>Row format classes to return Python objects or <code>namedtuples</code>.</li><li>Context managers to ensure the connection to the database gets closed.</li><li>A connection pool as the engine to reuse connection objects.</li><li>Advanced error handling for not found or parameter errors.</li></ul><p>We do this so much that we <em>plan</em> to create a package called <a href=https://github.com/tipsybear/ormbad>ORMBad</a> which will implement engines and a more advanced query pattern. We just have to get around to doing it!</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://bbengfort.github.io/2016/01/better-json-encoding/><span class=title>« Prev</span><br><span>Better JSON Encoding</span></a>
<a class=next href=https://bbengfort.github.io/2016/01/codetime-and-clock/><span class=title>Next »</span><br><span>The codetime and clock Commands</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://bbengfort.github.io>Libelli</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>