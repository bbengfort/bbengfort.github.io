<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Packaging Python Libraries with PyPI | Libelli</title><meta name=keywords content><meta name=description content="Package deployment is something that is so completely necessary, but such a pain in the butt that I avoid it a little bit. However to reuse code in Python and to do awesome things like pip install mycode, you need to package it up and stick it on to PyPI (pronounced /pīˈpēˈī/ according to one site I read, though I still prefer /pīˈpī/). This process should be easy, but it&rsquo;s detail oriented and there are only two good walk throughs (see links below)."><meta name=author content="Benjamin Bengfort"><link rel=canonical href=https://bbengfort.github.io/2016/01/packaging-with-pypi/><link crossorigin=anonymous href=/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe+FVUFzPh7U=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://bbengfort.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://bbengfort.github.io/icon.png><link rel=icon type=image/png sizes=32x32 href=https://bbengfort.github.io/icon.png><link rel=apple-touch-icon href=https://bbengfort.github.io/apple-touch-icon-precomposed.png><link rel=mask-icon href=https://bbengfort.github.io/icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-D3BE7EHHVP"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-D3BE7EHHVP",{anonymize_ip:!1})}</script><meta property="og:title" content="Packaging Python Libraries with PyPI"><meta property="og:description" content="Package deployment is something that is so completely necessary, but such a pain in the butt that I avoid it a little bit. However to reuse code in Python and to do awesome things like pip install mycode, you need to package it up and stick it on to PyPI (pronounced /pīˈpēˈī/ according to one site I read, though I still prefer /pīˈpī/). This process should be easy, but it&rsquo;s detail oriented and there are only two good walk throughs (see links below)."><meta property="og:type" content="article"><meta property="og:url" content="https://bbengfort.github.io/2016/01/packaging-with-pypi/"><meta property="og:image" content="https://bbengfort.github.io/bear.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2016-01-20T15:33:06+00:00"><meta property="article:modified_time" content="2016-01-20T15:33:06+00:00"><meta property="og:site_name" content="Libelli"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://bbengfort.github.io/bear.png"><meta name=twitter:title content="Packaging Python Libraries with PyPI"><meta name=twitter:description content="Package deployment is something that is so completely necessary, but such a pain in the butt that I avoid it a little bit. However to reuse code in Python and to do awesome things like pip install mycode, you need to package it up and stick it on to PyPI (pronounced /pīˈpēˈī/ according to one site I read, though I still prefer /pīˈpī/). This process should be easy, but it&rsquo;s detail oriented and there are only two good walk throughs (see links below)."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://bbengfort.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Packaging Python Libraries with PyPI","item":"https://bbengfort.github.io/2016/01/packaging-with-pypi/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Packaging Python Libraries with PyPI","name":"Packaging Python Libraries with PyPI","description":"Package deployment is something that is so completely necessary, but such a pain in the butt that I avoid it a little bit. However to reuse code in Python and to do awesome things like pip install mycode, you need to package it up and stick it on to PyPI (pronounced /pīˈpēˈī/ according to one site I read, though I still prefer /pīˈpī/). This process should be easy, but it\u0026rsquo;s detail oriented and there are only two good walk throughs (see links below).","keywords":[],"articleBody":"Package deployment is something that is so completely necessary, but such a pain in the butt that I avoid it a little bit. However to reuse code in Python and to do awesome things like pip install mycode, you need to package it up and stick it on to PyPI (pronounced /pīˈpēˈī/ according to one site I read, though I still prefer /pīˈpī/). This process should be easy, but it’s detail oriented and there are only two good walk throughs (see links below).\nThe Python Package Index or PyPI is the official third-party software repository for the Python programming language. Python developers intend it to be a comprehensive catalog of all open source Python packages. — Wikipedia\nI’ve outlined my process for publishing libraries to PyPI in this post. It is mostly for my own future reference, but I am writing an upcoming post about publishing data projects to PyPI on District Data Labs.\nGetting Started Before you can publish a package to PyPI, you need to make sure that you’re doing Python right. Mostly this means to ensure that you’ve structured your Python package according to the guide: How to Develop Quality Python Code. You should also have several files already part of your project, see [Basic Python Project Files]({% post_url 2016-01-09-project-start %}) for those.\nHowever, there are some things you probably haven’t done yet, so here is my checklist of stuff to take care of:\nCreating Accounts You must create accounts on both the PyPI Test and PyPI Live sites in order to upload code. So do that now and log in to your PyPI account. Once you’ve done that, create a .pypirc configuration file with your account information. Mine looks like this:\n[distutils] index-servers = pypi pypitest [pypi] repository = https://pypi.python.org/pypi username = bbengfort password = theeaglefliesatmidnight [pypitest] repository = https://testpypi.python.org/pypi username = bbengfort password = shadowofthedawnawaits Make sure this file is in your home directory; whenever you work with pip or a setup.py file, it will use this configuration for interactions with the remote index servers. As a side note, you can also build your own internal index servers using S3 or other tools!\nFinal Notes Ok for the purposes of this post, we’re going to assume that we’re working on a library called “foo” and that the directory structure looks like this:\n$ project . ├── .gitignore ├── .travis.yml ├── DESCRIPTION.rst ├── LICENSE.txt ├── Makefile ├── MANIFEST.in ├── mkdocs.yml ├── README.md ├── requirements.txt ├── setup.py ├── setup.cfg ├── bin | └── app.py ├── docs | ├── images | | └── banner.jpg | └── index.md ├── fixtures ├── foo | ├── __init__.py | └── version.py └── tests └── __init__.py Honestly, I hate that these repos grow to such massive sizes, but honestly, this is a minimal setup for a normal Python project. Or at least, a minimal one the way I do it. Needless to say, I’ll be discussing many of these files, in particular, DESCRIPTION.rst, MANIFEST.in, requirements.txt, setup.py, setup.cfg, and version.py in this post. Most of the other files are either self explanatory or contained in another post.\nSetup and Meta The first step is to configure your project with the necessary setup and meta data files. The first and most important of these is the setup.py file which will use the other meta files in the project. Basically, I just copy and paste the following file into all my projects and modify as needed. Apparently this is just a thing Python developers do.\nSo there is a lot going on here, but you can see that the basic meta information is right at the top. I hoped to top load this file so that copy and paste would be as easy as possible. A couple of notes:\nThe license can just be the name of the license like “MIT” or “Apache” — the LICENSE.txt file will spell everything out. The GitHub repository is important; particularly because the download url is formed from a tag, v + the version number. The classifiers must be selected from Python Classifiers. The get_version function must be stored in a file called version.py such that the setup.py script can read the file and exec it without accidentally importing any dependencies. Unfortunately, PyPI doesn’t display Markdown, so for the long description (which is displayed on the PyPI project page) I have created a file called DESCRIPTION.rst which is in reStructuredTxt. The setup script uses the find_packages function to discover the contained packages (which allows you to easily create packages with multiple top level modules). Therefore you need to tell it which directories not to look in, as specified by EXCLUDES. The script, bin/app.py will be installed to the $PATH of the user installing the program, but is not included as a module. I probably do need to break down these notes a bit more, but they are for reference here since I tend to speed write these posts. Check back later, maybe I’ll have updated them!\nConfiguration and Manifest The setup.cfg file allows you to specify other configurations. In my case it looks like this (assuming a Python 2 and 3 compatible package):\n[metadata] description-file = README.md [wheel] universal = 1 Basically the metadata tag is an attempt to get the Markdown README into the package, but it doesn’t really work (sadly). The manifest lists all the other files that should be included in the package when uploading to PyPI. Mine looks like this:\ninclude *.md include *.txt include *.yml include Makefile recursive-include docs *.md recursive-include docs *.jpg recursive-include tests *.py recursive-include bin *.py Final Notes on Configuration I find it really annoying that you have to create an extra description file for PyPI. Everywhere I read says that you should just put a reStructuredTxt file in as your README, but then of course GitHub doesn’t work. I prefer GitHub working, so I go with Markdown. You could write a script to do a conversion with Pandoc, but is it really worth the effort? In the future I’ll find a way to manage this a bit better.\nIf you want the files and directories from MANIFEST.in to also be installed (e.g. fixtures or data for machine learning or database setup), you will have to set include_package_data=True in your setup() call.\nBuilding and Submitting Basically there are two phases to submitting a project to PyPI: build and upload. During the upload phase you first send to PyPI Test to make sure everything is good, then send to PyPI live.\nBuild First build the package for distribution along with the binary wheel distribution:\n$ python setup.py sdist bdist_wheel This will create a build directory with the binary distribution, a foo.egg-info directory with packaging information, and finally a dist directory with two packages, the versioned distribution (foo-0.1.tar.gz) and the wheel (foo-0.1-py2-none-any.whl). Note that if you’re using my Makefile, make clean will clean up all of this extra stuff, but it should be ignored in your .gitignore already.\nAt this point you can (and should) test both the wheel and the sdist package by creating a virtual environment and attempting to install the package with pip directly as follows:\n$ virtualenv venv ... $ source venv/bin/activate $ pip install dist/foo-0.1.tar.gz $ python \u003e\u003e\u003e import foo \u003e\u003e\u003e print foo.__version__ 0.1 \u003e\u003e\u003e exit() $ deactivate $ rm -rf venv Upload The first step to submitting your package to an index server is to register it.\n$ python setup.py register -r pypitest The -r flag here specifies which index server you wish to use as listed by the .pypirc file. We can then upload the package with twine, which is the currently preferred method of uploading due to its security (TLS) and ability to prebuild and test. If you don’t have twine setup, simply pip install it.\n$ twine upload -r pypitest dist/foo-0.1* Note that you can also sign the package with a GnuPG key with the -s option, but we will skip that for now. Once again, we should test our packages with a virtual environment as above, but this time downloading them from PyPI Test directly:\n$ pip install -i https://testpypi.python.org/pypi foo Once this is done and everything is ready to rock, you can repeat the process for uploading to the package to PyPI, simplified here as follows:\n$ python setup.py register $ twine upload dist/foo-0.1* Documentation Did you know that PyPI hosts documentation? Well, it does, and even though you’re mainly hosting on Read the Docs which gets built on each push; it’s pretty handy to upload those same docs to PyPI.\nAssuming you’re using MkDocs as recommended then you can upload this documentation as follows:\n$ mkdocs build --clean $ python setup.py upload_docs --upload-dir=site Clean Up You’ll probably want to clean up after yourself, which is as simple as make clean if you’re using my Makefile. If you’d like to do it with bash it’s as follows:\n$ find . -name \"*.pyc\" -print0 | xargs -0 rm -rf $ rm -rf htmlcov $ rm -rf .coverage $ rm -rf build $ rm -rf dist $ rm -rf foo.egg-info Also you should probably remove that site folder created by the documentation build.\nConclusion Hopefully this post makes your life easier by giving you a simple guide to push new packages to PyPI. I know I shoot fast and loose with some of the stuff, but the post was super long anyway. If you’re really looking for awesome integrations, checkout How to Travis-CI Deploy for automatic deployment after testing.\nVery Helpful Links Official Documentation How to submit a package to PyPI Sharing Your Labor of Love: PyPI Quick and Dirty Packaging and Distributing Projects ","wordCount":"1599","inLanguage":"en","datePublished":"2016-01-20T15:33:06Z","dateModified":"2016-01-20T15:33:06Z","author":{"@type":"Person","name":"Benjamin Bengfort"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://bbengfort.github.io/2016/01/packaging-with-pypi/"},"publisher":{"@type":"Organization","name":"Libelli","logo":{"@type":"ImageObject","url":"https://bbengfort.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bbengfort.github.io accesskey=h title="Libelli (Alt + H)"><img src=https://bbengfort.github.io/icon.png alt aria-label=logo height=35>Libelli</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://bbengfort.github.io/archive/ title=archive><span>archive</span></a></li><li><a href=https://bbengfort.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://bbengfort.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://bbengfort.github.io/about/ title=about><span>about</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://bbengfort.github.io>Home</a>&nbsp;»&nbsp;<a href=https://bbengfort.github.io/posts/>Posts</a></div><h1 class=post-title>Packaging Python Libraries with PyPI</h1><div class=post-meta><span title='2016-01-20 15:33:06 +0000 UTC'>January 20, 2016</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;1599 words&nbsp;·&nbsp;Benjamin Bengfort&nbsp;|&nbsp;<a href=https://github.com/bbengfort/bbengfort.github.io/tree/main/content/posts/2016-01-20-packaging-with-pypi.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>Package deployment is something that is so completely necessary, but such a pain in the butt that I avoid it a little bit. However to reuse code in Python and to do awesome things like <code>pip install mycode</code>, you need to package it up and stick it on to PyPI (pronounced /pīˈpēˈī/ according to one site I read, though I still prefer /pīˈpī/). This process should be easy, but it&rsquo;s detail oriented and there are only two good walk throughs (see links below).</p><blockquote><p>The Python Package Index or <strong>PyPI</strong> is the official third-party software repository for the Python programming language. Python developers intend it to be a comprehensive catalog of all open source Python packages. — <a href=https://en.wikipedia.org/wiki/Python_Package_Index>Wikipedia</a></p></blockquote><p>I&rsquo;ve outlined my process for publishing libraries to PyPI in this post. It is mostly for my own future reference, but I am writing an upcoming post about publishing data projects to PyPI on District Data Labs.</p><h2 id=getting-started>Getting Started<a hidden class=anchor aria-hidden=true href=#getting-started>#</a></h2><p>Before you can publish a package to PyPI, you need to make sure that you&rsquo;re doing Python right. Mostly this means to ensure that you&rsquo;ve structured your Python package according to the guide: <a href=http://blog.districtdatalabs.com/how-to-develop-quality-python-code><em>How to Develop Quality Python Code</em></a>. You should also have several files already part of your project, see [<em>Basic Python Project Files</em>]({% post_url 2016-01-09-project-start %}) for those.</p><p>However, there are some things you probably haven&rsquo;t done yet, so here is my checklist of stuff to take care of:</p><h3 id=creating-accounts>Creating Accounts<a hidden class=anchor aria-hidden=true href=#creating-accounts>#</a></h3><p>You must create accounts on <em>both</em> the <a href=https://testpypi.python.org/pypi>PyPI Test</a> and <a href=https://pypi.python.org/pypi>PyPI Live</a> sites in order to upload code. So do that now and log in to your PyPI account. Once you&rsquo;ve done that, create a <code>.pypirc</code> configuration file with your account information. Mine looks like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ini data-lang=ini><span class=line><span class=cl><span class=k>[distutils]</span>
</span></span><span class=line><span class=cl><span class=na>index-servers</span> <span class=o>=</span><span class=s>
</span></span></span><span class=line><span class=cl><span class=s>    pypi
</span></span></span><span class=line><span class=cl><span class=s>    pypitest</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>[pypi]</span>
</span></span><span class=line><span class=cl><span class=na>repository</span> <span class=o>=</span> <span class=s>https://pypi.python.org/pypi</span>
</span></span><span class=line><span class=cl><span class=na>username</span>   <span class=o>=</span> <span class=s>bbengfort</span>
</span></span><span class=line><span class=cl><span class=na>password</span>   <span class=o>=</span> <span class=s>theeaglefliesatmidnight</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>[pypitest]</span>
</span></span><span class=line><span class=cl><span class=na>repository</span> <span class=o>=</span> <span class=s>https://testpypi.python.org/pypi</span>
</span></span><span class=line><span class=cl><span class=na>username</span>   <span class=o>=</span> <span class=s>bbengfort</span>
</span></span><span class=line><span class=cl><span class=na>password</span>   <span class=o>=</span> <span class=s>shadowofthedawnawaits</span>
</span></span></code></pre></div><p>Make sure this file is in your home directory; whenever you work with pip or a setup.py file, it will use this configuration for interactions with the remote index servers. As a side note, you can also build your own internal index servers using S3 or other tools!</p><h3 id=final-notes>Final Notes<a hidden class=anchor aria-hidden=true href=#final-notes>#</a></h3><p>Ok for the purposes of this post, we&rsquo;re going to assume that we&rsquo;re working on a library called “foo” and that the directory structure looks like this:</p><pre tabindex=0><code>$ project
.
├── .gitignore
├── .travis.yml
├── DESCRIPTION.rst
├── LICENSE.txt
├── Makefile
├── MANIFEST.in
├── mkdocs.yml
├── README.md
├── requirements.txt
├── setup.py
├── setup.cfg
├── bin
|   └── app.py
├── docs
|   ├── images
|   |   └── banner.jpg
|   └── index.md
├── fixtures
├── foo
|   ├── __init__.py
|   └── version.py
└── tests
    └── __init__.py
</code></pre><p>Honestly, I hate that these repos grow to such massive sizes, but honestly, this is a <em>minimal</em> setup for a normal Python project. Or at least, a minimal one the way I do it. Needless to say, I&rsquo;ll be discussing many of these files, in particular, <code>DESCRIPTION.rst</code>, <code>MANIFEST.in</code>, <code>requirements.txt</code>, <code>setup.py</code>, <code>setup.cfg</code>, and <code>version.py</code> in this post. Most of the other files are either self explanatory or contained in another post.</p><h2 id=setup-and-meta>Setup and Meta<a hidden class=anchor aria-hidden=true href=#setup-and-meta>#</a></h2><p>The first step is to configure your project with the necessary setup and meta data files. The first and most important of these is the <code>setup.py</code> file which will use the other meta files in the project. Basically, I just copy and paste the following file into all my projects and modify as needed. Apparently this is just a thing Python developers do.</p><script type=application/javascript src=https://gist.github.com/bbengfort/76d45a80af5494908c95.js></script><p>So there is a lot going on here, but you can see that the basic meta information is right at the top. I hoped to top load this file so that copy and paste would be as easy as possible. A couple of notes:</p><ol><li>The license can just be the name of the license like “MIT” or “Apache” — the <code>LICENSE.txt</code> file will spell everything out.</li><li>The GitHub repository is important; particularly because the download url is formed from a tag, v + the version number.</li><li>The classifiers <strong>must</strong> be selected from <a href="https://pypi.python.org/pypi?%3Aaction=list_classifiers">Python Classifiers</a>.</li><li>The <code>get_version</code> function must be stored in a file called <code>version.py</code> such that the <code>setup.py</code> script can read the file and <code>exec</code> it <em>without accidentally importing any dependencies</em>.</li><li>Unfortunately, <a href=https://coderwall.com/p/qawuyq/use-markdown-readme-s-in-python-modules>PyPI doesn&rsquo;t display Markdown</a>, so for the long description (which is displayed on the PyPI project page) I have created a file called <code>DESCRIPTION.rst</code> which is in reStructuredTxt.</li><li>The setup script uses the <code>find_packages</code> function to discover the contained packages (which allows you to easily create packages with multiple top level modules). Therefore you need to tell it which directories <em>not</em> to look in, as specified by <code>EXCLUDES</code>.</li><li>The script, <code>bin/app.py</code> will be installed to the <code>$PATH</code> of the user installing the program, but is not included as a module.</li></ol><p>I probably do need to break down these notes a bit more, but they are for reference here since I tend to speed write these posts. Check back later, maybe I&rsquo;ll have updated them!</p><h3 id=configuration-and-manifest>Configuration and Manifest<a hidden class=anchor aria-hidden=true href=#configuration-and-manifest>#</a></h3><p>The <code>setup.cfg</code> file allows you to specify other configurations. In my case it looks like this (assuming a Python 2 and 3 compatible package):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ini data-lang=ini><span class=line><span class=cl><span class=k>[metadata]</span>
</span></span><span class=line><span class=cl><span class=na>description-file</span> <span class=o>=</span> <span class=s>README.md</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>[wheel]</span>
</span></span><span class=line><span class=cl><span class=na>universal</span> <span class=o>=</span> <span class=s>1</span>
</span></span></code></pre></div><p>Basically the metadata tag is an attempt to get the Markdown README into the package, but it doesn&rsquo;t really work (sadly). The manifest lists all the other files that should be included in the package when uploading to PyPI. Mine looks like this:</p><pre tabindex=0><code>include *.md
include *.txt
include *.yml
include Makefile
recursive-include docs *.md
recursive-include docs *.jpg
recursive-include tests *.py
recursive-include bin *.py
</code></pre><h3 id=final-notes-on-configuration>Final Notes on Configuration<a hidden class=anchor aria-hidden=true href=#final-notes-on-configuration>#</a></h3><p>I find it really annoying that you have to create an extra description file for PyPI. Everywhere I read says that you should just put a reStructuredTxt file in as your README, but then of course GitHub doesn&rsquo;t work. I prefer GitHub working, so I go with Markdown. You could write a script to do a conversion with Pandoc, but is it really worth the effort? In the future I&rsquo;ll find a way to manage this a bit better.</p><p>If you want the files and directories from <code>MANIFEST.in</code> to also be installed (e.g. fixtures or data for machine learning or database setup), you will have to set <code>include_package_data=True</code> in your <code>setup()</code> call.</p><h2 id=building-and-submitting>Building and Submitting<a hidden class=anchor aria-hidden=true href=#building-and-submitting>#</a></h2><p>Basically there are two phases to submitting a project to PyPI: build and upload. During the upload phase you first send to PyPI Test to make sure everything is good, then send to PyPI live.</p><h3 id=build>Build<a hidden class=anchor aria-hidden=true href=#build>#</a></h3><p>First build the package for distribution along with the binary <a href=http://pythonwheels.com/>wheel</a> distribution:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ python setup.py sdist bdist_wheel
</span></span></code></pre></div><p>This will create a <code>build</code> directory with the binary distribution, a <code>foo.egg-info</code> directory with packaging information, and finally a <code>dist</code> directory with two packages, the versioned distribution (<code>foo-0.1.tar.gz</code>) and the wheel (<code>foo-0.1-py2-none-any.whl</code>). Note that if you&rsquo;re using my <code>Makefile</code>, <code>make clean</code> will clean up all of this extra stuff, but it should be ignored in your <code>.gitignore</code> already.</p><p>At this point you can (and should) test both the wheel and the sdist package by creating a virtual environment and attempting to install the package with <code>pip</code> directly as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ virtualenv venv
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>$ <span class=nb>source</span> venv/bin/activate
</span></span><span class=line><span class=cl>$ pip install dist/foo-0.1.tar.gz
</span></span><span class=line><span class=cl>$ python
</span></span><span class=line><span class=cl>&gt;&gt;&gt; import foo
</span></span><span class=line><span class=cl>&gt;&gt;&gt; print foo.__version__
</span></span><span class=line><span class=cl>0.1
</span></span><span class=line><span class=cl>&gt;&gt;&gt; exit<span class=o>()</span>
</span></span><span class=line><span class=cl>$ deactivate
</span></span><span class=line><span class=cl>$ rm -rf venv
</span></span></code></pre></div><h3 id=upload>Upload<a hidden class=anchor aria-hidden=true href=#upload>#</a></h3><p>The first step to submitting your package to an index server is to register it.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ python setup.py register -r pypitest
</span></span></code></pre></div><p>The <code>-r</code> flag here specifies which index server you wish to use as listed by the <code>.pypirc</code> file. We can then upload the package with <a href=https://pypi.python.org/pypi/twine>twine</a>, which is the currently preferred method of uploading due to its security (TLS) and ability to prebuild and test. If you don&rsquo;t have twine setup, simply <code>pip install</code> it.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ twine upload -r pypitest dist/foo-0.1*
</span></span></code></pre></div><p>Note that you can also sign the package with a GnuPG key with the <code>-s</code> option, but we will skip that for now. Once again, we should test our packages with a virtual environment as above, but this time downloading them from PyPI Test directly:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ pip install -i https://testpypi.python.org/pypi foo
</span></span></code></pre></div><p>Once this is done and everything is ready to rock, you can repeat the process for uploading to the package to PyPI, simplified here as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ python setup.py register
</span></span><span class=line><span class=cl>$ twine upload dist/foo-0.1*
</span></span></code></pre></div><h3 id=documentation>Documentation<a hidden class=anchor aria-hidden=true href=#documentation>#</a></h3><p>Did you know that PyPI <a href=https://pythonhosted.org/>hosts documentation</a>? Well, it does, and even though you&rsquo;re mainly hosting on <a href=https://readthedocs.org/>Read the Docs</a> which gets built on each push; it&rsquo;s pretty handy to upload those same docs to PyPI.</p><p>Assuming you&rsquo;re using <a href=http://www.mkdocs.org/>MkDocs</a> as recommended then you can upload this documentation as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ mkdocs build --clean
</span></span><span class=line><span class=cl>$ python setup.py upload_docs --upload-dir<span class=o>=</span>site
</span></span></code></pre></div><h3 id=clean-up>Clean Up<a hidden class=anchor aria-hidden=true href=#clean-up>#</a></h3><p>You&rsquo;ll probably want to clean up after yourself, which is as simple as <code>make clean</code> if you&rsquo;re using my Makefile. If you&rsquo;d like to do it with bash it&rsquo;s as follows:</p><pre tabindex=0><code>$ find . -name &#34;*.pyc&#34; -print0 | xargs -0 rm -rf
$ rm -rf htmlcov
$ rm -rf .coverage
$ rm -rf build
$ rm -rf dist
$ rm -rf foo.egg-info
</code></pre><p>Also you should probably remove that <code>site</code> folder created by the documentation build.</p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>Hopefully this post makes your life easier by giving you a simple guide to push new packages to PyPI. I know I shoot fast and loose with some of the stuff, but the post was super long anyway. If you&rsquo;re really looking for awesome integrations, checkout <a href=http://5minutes.youkidea.com/howto-deploy-python-package-on-pypi-with-github-and-travis.html>How to Travis-CI Deploy</a> for automatic deployment after testing.</p><h3 id=very-helpful-links>Very Helpful Links<a hidden class=anchor aria-hidden=true href=#very-helpful-links>#</a></h3><ul><li><a href=https://wiki.python.org/moin/CheeseShopTutorial#Submitting_Packages_to_the_Package_Index>Official Documentation</a></li><li><a href=http://peterdowns.com/posts/first-time-with-pypi.html>How to submit a package to PyPI</a></li><li><a href=https://hynek.me/articles/sharing-your-labor-of-love-pypi-quick-and-dirty/>Sharing Your Labor of Love: PyPI Quick and Dirty</a></li><li><a href=http://python-packaging-user-guide.readthedocs.org/en/latest/distributing/>Packaging and Distributing Projects</a></li></ul></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://bbengfort.github.io/2016/01/freezing-requirements/><span class=title>« Prev</span><br><span>Freezing Package Requirements</span></a>
<a class=next href=https://bbengfort.github.io/2016/01/better-json-encoding/><span class=title>Next »</span><br><span>Better JSON Encoding</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://bbengfort.github.io>Libelli</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>