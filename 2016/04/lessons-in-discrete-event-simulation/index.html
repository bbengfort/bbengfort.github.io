<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Lessons in Discrete Event Simulation | Libelli</title><meta name=keywords content><meta name=description content="Part of my research involves the creation of large scale distributed systems, and while we do build these systems and deploy them, we do find that simulating them for development and research gives us an advantage in trying new things out. To that end, I employ discrete event simulation (DES) using Python&rsquo;s SimPy library to build very large simulations of distributed systems, such as the one I&rsquo;ve built to inspect consistency patterns in variable latency, heterogenous, partition prone networks: CloudScope."><meta name=author content="Benjamin Bengfort"><link rel=canonical href=https://bbengfort.github.io/2016/04/lessons-in-discrete-event-simulation/><link crossorigin=anonymous href=/assets/css/stylesheet.min.d0c0348c2d0cff14148d0e347258519d8df2ce53ce5ac32c7bd9a549182cb8ae.css integrity="sha256-0MA0jC0M/xQUjQ40clhRnY3yzlPOWsMse9mlSRgsuK4=" rel="preload stylesheet" as=style><link rel=preload href=/icon.png as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><link rel=icon href=https://bbengfort.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://bbengfort.github.io/icon.png><link rel=icon type=image/png sizes=32x32 href=https://bbengfort.github.io/icon.png><link rel=apple-touch-icon href=https://bbengfort.github.io/apple-touch-icon-precomposed.png><link rel=mask-icon href=https://bbengfort.github.io/icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.79.0"><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-8096804-11','auto');ga('send','pageview');}</script><meta property="og:title" content="Lessons in Discrete Event Simulation"><meta property="og:description" content="Part of my research involves the creation of large scale distributed systems, and while we do build these systems and deploy them, we do find that simulating them for development and research gives us an advantage in trying new things out. To that end, I employ discrete event simulation (DES) using Python&rsquo;s SimPy library to build very large simulations of distributed systems, such as the one I&rsquo;ve built to inspect consistency patterns in variable latency, heterogenous, partition prone networks: CloudScope."><meta property="og:type" content="article"><meta property="og:url" content="https://bbengfort.github.io/2016/04/lessons-in-discrete-event-simulation/"><meta property="og:image" content="https://bbengfort.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2016-04-15T06:26:42+00:00"><meta property="article:modified_time" content="2016-04-15T06:26:42+00:00"><meta property="og:site_name" content="Libelli"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://bbengfort.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Lessons in Discrete Event Simulation"><meta name=twitter:description content="Part of my research involves the creation of large scale distributed systems, and while we do build these systems and deploy them, we do find that simulating them for development and research gives us an advantage in trying new things out. To that end, I employ discrete event simulation (DES) using Python&rsquo;s SimPy library to build very large simulations of distributed systems, such as the one I&rsquo;ve built to inspect consistency patterns in variable latency, heterogenous, partition prone networks: CloudScope."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://bbengfort.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Lessons in Discrete Event Simulation","item":"https://bbengfort.github.io/2016/04/lessons-in-discrete-event-simulation/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Lessons in Discrete Event Simulation","name":"Lessons in Discrete Event Simulation","description":"Part of my research involves the creation of large scale distributed systems, and while we do build these systems and deploy them, we do find that simulating them for development and research gives us an advantage in trying new things out. To that end, I employ discrete event simulation (DES) using Python\u0026rsquo;s SimPy library to build very large simulations of distributed systems, such as the one I\u0026rsquo;ve built to inspect consistency patterns in variable latency, heterogenous, partition prone networks: CloudScope.","keywords":[],"articleBody":"Part of my research involves the creation of large scale distributed systems, and while we do build these systems and deploy them, we do find that simulating them for development and research gives us an advantage in trying new things out. To that end, I employ discrete event simulation (DES) using Python’s SimPy library to build very large simulations of distributed systems, such as the one I’ve built to inspect consistency patterns in variable latency, heterogenous, partition prone networks: CloudScope.\nVery briefly (perhaps I’ll do a SimPy tutorial at another date), SimPy creates an environment that dispatches and listens for events. You create these event processes in the environment by implementing [generators]({% post_url 2016-02-05-iterators-generators %}) that yield control of the execution as they’re working. As a result, the SimPy environment can call the next() method of your generator to do processing on schedule. Consider the following code:\nimport simpy def wake_and_sleep(env): state = 'Awake' while True: # change state and alert state = 'Awake' if state == 'Asleep' else 'Asleep' print \"{} at {}\".format(state, env.now) # wait 5 timesteps yield env.timeout(5) if __name__ == '__main__': env = simpy.Environment() env.process(wake_and_sleep(env)) env.run(until=100) This simple generator function runs forever and constantly switches its state from Awake to Asleep to Awake again every 5 timesteps. If you run this you’ll get something that looks as follows:\nAsleep at 0 Awake at 5 Asleep at 10 Awake at 15 Asleep at 20 ... The neat thing is that SimPy doesn’t have a counter that simply increments the timestep and checks if any events have gone off – and actually that’s the whole point of discrete event simulation: to simulate events and their interactions as they occur in order without the burden of waiting for a real time simulation. Instead, SimPy has a master schedule that is created by calling the next() method of all its processes. When you yield a timeout of 5, your next() method will be called at env.now + 5. SimPy just increments now to the next timestep that has an event in it (or the minimum time of the current schedule).\nThis means that it’s a bad idea to constantly yield 1 timestep timeouts. Especially if you’re doing something like checking a state for work. Instead you should register a callback to the state change that you’re looking for, and call the closure there. However, when you’re modeling real world systems that do check their state every timestep, it’s very difficult. This led me to the question:\nHow bad is it to constantly yield 1 timestep timeouts in large simulations?\nSo of course, we need data.\nI created a SimPy process that would yield a timeout with a specific number of steps as a timeout, then track how many executions the process and the amount of real time that passes by. The experiment variables were the maximum number of timesteps allowed in the simulation and the number of steps to yield in the process. I selected a range of 10 maximum times between 1,000,000 and 50,000,000, with a stride of 5,000,000 and a range of steps between 1 and 10. This led to 100 runs of the simulation with each dimension pair. The [results]({{ site.baseurl }}assets/data/timestepping.csv) were as follows:\n![Simulation Timestepping Results]({{ site.baseurl }}assets/images/2016-04-15-timestepping.png)\nAs you can see, there is an exponential decrease in the amount of real time taken by the system, and the amount of time you yield in your event process. Even just going from doing a check every single timestep to every other timestep will save you a lot of real time in your simulation process!\nAnd a different view, the interaction plot is as follows:\n![Simulation Interaction Plot]({{ site.baseurl }}assets/images/2016-04-15-interact-plot.png)\nThe interact plot shows every experiment, which is a grid of max simulation time (until) and the number of steps between event process yield. The heatmap shows that the amount of real time is exponentially dependent on steps (the curve around the X access) and linearly dependent on until (there is a straight line through the center of the curves).\nThe code to reproduce the data and the experiment is as follows:\n The code does contain some cloudscope utilities, but they’re not large and can be found in the cloudscope repository.\nFor the results reported, the code was run on a MacBook Pro (Retina, 15-inch, Early 2013) with a 2.8 GHz Intel Core i7 processor and 16 GB of 1600 MHz DDR3 memory, running OS X El Capitan Version 10.11.4.\nThe visualizations were generated with the following code:\nimport numpy as np import pandas as pd import seaborn as sns # Set the context and style sns.set_context('talk') sns.set_style('whitegrid') # Load the data data = pd.read_csv('timestepping.csv') # Plot the means of the experiment times by step. sns.lmplot( 'steps', 'time', size=12, x_estimator=np.mean, fit_reg=False, data=data ) # Plot the interact plot of all experiments sns.interactplot('steps', 'until', 'time', size=12, data=data) So the lesson is - yield at least three timesteps in your simulation!\n","wordCount":"823","inLanguage":"en","datePublished":"2016-04-15T06:26:42Z","dateModified":"2016-04-15T06:26:42Z","author":{"@type":"Person","name":"Benjamin Bengfort"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://bbengfort.github.io/2016/04/lessons-in-discrete-event-simulation/"},"publisher":{"@type":"Organization","name":"Libelli","logo":{"@type":"ImageObject","url":"https://bbengfort.github.io/favicon.ico"}}}</script></head><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme: #1d1e20;--entry: #2e2e33;--primary: rgba(255, 255, 255, 0.84);--secondary: rgba(255, 255, 255, 0.56);--tertiary: rgba(255, 255, 255, 0.16);--content: rgba(255, 255, 255, 0.74);--hljs-bg: #2e2e33;--code-bg: #37383e;--border: #333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://bbengfort.github.io accesskey=h title="Libelli (Alt + H)"><img src=/icon.png alt=logo aria-label=logo height=35>Libelli</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://bbengfort.github.io/archive/ title=archive><span>archive</span></a></li><li><a href=https://bbengfort.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://bbengfort.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://bbengfort.github.io/about/ title=about><span>about</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Lessons in Discrete Event Simulation</h1><div class=post-meta>April 15, 2016&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Benjamin Bengfort</div></header><div class=post-content><p>Part of my research involves the creation of large scale distributed systems, and while we do build these systems and deploy them, we do find that simulating them for development and research gives us an advantage in trying new things out. To that end, I employ <a href=https://en.wikipedia.org/wiki/Discrete_event_simulation>discrete event simulation</a> (DES) using Python&rsquo;s <a href=https://simpy.readthedocs.org/en/latest/>SimPy</a> library to build very large simulations of distributed systems, such as the one I&rsquo;ve built to inspect consistency patterns in variable latency, heterogenous, partition prone networks: <a href=https://github.com/bbengfort/cloudscope>CloudScope</a>.</p><p>Very briefly (perhaps I&rsquo;ll do a SimPy tutorial at another date), SimPy creates an environment that dispatches and listens for <em>events</em>. You create these event processes in the environment by implementing [generators]({% post_url 2016-02-05-iterators-generators %}) that <code>yield</code> control of the execution as they&rsquo;re working. As a result, the SimPy environment can call the <code>next()</code> method of your generator to do processing on schedule. Consider the following code:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#f92672>import</span> simpy

<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>wake_and_sleep</span>(env):
    state <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;Awake&#39;</span>

    <span style=color:#66d9ef>while</span> True:
        <span style=color:#75715e># change state and alert</span>
        state <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;Awake&#39;</span> <span style=color:#66d9ef>if</span> state <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;Asleep&#39;</span> <span style=color:#66d9ef>else</span> <span style=color:#e6db74>&#39;Asleep&#39;</span>
        <span style=color:#66d9ef>print</span> <span style=color:#e6db74>&#34;{} at {}&#34;</span><span style=color:#f92672>.</span>format(state, env<span style=color:#f92672>.</span>now)

        <span style=color:#75715e># wait 5 timesteps</span>
        <span style=color:#66d9ef>yield</span> env<span style=color:#f92672>.</span>timeout(<span style=color:#ae81ff>5</span>)

<span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;__main__&#39;</span>:
    env <span style=color:#f92672>=</span> simpy<span style=color:#f92672>.</span>Environment()
    env<span style=color:#f92672>.</span>process(wake_and_sleep(env))
    env<span style=color:#f92672>.</span>run(until<span style=color:#f92672>=</span><span style=color:#ae81ff>100</span>)
</code></pre></div><p>This simple generator function runs forever and constantly switches its state from <code>Awake</code> to <code>Asleep</code> to <code>Awake</code> again every 5 timesteps. If you run this you&rsquo;ll get something that looks as follows:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>Asleep at 0
Awake at 5
Asleep at 10
Awake at 15
Asleep at 20
...
</code></pre></div><p>The neat thing is that SimPy doesn&rsquo;t have a counter that simply increments the timestep and checks if any events have gone off &ndash; and actually that&rsquo;s the whole point of discrete event simulation: to simulate events and their interactions as they occur in order without the burden of waiting for a real time simulation. Instead, SimPy has a master schedule that is created by calling the <code>next()</code> method of all its processes. When you <code>yield</code> a timeout of 5, your <code>next()</code> method will be called at <code>env.now + 5</code>. SimPy just increments <code>now</code> to the next timestep that has an event in it (or the minimum time of the current schedule).</p><p>This means that <em>it&rsquo;s a bad idea to constantly yield 1 timestep timeouts</em>. Especially if you&rsquo;re doing something like checking a state for work. Instead you should register a callback to the state change that you&rsquo;re looking for, and call the closure there. However, when you&rsquo;re modeling real world systems that do check their state every timestep, it&rsquo;s very difficult. This led me to the question:</p><p><strong>How bad is it to constantly yield 1 timestep timeouts in large simulations?</strong></p><p>So of course, we need data.</p><p>I created a SimPy process that would yield a timeout with a specific number of steps as a timeout, then track how many executions the process and the amount of real time that passes by. The experiment variables were the maximum number of timesteps allowed in the simulation and the number of steps to yield in the process. I selected a range of 10 maximum times between 1,000,000 and 50,000,000, with a stride of 5,000,000 and a range of steps between 1 and 10. This led to 100 runs of the simulation with each dimension pair. The [results]({{ site.baseurl }}assets/data/timestepping.csv) were as follows:</p><p>![Simulation Timestepping Results]({{ site.baseurl }}assets/images/2016-04-15-timestepping.png)</p><p>As you can see, there is an exponential decrease in the amount of real time taken by the system, and the amount of time you yield in your event process. Even just going from doing a check every single timestep to every other timestep will save you a lot of real time in your simulation process!</p><p>And a different view, the <a href=https://stanford.edu/~mwaskom/software/seaborn/generated/seaborn.interactplot.html>interaction plot</a> is as follows:</p><p>![Simulation Interaction Plot]({{ site.baseurl }}assets/images/2016-04-15-interact-plot.png)</p><p>The interact plot shows every experiment, which is a grid of max simulation time (until) and the number of steps between event process yield. The heatmap shows that the amount of real time is exponentially dependent on steps (the curve around the X access) and linearly dependent on until (there is a straight line through the center of the curves).</p><p>The code to reproduce the data and the experiment is as follows:</p><script type=application/javascript src=https://gist.github.com/bbengfort/f950dbc0ac9b7d3d4c32caf1d26dbcc5.js></script><p>The code does contain some cloudscope utilities, but they&rsquo;re not large and can be found in the <a href=https://github.com/bbengfort/cloudscope>cloudscope repository</a>.</p><p>For the results reported, the code was run on a MacBook Pro (Retina, 15-inch, Early 2013) with a 2.8 GHz Intel Core i7 processor and 16 GB of 1600 MHz DDR3 memory, running OS X El Capitan Version 10.11.4.</p><p>The visualizations were generated with the following code:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#f92672>import</span> numpy <span style=color:#f92672>as</span> np
<span style=color:#f92672>import</span> pandas <span style=color:#f92672>as</span> pd
<span style=color:#f92672>import</span> seaborn <span style=color:#f92672>as</span> sns

<span style=color:#75715e># Set the context and style</span>
sns<span style=color:#f92672>.</span>set_context(<span style=color:#e6db74>&#39;talk&#39;</span>)
sns<span style=color:#f92672>.</span>set_style(<span style=color:#e6db74>&#39;whitegrid&#39;</span>)

<span style=color:#75715e># Load the data</span>
data <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>read_csv(<span style=color:#e6db74>&#39;timestepping.csv&#39;</span>)

<span style=color:#75715e># Plot the means of the experiment times by step.</span>
sns<span style=color:#f92672>.</span>lmplot(
    <span style=color:#e6db74>&#39;steps&#39;</span>, <span style=color:#e6db74>&#39;time&#39;</span>, size<span style=color:#f92672>=</span><span style=color:#ae81ff>12</span>,
    x_estimator<span style=color:#f92672>=</span>np<span style=color:#f92672>.</span>mean, fit_reg<span style=color:#f92672>=</span>False, data<span style=color:#f92672>=</span>data
)

<span style=color:#75715e># Plot the interact plot of all experiments</span>
sns<span style=color:#f92672>.</span>interactplot(<span style=color:#e6db74>&#39;steps&#39;</span>, <span style=color:#e6db74>&#39;until&#39;</span>, <span style=color:#e6db74>&#39;time&#39;</span>, size<span style=color:#f92672>=</span><span style=color:#ae81ff>12</span>, data<span style=color:#f92672>=</span>data)
</code></pre></div><p>So the lesson is - yield at least three timesteps in your simulation!</p></div><footer class=post-footer></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://bbengfort.github.io>Libelli</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById('menu')
menu.scrollLeft=localStorage.getItem("menu-scroll-position");menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft);}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);if(!window.matchMedia('(prefers-reduced-motion: reduce)').matches){document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});}else{document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();}
if(id==="top"){history.replaceState(null,null," ");}else{history.pushState(null,null,`#${id}`);}});});</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script></body></html>