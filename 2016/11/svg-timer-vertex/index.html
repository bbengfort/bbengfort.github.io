<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>SVG Vertex with a Timer | Libelli</title><meta name=keywords content><meta name=description content="In order to promote the use of graph data structures for data analysis, I&rsquo;ve recently given talks on dynamic graphs: embedding time into graph structures to analyze change. In order to embed time into a graph there are two primary mechanisms: make time a graph element (a vertex or an edge) or have multiple subgraphs where each graph represents a discrete time step. By using either of these techniques, opportunities exist to perform a structural analysis using graph algorithms on time; for example - asking what time is most central to a particular set of relationships."><meta name=author content="Benjamin Bengfort"><link rel=canonical href=https://bbengfort.github.io/2016/11/svg-timer-vertex/><link crossorigin=anonymous href=/assets/css/stylesheet.min.d0c0348c2d0cff14148d0e347258519d8df2ce53ce5ac32c7bd9a549182cb8ae.css integrity="sha256-0MA0jC0M/xQUjQ40clhRnY3yzlPOWsMse9mlSRgsuK4=" rel="preload stylesheet" as=style><link rel=preload href=/icon.png as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><link rel=icon href=https://bbengfort.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://bbengfort.github.io/icon.png><link rel=icon type=image/png sizes=32x32 href=https://bbengfort.github.io/icon.png><link rel=apple-touch-icon href=https://bbengfort.github.io/apple-touch-icon-precomposed.png><link rel=mask-icon href=https://bbengfort.github.io/icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.79.0"><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-8096804-11','auto');ga('send','pageview');}</script><meta property="og:title" content="SVG Vertex with a Timer"><meta property="og:description" content="In order to promote the use of graph data structures for data analysis, I&rsquo;ve recently given talks on dynamic graphs: embedding time into graph structures to analyze change. In order to embed time into a graph there are two primary mechanisms: make time a graph element (a vertex or an edge) or have multiple subgraphs where each graph represents a discrete time step. By using either of these techniques, opportunities exist to perform a structural analysis using graph algorithms on time; for example - asking what time is most central to a particular set of relationships."><meta property="og:type" content="article"><meta property="og:url" content="https://bbengfort.github.io/2016/11/svg-timer-vertex/"><meta property="og:image" content="https://bbengfort.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2016-11-04T10:30:29+00:00"><meta property="article:modified_time" content="2016-11-04T10:30:29+00:00"><meta property="og:site_name" content="Libelli"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://bbengfort.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="SVG Vertex with a Timer"><meta name=twitter:description content="In order to promote the use of graph data structures for data analysis, I&rsquo;ve recently given talks on dynamic graphs: embedding time into graph structures to analyze change. In order to embed time into a graph there are two primary mechanisms: make time a graph element (a vertex or an edge) or have multiple subgraphs where each graph represents a discrete time step. By using either of these techniques, opportunities exist to perform a structural analysis using graph algorithms on time; for example - asking what time is most central to a particular set of relationships."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://bbengfort.github.io/posts/"},{"@type":"ListItem","position":3,"name":"SVG Vertex with a Timer","item":"https://bbengfort.github.io/2016/11/svg-timer-vertex/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"SVG Vertex with a Timer","name":"SVG Vertex with a Timer","description":"In order to promote the use of graph data structures for data analysis, I\u0026rsquo;ve recently given talks on dynamic graphs: embedding time into graph structures to analyze change. In order to embed time into a graph there are two primary mechanisms: make time a graph element (a vertex or an edge) or have multiple subgraphs where each graph represents a discrete time step. By using either of these techniques, opportunities exist to perform a structural analysis using graph algorithms on time; for example - asking what time is most central to a particular set of relationships.","keywords":[],"articleBody":"In order to promote the use of graph data structures for data analysis, I’ve recently given talks on dynamic graphs: embedding time into graph structures to analyze change. In order to embed time into a graph there are two primary mechanisms: make time a graph element (a vertex or an edge) or have multiple subgraphs where each graph represents a discrete time step. By using either of these techniques, opportunities exist to perform a structural analysis using graph algorithms on time; for example - asking what time is most central to a particular set of relationships.\nGraphs are primarily useful to simplify modeling and querying, but they are also useful for visual analytics. While visualizing static graphs with time embedded as a structure requires only standard graph techniques, visualizing dynamic graphs requires some sort of animation or interaction. We are currently exploring these techniques in the District Data Labs dynamic graphs research group. Towards that research, we are proposing to use D3 and SVG for interaction and visualization.\nAs time moves forward graph elements (vertices and edges) will change, either being added to the graph or removed from them. To support visual analytics, particularly with layouts that will change depending on the nodes that get added (like force directed layouts), these transitions must not be sudden, but instead give visual clues as to what’s going on in the layout. The most obvious choice is to use opacity or size to fade in and out during the transition. However, this does not give the user any sense of how long the node has been on the screen, or how long it has left.\nTherefore, I’m interested in creating vertices that have timers associated with them. Inspired by raftscope, I want to create vertices that have a timer that indicates how long they’ve been on the screen. Here is my initial attempt:\nsvg#timer-vertex { width: 100%; height: 120px; } svg .vertex text { text-anchor: middle; dominant-baseline: central; text-align: center; fill: #FEFEFE; } svg .vertex circle { fill: #003F87; } svg .vertex path { fill: none; stroke: #CF0000; }    var SVG = function(tag) { return $(document.createElementNS('http://www.w3.org/2000/svg', tag)); }; var ARC_WIDTH = 6; function circleCoord(frac, cx, cy, r) { var radians = 2 * Math.PI * (0.75 + frac); return { x: cx + r * Math.cos(radians), y: cy + r * Math.sin(radians), }; } function arcSpec(spec, fraction) { var radius = spec.r + ARC_WIDTH/2; var end = circleCoord(fraction, spec.cx, spec.cy, radius); var s = ['M', spec.cx, ',', spec.cy - radius]; if (fraction  0.5) { s.push('A', radius, ',', radius, '0 0,1', spec.cx, spec.cy + radius); s.push('M', spec.cx, ',', spec.cy + radius); } s.push('A', radius, ',', radius, '0 0,1', end.x, end.y); return s.join(' '); } function updateArcTimer(elems, spec, current) { var amt = current - 0.015; if (amt The code to do this uses JavaScript with jQuery as well as CSS but no other libraries. To make this work for graphs, we’ll have to find a way to implement this vertex type in D3. But for now, we can just look what’s happening.\nFirst I added an SVG element to the body of my HTML:\nhtml head titleVertex Timer Testtitle head body svg id=\"timer-vertex\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" svg body html Then add some simple styles with CSS so that you don’t have to manually set them on every single element:\nsvg { width: 100%; height: 120px; } svg .vertex text { text-anchor: middle; dominant-baseline: central; text-align: center; fill: #FEFEFE; } svg .vertex circle { fill: #003F87; } svg .vertex path { fill: none; stroke: #CF0000; } For the rest of the work, we’re going to manually add SVG elements with JavaScript, updating their attributes with computed values. To make this easier, a simple function will allow us to create SVG elements in the correct namespace:\nfunction SVG(tag) { var ns = 'http://www.w3.org/2000/svg'; return $(document.createElementNS(ns, tag)); } We can now use this function to quickly create the elements of our vertex: the circle representing the node, the text representing the label, and the arc representing the timer. First, let’s find the center of the SVG so that we know where to place the vertex, and define other properties like its radius.\n// Set the constant arc width var ARC_WIDTH = 6; // Select the svg to place the vertex into var svg = $(\"#timer-vertex\"); // Define the vertex center point and radius vertexSpec = { cx: svg.width() / 2, cy: svg.height() / 2, r: 30, } Before we can add all of the elements, we need to define the method by which we create the arc. To do this we’re going to create a path that follows an arc. Creating paths with SVG means defining a d attribute, which contains a series of commands and parameters that define the shape of the path. The first command is the “move to” command, M, that specifies where the path begins, e.g. M50 210 places a point at the coordinates (50, 210). We then define the arc with the A command. The A command is complex, you have to define the x and y radius, axis rotation, sweep flags and an endpoint. However, it is powerful.\nIn the next snippet we will use the arcSpec function to create the d attribute for our path. It returns a string from the spec defining the vertex (the center and radius) as well as the fraction of the circle we want represented on the arc. It also uses another helper function, circleCoord to determine where points around the circle are located.\nfunction circleCoord(frac, cx, cy, r) { var radians = 2 * Math.PI * (0.75 + frac); return { x: cx + r * Math.cos(radians), y: cy + r * Math.sin(radians), }; } function arcSpec(spec, fraction) { var radius = spec.r + ARC_WIDTH/2; var end = circleCoord(fraction, spec.cx, spec.cy, radius); var s = ['M', spec.cx, ',', spec.cy - radius]; if (fraction  0.5) { s.push('A', radius, ',', radius, '0 0,1', spec.cx, spec.cy + radius); s.push('M', spec.cx, ',', spec.cy + radius); } s.push('A', radius, ',', radius, '0 0,1', end.x, end.y); return s.join(' '); } Now that we have these two helper functions in place, we can finally define our elements:\nsvg.append( SVG('g') .attr('id', 'vertex-1') .attr('class', 'vertex') .append(SVG('a') .append(SVG('circle') .attr('class', 'background') .attr(vertexSpec)) .append(SVG('path') .attr('class', 'timer-arc') .attr('style', 'stroke-width: ' + ARC_WIDTH) .attr('d', arcSpec(vertexSpec, 1.0))) ) .append(SVG('text') .attr('class', 'vlabel') .text('v1') .attr({x: vertexSpec.cx, y: vertexSpec.cy})) ); This is simply a matter of appending various SVG elements together to create the group of shapes that together make up the vertex.\nNow to animate, I’ll simply recompute the path of the ARC for a smaller fraction of the vertex at each time step. To do this I’ll use a function that updates the path, then uses setTimeout to schedule the next update once it’s complete:\nfunction updateArcTimer(elems, spec, current) { var amt = current - 0.015; if (amt  0) { amt = 1.0; } elems.attr('d', arcSpec(spec, amt)); setTimeout(function() { updateArcTimer(elems, spec, amt) }, 100); } Playing around with the delay between update (100 ms in this example) and the amount of the arc to reduce (0.015 in this example) changes how fast and smooth the timer is. However, making it too granular can cause weird jitters and artifacts to appear. Kick this function off right after creating the vertex as follows:\nupdateArcTimer($(\".timer-arc\"), vertexSpec, 1.0); Future work for this project will be to implement this style vertex with D3, and the ability to set timers with a meaningful time measurement. I’d also like to look into other styles, for example the circle fill emptying out (like a sand timer) at the rate of the timer or the halo of the vertex flashing slowly or more quickly as it moves to the end of the timer. Importantly, these elements should also be able to be paused and hooked into other update mechanisms, such that sliders or other interactive functionality can be used. Finally, I’m not sure how edges will interact with the timer halo, but it is also important to consider.\n","wordCount":"1331","inLanguage":"en","datePublished":"2016-11-04T10:30:29Z","dateModified":"2016-11-04T10:30:29Z","author":{"@type":"Person","name":"Benjamin Bengfort"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://bbengfort.github.io/2016/11/svg-timer-vertex/"},"publisher":{"@type":"Organization","name":"Libelli","logo":{"@type":"ImageObject","url":"https://bbengfort.github.io/favicon.ico"}}}</script></head><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme: #1d1e20;--entry: #2e2e33;--primary: rgba(255, 255, 255, 0.84);--secondary: rgba(255, 255, 255, 0.56);--tertiary: rgba(255, 255, 255, 0.16);--content: rgba(255, 255, 255, 0.74);--hljs-bg: #2e2e33;--code-bg: #37383e;--border: #333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://bbengfort.github.io accesskey=h title="Libelli (Alt + H)"><img src=/icon.png alt=logo aria-label=logo height=35>Libelli</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://bbengfort.github.io/archive/ title=archive><span>archive</span></a></li><li><a href=https://bbengfort.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://bbengfort.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://bbengfort.github.io/about/ title=about><span>about</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>SVG Vertex with a Timer</h1><div class=post-meta>November 4, 2016&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Benjamin Bengfort</div></header><div class=post-content><p>In order to promote the use of graph data structures for data analysis, I&rsquo;ve recently given talks on <a href=https://youtu.be/RgixxVpfXDY>dynamic graphs</a>: embedding time into graph structures to analyze change. In order to embed time into a graph there are two primary mechanisms: make time a graph element (a vertex or an edge) or have multiple subgraphs where each graph represents a discrete time step. By using either of these techniques, opportunities exist to perform a structural analysis using graph algorithms on time; for example - asking what time is most central to a particular set of relationships.</p><p>Graphs are primarily useful to simplify modeling and querying, but they are also useful for visual analytics. While visualizing static graphs with time embedded as a structure requires only standard graph techniques, visualizing dynamic graphs requires some sort of animation or interaction. We are currently exploring these techniques in the District Data Labs dynamic graphs research group. Towards that research, we are proposing to use D3 and SVG for interaction and visualization.</p><p>As time moves forward graph elements (vertices and edges) will change, either being added to the graph or removed from them. To support visual analytics, particularly with layouts that will change depending on the nodes that get added (like force directed layouts), these transitions must not be sudden, but instead give visual clues as to what&rsquo;s going on in the layout. The most obvious choice is to use opacity or size to fade in and out during the transition. However, this does not give the user any sense of how long the node has been on the screen, or how long it has left.</p><p>Therefore, I&rsquo;m interested in creating vertices that have timers associated with them. Inspired by <a href=https://raft.github.io/raftscope-replay/>raftscope</a>, I want to create vertices that have a timer that indicates how long they&rsquo;ve been on the screen. Here is my initial attempt:</p><style type=text/css>svg#timer-vertex{width:100%;height:120px}svg .vertex text{text-anchor:middle;dominant-baseline:central;text-align:center;fill:#fefefe}svg .vertex circle{fill:#003f87}svg .vertex path{fill:none;stroke:#cf0000}</style><svg id="timer-vertex"/><script src=https://code.jquery.com/jquery-3.1.1.slim.min.js integrity="sha256-/SIrNqv8h6QGKDuNoLGA4iret+kyesCkHGzVUUV0shc=" crossorigin=anonymous></script><script type=text/javascript>var SVG=function(tag){return $(document.createElementNS('http://www.w3.org/2000/svg',tag));};var ARC_WIDTH=6;function circleCoord(frac,cx,cy,r){var radians=2*Math.PI*(0.75+frac);return{x:cx+r*Math.cos(radians),y:cy+r*Math.sin(radians),};}
function arcSpec(spec,fraction){var radius=spec.r+ARC_WIDTH/2;var end=circleCoord(fraction,spec.cx,spec.cy,radius);var s=['M',spec.cx,',',spec.cy-radius];if(fraction>0.5){s.push('A',radius,',',radius,'0 0,1',spec.cx,spec.cy+radius);s.push('M',spec.cx,',',spec.cy+radius);}
s.push('A',radius,',',radius,'0 0,1',end.x,end.y);return s.join(' ');}
function updateArcTimer(elems,spec,current){var amt=current-0.015;if(amt<0){amt=1.0;}
elems.attr('d',arcSpec(spec,amt));setTimeout(function(){updateArcTimer(elems,spec,amt)},100);}
$(document).ready(function(){var svg=$("#timer-vertex");vertexSpec={cx:svg.width()/2,cy:svg.height()/2,r:36,}
svg.append(SVG('g').attr('id','vertex-1').attr('class','vertex').append(SVG('a').append(SVG('circle').attr('class','background').attr(vertexSpec)).append(SVG('path').attr('class','timer-arc').attr('style','stroke-width: '+ARC_WIDTH).attr('d',arcSpec(vertexSpec,1.0)))).append(SVG('text').attr('class','vlabel').text('v1').attr({x:vertexSpec.cx,y:vertexSpec.cy})));updateArcTimer($(".timer-arc"),vertexSpec,1.0);});</script><p>The code to do this uses JavaScript with jQuery as well as CSS but no other libraries. To make this work for graphs, we&rsquo;ll have to find a way to implement this vertex type in D3. But for now, we can just look what&rsquo;s happening.</p><p>First I added an SVG element to the body of my HTML:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html>&lt;<span style=color:#f92672>html</span>&gt;
    &lt;<span style=color:#f92672>head</span>&gt;
        &lt;<span style=color:#f92672>title</span>&gt;Vertex Timer Test&lt;/<span style=color:#f92672>title</span>&gt;
    &lt;/<span style=color:#f92672>head</span>&gt;
    &lt;<span style=color:#f92672>body</span>&gt;
        &lt;<span style=color:#f92672>svg</span> <span style=color:#a6e22e>id</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;timer-vertex&#34;</span>
             <span style=color:#a6e22e>xmlns</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;http://www.w3.org/2000/svg&#34;</span> <span style=color:#a6e22e>version</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;1.1&#34;</span>
             <span style=color:#a6e22e>xmlns:xlink</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;http://www.w3.org/1999/xlink&#34;</span>&gt;
        &lt;/<span style=color:#f92672>svg</span>&gt;
    &lt;/<span style=color:#f92672>body</span>&gt;
&lt;/<span style=color:#f92672>html</span>&gt;
</code></pre></div><p>Then add some simple styles with CSS so that you don&rsquo;t have to manually set them on every single element:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=color:#f92672>svg</span> {
    <span style=color:#66d9ef>width</span>: <span style=color:#ae81ff>100</span><span style=color:#66d9ef>%</span>;
    <span style=color:#66d9ef>height</span>: <span style=color:#ae81ff>120</span><span style=color:#66d9ef>px</span>;
}

<span style=color:#f92672>svg</span> .<span style=color:#a6e22e>vertex</span> <span style=color:#f92672>text</span> {
  text-anchor: <span style=color:#66d9ef>middle</span>;
  <span style=color:#66d9ef>dominant-baseline</span>: central;
  <span style=color:#66d9ef>text-align</span>: <span style=color:#66d9ef>center</span>;
  fill: <span style=color:#ae81ff>#FEFEFE</span>;
}

<span style=color:#f92672>svg</span> .<span style=color:#a6e22e>vertex</span> <span style=color:#f92672>circle</span> {
    fill: <span style=color:#ae81ff>#003F87</span>;
}

<span style=color:#f92672>svg</span> .<span style=color:#a6e22e>vertex</span> <span style=color:#f92672>path</span> {
  fill: <span style=color:#66d9ef>none</span>;
  stroke: <span style=color:#ae81ff>#CF0000</span>;
}
</code></pre></div><p>For the rest of the work, we&rsquo;re going to manually add SVG elements with JavaScript, updating their attributes with computed values. To make this easier, a simple function will allow us to create SVG elements in the correct namespace:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>SVG</span>(<span style=color:#a6e22e>tag</span>) {
    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ns</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;http://www.w3.org/2000/svg&#39;</span>;
    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>$</span>(document.<span style=color:#a6e22e>createElementNS</span>(<span style=color:#a6e22e>ns</span>, <span style=color:#a6e22e>tag</span>));
}
</code></pre></div><p>We can now use this function to quickly create the elements of our vertex: the circle representing the node, the text representing the label, and the arc representing the timer. First, let&rsquo;s find the center of the SVG so that we know where to place the vertex, and define other properties like its radius.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#75715e>// Set the constant arc width
</span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ARC_WIDTH</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>6</span>;

<span style=color:#75715e>// Select the svg to place the vertex into
</span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>svg</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>$</span>(<span style=color:#e6db74>&#34;#timer-vertex&#34;</span>);

<span style=color:#75715e>// Define the vertex center point and radius
</span><span style=color:#75715e></span><span style=color:#a6e22e>vertexSpec</span> <span style=color:#f92672>=</span> {
    <span style=color:#a6e22e>cx</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>svg</span>.<span style=color:#a6e22e>width</span>() <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>,
    <span style=color:#a6e22e>cy</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>svg</span>.<span style=color:#a6e22e>height</span>() <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>,
    <span style=color:#a6e22e>r</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>30</span>,
}
</code></pre></div><p>Before we can add all of the elements, we need to define the method by which we create the arc. To do this we&rsquo;re going to create a <code>path</code> that <a href=https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths#Arcs>follows an arc</a>. Creating paths with SVG means defining a <code>d</code> attribute, which contains a series of commands and parameters that define the shape of the path. The first command is the &ldquo;move to&rdquo; command, <code>M</code>, that specifies where the path begins, e.g. <code>M50 210</code> places a point at the coordinates <code>(50, 210)</code>. We then define the arc with the <code>A</code> command. The <code>A</code> command is complex, you have to define the x and y radius, axis rotation, sweep flags and an endpoint. However, it is powerful.</p><p>In the next snippet we will use the <code>arcSpec</code> function to create the <code>d</code> attribute for our path. It returns a string from the spec defining the vertex (the center and radius) as well as the fraction of the circle we want represented on the arc. It also uses another helper function, <code>circleCoord</code> to determine where points around the circle are located.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>circleCoord</span>(<span style=color:#a6e22e>frac</span>, <span style=color:#a6e22e>cx</span>, <span style=color:#a6e22e>cy</span>, <span style=color:#a6e22e>r</span>) {
    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>radians</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> Math.<span style=color:#a6e22e>PI</span> <span style=color:#f92672>*</span> (<span style=color:#ae81ff>0.75</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>frac</span>);
    <span style=color:#66d9ef>return</span> {
        <span style=color:#a6e22e>x</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>cx</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span> Math.<span style=color:#a6e22e>cos</span>(<span style=color:#a6e22e>radians</span>),
        <span style=color:#a6e22e>y</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>cy</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span> Math.<span style=color:#a6e22e>sin</span>(<span style=color:#a6e22e>radians</span>),
    };
}

<span style=color:#66d9ef>function</span> <span style=color:#a6e22e>arcSpec</span>(<span style=color:#a6e22e>spec</span>, <span style=color:#a6e22e>fraction</span>) {
    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>radius</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>spec</span>.<span style=color:#a6e22e>r</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>ARC_WIDTH</span><span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>;
    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>end</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>circleCoord</span>(<span style=color:#a6e22e>fraction</span>, <span style=color:#a6e22e>spec</span>.<span style=color:#a6e22e>cx</span>, <span style=color:#a6e22e>spec</span>.<span style=color:#a6e22e>cy</span>, <span style=color:#a6e22e>radius</span>);
    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>s</span> <span style=color:#f92672>=</span> [<span style=color:#e6db74>&#39;M&#39;</span>, <span style=color:#a6e22e>spec</span>.<span style=color:#a6e22e>cx</span>, <span style=color:#e6db74>&#39;,&#39;</span>, <span style=color:#a6e22e>spec</span>.<span style=color:#a6e22e>cy</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>radius</span>];

    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>fraction</span> <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0.5</span>) {
        <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>push</span>(<span style=color:#e6db74>&#39;A&#39;</span>, <span style=color:#a6e22e>radius</span>, <span style=color:#e6db74>&#39;,&#39;</span>, <span style=color:#a6e22e>radius</span>, <span style=color:#e6db74>&#39;0 0,1&#39;</span>, <span style=color:#a6e22e>spec</span>.<span style=color:#a6e22e>cx</span>, <span style=color:#a6e22e>spec</span>.<span style=color:#a6e22e>cy</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>radius</span>);
        <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>push</span>(<span style=color:#e6db74>&#39;M&#39;</span>, <span style=color:#a6e22e>spec</span>.<span style=color:#a6e22e>cx</span>, <span style=color:#e6db74>&#39;,&#39;</span>, <span style=color:#a6e22e>spec</span>.<span style=color:#a6e22e>cy</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>radius</span>);
    }
    <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>push</span>(<span style=color:#e6db74>&#39;A&#39;</span>, <span style=color:#a6e22e>radius</span>, <span style=color:#e6db74>&#39;,&#39;</span>, <span style=color:#a6e22e>radius</span>, <span style=color:#e6db74>&#39;0 0,1&#39;</span>, <span style=color:#a6e22e>end</span>.<span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>end</span>.<span style=color:#a6e22e>y</span>);
    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>join</span>(<span style=color:#e6db74>&#39; &#39;</span>);
}
</code></pre></div><p>Now that we have these two helper functions in place, we can finally define our elements:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#a6e22e>svg</span>.<span style=color:#a6e22e>append</span>(
    <span style=color:#a6e22e>SVG</span>(<span style=color:#e6db74>&#39;g&#39;</span>)
        .<span style=color:#a6e22e>attr</span>(<span style=color:#e6db74>&#39;id&#39;</span>, <span style=color:#e6db74>&#39;vertex-1&#39;</span>)
        .<span style=color:#a6e22e>attr</span>(<span style=color:#e6db74>&#39;class&#39;</span>, <span style=color:#e6db74>&#39;vertex&#39;</span>)
        .<span style=color:#a6e22e>append</span>(<span style=color:#a6e22e>SVG</span>(<span style=color:#e6db74>&#39;a&#39;</span>)
            .<span style=color:#a6e22e>append</span>(<span style=color:#a6e22e>SVG</span>(<span style=color:#e6db74>&#39;circle&#39;</span>)
                        .<span style=color:#a6e22e>attr</span>(<span style=color:#e6db74>&#39;class&#39;</span>, <span style=color:#e6db74>&#39;background&#39;</span>)
                        .<span style=color:#a6e22e>attr</span>(<span style=color:#a6e22e>vertexSpec</span>))
            .<span style=color:#a6e22e>append</span>(<span style=color:#a6e22e>SVG</span>(<span style=color:#e6db74>&#39;path&#39;</span>)
                        .<span style=color:#a6e22e>attr</span>(<span style=color:#e6db74>&#39;class&#39;</span>, <span style=color:#e6db74>&#39;timer-arc&#39;</span>)
                        .<span style=color:#a6e22e>attr</span>(<span style=color:#e6db74>&#39;style&#39;</span>, <span style=color:#e6db74>&#39;stroke-width: &#39;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>ARC_WIDTH</span>)
                        .<span style=color:#a6e22e>attr</span>(<span style=color:#e6db74>&#39;d&#39;</span>, <span style=color:#a6e22e>arcSpec</span>(<span style=color:#a6e22e>vertexSpec</span>, <span style=color:#ae81ff>1.0</span>)))
        )
        .<span style=color:#a6e22e>append</span>(<span style=color:#a6e22e>SVG</span>(<span style=color:#e6db74>&#39;text&#39;</span>)
                    .<span style=color:#a6e22e>attr</span>(<span style=color:#e6db74>&#39;class&#39;</span>, <span style=color:#e6db74>&#39;vlabel&#39;</span>)
                    .<span style=color:#a6e22e>text</span>(<span style=color:#e6db74>&#39;v1&#39;</span>)
                    .<span style=color:#a6e22e>attr</span>({<span style=color:#a6e22e>x</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>vertexSpec</span>.<span style=color:#a6e22e>cx</span>, <span style=color:#a6e22e>y</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>vertexSpec</span>.<span style=color:#a6e22e>cy</span>}))
);
</code></pre></div><p>This is simply a matter of appending various SVG elements together to create the group of shapes that together make up the vertex.</p><p>Now to animate, I&rsquo;ll simply recompute the path of the ARC for a smaller fraction of the vertex at each time step. To do this I&rsquo;ll use a function that updates the path, then uses <code>setTimeout</code> to schedule the next update once it&rsquo;s complete:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>updateArcTimer</span>(<span style=color:#a6e22e>elems</span>, <span style=color:#a6e22e>spec</span>, <span style=color:#a6e22e>current</span>) {
    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>amt</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>current</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>0.015</span>;
    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>amt</span> <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
        <span style=color:#a6e22e>amt</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1.0</span>;
    }

    <span style=color:#a6e22e>elems</span>.<span style=color:#a6e22e>attr</span>(<span style=color:#e6db74>&#39;d&#39;</span>, <span style=color:#a6e22e>arcSpec</span>(<span style=color:#a6e22e>spec</span>, <span style=color:#a6e22e>amt</span>));
    <span style=color:#a6e22e>setTimeout</span>(<span style=color:#66d9ef>function</span>() { <span style=color:#a6e22e>updateArcTimer</span>(<span style=color:#a6e22e>elems</span>, <span style=color:#a6e22e>spec</span>, <span style=color:#a6e22e>amt</span>) }, <span style=color:#ae81ff>100</span>);
}
</code></pre></div><p>Playing around with the delay between update (100 ms in this example) and the amount of the arc to reduce (0.015 in this example) changes how fast and smooth the timer is. However, making it too granular can cause weird jitters and artifacts to appear. Kick this function off right after creating the vertex as follows:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#a6e22e>updateArcTimer</span>(<span style=color:#a6e22e>$</span>(<span style=color:#e6db74>&#34;.timer-arc&#34;</span>), <span style=color:#a6e22e>vertexSpec</span>, <span style=color:#ae81ff>1.0</span>);
</code></pre></div><p>Future work for this project will be to implement this style vertex with D3, and the ability to set timers with a meaningful time measurement. I&rsquo;d also like to look into other styles, for example the circle fill emptying out (like a sand timer) at the rate of the timer or the halo of the vertex flashing slowly or more quickly as it moves to the end of the timer. Importantly, these elements should also be able to be paused and hooked into other update mechanisms, such that sliders or other interactive functionality can be used. Finally, I&rsquo;m not sure how edges will interact with the timer halo, but it is also important to consider.</p></div><footer class=post-footer></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://bbengfort.github.io>Libelli</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById('menu')
menu.scrollLeft=localStorage.getItem("menu-scroll-position");menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft);}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);if(!window.matchMedia('(prefers-reduced-motion: reduce)').matches){document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});}else{document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();}
if(id==="top"){history.replaceState(null,null," ");}else{history.pushState(null,null,`#${id}`);}});});</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script></body></html>