<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Message Latency: Ping vs. gRPC | Libelli</title><meta name=keywords content><meta name=description content="Building distributed systems means passing messages between devices over a network connection. My research specifically considers networks that have extremely variable latencies or that can be partition prone. This led me to the natural question, “how variable are real world networks?” In order to get real numbers, I built a simple echo protocol using Go and gRPC called Orca.
I ran Orca for a few days and got some latency measurements as I traveled around with my laptop."><meta name=author content="Benjamin Bengfort"><link rel=canonical href=https://bbengfort.github.io/2016/11/ping-vs-grpc/><link crossorigin=anonymous href=/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe+FVUFzPh7U=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://bbengfort.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://bbengfort.github.io/icon.png><link rel=icon type=image/png sizes=32x32 href=https://bbengfort.github.io/icon.png><link rel=apple-touch-icon href=https://bbengfort.github.io/apple-touch-icon-precomposed.png><link rel=mask-icon href=https://bbengfort.github.io/icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-D3BE7EHHVP"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-D3BE7EHHVP",{anonymize_ip:!1})}</script><meta property="og:title" content="Message Latency: Ping vs. gRPC"><meta property="og:description" content="Building distributed systems means passing messages between devices over a network connection. My research specifically considers networks that have extremely variable latencies or that can be partition prone. This led me to the natural question, “how variable are real world networks?” In order to get real numbers, I built a simple echo protocol using Go and gRPC called Orca.
I ran Orca for a few days and got some latency measurements as I traveled around with my laptop."><meta property="og:type" content="article"><meta property="og:url" content="https://bbengfort.github.io/2016/11/ping-vs-grpc/"><meta property="og:image" content="https://bbengfort.github.io/bear.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2016-11-02T15:46:31+00:00"><meta property="article:modified_time" content="2016-11-02T15:46:31+00:00"><meta property="og:site_name" content="Libelli"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://bbengfort.github.io/bear.png"><meta name=twitter:title content="Message Latency: Ping vs. gRPC"><meta name=twitter:description content="Building distributed systems means passing messages between devices over a network connection. My research specifically considers networks that have extremely variable latencies or that can be partition prone. This led me to the natural question, “how variable are real world networks?” In order to get real numbers, I built a simple echo protocol using Go and gRPC called Orca.
I ran Orca for a few days and got some latency measurements as I traveled around with my laptop."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://bbengfort.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Message Latency: Ping vs. gRPC","item":"https://bbengfort.github.io/2016/11/ping-vs-grpc/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Message Latency: Ping vs. gRPC","name":"Message Latency: Ping vs. gRPC","description":"Building distributed systems means passing messages between devices over a network connection. My research specifically considers networks that have extremely variable latencies or that can be partition prone. This led me to the natural question, “how variable are real world networks?” In order to get real numbers, I built a simple echo protocol using Go and gRPC called Orca.\nI ran Orca for a few days and got some latency measurements as I traveled around with my laptop.","keywords":[],"articleBody":"Building distributed systems means passing messages between devices over a network connection. My research specifically considers networks that have extremely variable latencies or that can be partition prone. This led me to the natural question, “how variable are real world networks?” In order to get real numbers, I built a simple echo protocol using Go and gRPC called Orca.\nI ran Orca for a few days and got some latency measurements as I traveled around with my laptop. Orca does a lot of work, including GeoIP look ups, IP address resolution, and database queries and storage. This post, however, is not about Orca. The latencies I was getting were very high relative to the round-trip latencies reported by the simple ping command that implements the ICMP protocol.\nAt first, I attributed this difference to the database overhead, but it was still far too high. In order to measure the difference between ping and the echo protocol I implemented, I created a branch that strips everything except the communications protocol: a protocol buffers service implemented with gRPC. I believe there are two potential places that introduce the overhead, either in the gRPC communications protocol or in Go itself, for example the garbage collector.\nExperiment To see how much of a difference there is in the overhead of the Go implementation, I simultaneously ran both ping and orca from my house to a server at the University for an hour. I collected slightly under 3600 round-trip latencies (RTTs) for each (there were a few dropped packets). The result was that, on average, ping is approximately 16.384 ms faster than the gRPC protocol, and less variable by 4.933 ms! The variability might be explained by language-specific elements like garbage collection and threading, but the ease of use of protocol buffers comes at a cost!\nThe results of the two pings are as follows:\nThis above figure shows a box plot of the dataset with outliers trimmed using the z-score method and 2 passes. The ends of the bar represent the 5th and 95th percentile respectively, and data points outside the 95th percentile are plotted individually. The box goes from the first to the third quartile and the middle line is the median. As you can see from this plot, there is no overlap from the high percentile of the ping protocol to the lower percentile of the echo protocol. Moreover, the majority of the ping points are in a much smaller range than the majority of the echo protocol points.\nThis second image shows the violin plot - such that the curve represents the kernel density estimate (KDE) of the histogram of the data. It then similarly shows the median and the first and third quartiles inside of the violin. Both distributions are significantly right skewed, but the ping distribution has a much steeper curve than the more variable echo protocol.\nHere are the raw statistics for the small experiment:\n|——-|———–|———–|\nping echo count 3,567 3,538 mean 13.037 ms 29.431 ms std 1.877 ms 2.908 ms min 10.616 ms 23.806 ms 25% 12.169 ms 27.366 ms 50% 12.747 ms 28.989 ms 75% 13.422 ms 31.016 ms max 42.806 ms 49.039 ms :—— ———– ———– So what does this mean? Of course, I could do extensive experimentation, moving the laptop and getting different times of day for latency measurements. However, I honestly believe that the one hour test was enough to demonstrate how significant a gap there is between the ping implementation and a gRPC implementation of the communications. In normal systems there will always be some message processing overhead and database accesses, however right off the bat you do incur a significant overhead.\nMethod To run the experiment to collect data for comparison (and as documentation in case I have to do this again), I did it as follows. First clone the orca repository:\n$ go get github.com/bbengfort/orca/... You’ll then have to cd into that directory, which is in your $GOHOME/src location. Checkout the ping branch as follows:\n$ git fetch $ git checkout ping You should see a pretty significant change in the amount of code and the README should indicate you’re in the ping branch. Set up a server to listen for the ping requests:\n$ go run cmd/orca listen If you want, you can run it in silent mode with the -s flag to further reduce latency as much as possible. In silent mode, the command prints nothing to the console. Then run 3600 pings on a different machine as follows:\n$ go run cmd/orca -n 3600 ping 1.2.3.4:3265 Make sure you insert the correct IP address and port! As quickly as you can, also start the ping service:\n$ ping -c 3600 1.2.3.4 After about an hour, the dataset is sitting at your disposal ready to copy and paste into a text file. You can use the ping_vs_echo.ipynb Jupyter Notebook to perform the analysis. It includes regular expressions to parse each type of line output and to aggregate them into the visualizations you saw above.\nLocal Subnet There are many reasons that ping could be faster than gRPC, not just the overhead of serializing and deserializing protocol buffers and HTTP transport. For example, ICMP could be given special routing, ICMP is handled closer to the kernel level, or the fact that ICMP frames are much, much smaller. In order to test this I ran the test from two machines on the same subnet; the violin plot for the distribution is below:\nBoth ping and echo latencies are much smaller, by approximately the same amount. Because the gap between them is approximately the same percentage (though not fixed), I think this graph identifies clearly what is overhead and what is network latency. However, because the gap is also smaller, it shows that bandwidth and other message traffic may be having an influence in the disparity as well (e.g. that ping has preferential routes through wide area networks).\n","wordCount":"987","inLanguage":"en","datePublished":"2016-11-02T15:46:31Z","dateModified":"2016-11-02T15:46:31Z","author":{"@type":"Person","name":"Benjamin Bengfort"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://bbengfort.github.io/2016/11/ping-vs-grpc/"},"publisher":{"@type":"Organization","name":"Libelli","logo":{"@type":"ImageObject","url":"https://bbengfort.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bbengfort.github.io accesskey=h title="Libelli (Alt + H)"><img src=https://bbengfort.github.io/icon.png alt aria-label=logo height=35>Libelli</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://bbengfort.github.io/archive/ title=archive><span>archive</span></a></li><li><a href=https://bbengfort.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://bbengfort.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://bbengfort.github.io/about/ title=about><span>about</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://bbengfort.github.io>Home</a>&nbsp;»&nbsp;<a href=https://bbengfort.github.io/posts/>Posts</a></div><h1 class=post-title>Message Latency: Ping vs. gRPC</h1><div class=post-meta><span title='2016-11-02 15:46:31 +0000 UTC'>November 2, 2016</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;987 words&nbsp;·&nbsp;Benjamin Bengfort&nbsp;|&nbsp;<a href=https://github.com/bbengfort/bbengfort.github.io/tree/main/content/posts/2016-11-02-ping-vs-grpc.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>Building distributed systems means passing messages between devices over a network connection. My research specifically considers networks that have extremely variable latencies or that can be partition prone. This led me to the natural question, “how variable are real world networks?” In order to get real numbers, I built a simple echo protocol using Go and gRPC called <a href=https://github.com/bbengfort/orca>Orca</a>.</p><p>I ran Orca for a few days and got some latency measurements as I traveled around with my laptop. Orca does a lot of work, including GeoIP look ups, IP address resolution, and database queries and storage. This post, however, is not about Orca. The latencies I was getting were very high relative to the round-trip latencies reported by the simple <code>ping</code> command that implements the <a href=https://en.wikipedia.org/wiki/Internet_Control_Message_Protocol>ICMP protocol</a>.</p><p>At first, I attributed this difference to the database overhead, but it was still far too high. In order to measure the difference between <code>ping</code> and the echo protocol I implemented, I created a <a href=https://github.com/bbengfort/orca/tree/ping>branch</a> that strips everything except the communications protocol: <a href=https://developers.google.com/protocol-buffers/docs/proto3#services>a protocol buffers service</a> implemented with <a href=https://github.com/grpc/grpc>gRPC</a>. I believe there are two potential places that introduce the overhead, either in the gRPC communications protocol or in Go itself, for example the garbage collector.</p><h2 id=experiment>Experiment<a hidden class=anchor aria-hidden=true href=#experiment>#</a></h2><p>To see how much of a difference there is in the overhead of the Go implementation, I simultaneously ran both <code>ping</code> and <code>orca</code> from my house to a server at the University for an hour. I collected slightly under 3600 round-trip latencies (RTTs) for each (there were a few dropped packets). The result was that, on average, ping is approximately 16.384 ms <em>faster</em> than the gRPC protocol, and less variable by 4.933 ms! The variability might be explained by language-specific elements like garbage collection and threading,
but the ease of use of protocol buffers comes at a cost!</p><p>The results of the two pings are as follows:</p><p><img loading=lazy src=/images/2016-11-02-ping-vs-echo-boxplot.png alt="Range of Latencies"></p><p>This above figure shows a box plot of the dataset with outliers trimmed using the z-score method and 2 passes. The ends of the bar represent the 5th and 95th percentile respectively, and data points outside the 95th percentile are plotted individually. The box goes from the first to the third quartile and the middle line is the median. As you can see from this plot, there is no overlap from the high percentile of the ping protocol to the lower percentile of the echo protocol. Moreover, the majority of the ping points are in a much smaller range than the majority of the echo protocol points.</p><p><img loading=lazy src=/images/2016-11-02-ping-vs-echo-violinplot.png alt="Distribution of Latencies"></p><p>This second image shows the violin plot - such that the curve represents the kernel density estimate (KDE) of the histogram of the data. It then similarly shows the median and the first and third quartiles inside of the violin. Both distributions are significantly right skewed, but the ping distribution has a much steeper curve than the more variable echo protocol.</p><p>Here are the raw statistics for the small experiment:</p><p>|&mdash;&mdash;-|&mdash;&mdash;&mdash;&ndash;|&mdash;&mdash;&mdash;&ndash;|</p><table><thead><tr><th style=text-align:center></th><th style=text-align:center>ping</th><th style=text-align:center>echo</th></tr></thead><tbody><tr><td style=text-align:center>count</td><td style=text-align:center>3,567</td><td style=text-align:center>3,538</td></tr><tr><td style=text-align:center>mean</td><td style=text-align:center>13.037 ms</td><td style=text-align:center>29.431 ms</td></tr><tr><td style=text-align:center>std</td><td style=text-align:center>1.877 ms</td><td style=text-align:center>2.908 ms</td></tr><tr><td style=text-align:center>min</td><td style=text-align:center>10.616 ms</td><td style=text-align:center>23.806 ms</td></tr><tr><td style=text-align:center>25%</td><td style=text-align:center>12.169 ms</td><td style=text-align:center>27.366 ms</td></tr><tr><td style=text-align:center>50%</td><td style=text-align:center>12.747 ms</td><td style=text-align:center>28.989 ms</td></tr><tr><td style=text-align:center>75%</td><td style=text-align:center>13.422 ms</td><td style=text-align:center>31.016 ms</td></tr><tr><td style=text-align:center>max</td><td style=text-align:center>42.806 ms</td><td style=text-align:center>49.039 ms</td></tr><tr><td style=text-align:center>:&mdash;&mdash;</td><td style=text-align:center>&mdash;&mdash;&mdash;&ndash;</td><td style=text-align:center>&mdash;&mdash;&mdash;&ndash;</td></tr></tbody></table><p>So what does this mean? Of course, I could do extensive experimentation, moving the laptop and getting different times of day for latency measurements. However, I honestly believe that the one hour test was enough to demonstrate how significant a gap there is between the ping implementation and a gRPC implementation of the communications. In normal systems there will always be some message processing overhead and database accesses, however right off the bat you do incur a significant overhead.</p><h2 id=method>Method<a hidden class=anchor aria-hidden=true href=#method>#</a></h2><p>To run the experiment to collect data for comparison (and as documentation in case I have to do this again), I did it as follows. First clone the orca repository:</p><pre><code>$ go get github.com/bbengfort/orca/...
</code></pre><p>You&rsquo;ll then have to <code>cd</code> into that directory, which is in your <code>$GOHOME/src</code> location. Checkout the ping branch as follows:</p><pre><code>$ git fetch
$ git checkout ping
</code></pre><p>You should see a pretty significant change in the amount of code and the README should indicate you&rsquo;re in the <code>ping</code> branch. Set up a server to listen for the ping requests:</p><pre><code>$ go run cmd/orca listen
</code></pre><p>If you want, you can run it in silent mode with the <code>-s</code> flag to further reduce latency as much as possible. In silent mode, the command prints nothing to the console. Then run 3600 pings on a different machine as follows:</p><pre><code>$ go run cmd/orca -n 3600 ping 1.2.3.4:3265
</code></pre><p>Make sure you insert the correct IP address and port! As quickly as you can, also start the ping service:</p><pre><code>$ ping -c 3600 1.2.3.4
</code></pre><p>After about an hour, the dataset is sitting at your disposal ready to copy and paste into a text file. You can use the <a href=https://github.com/bbengfort/orca-analysis/blob/master/notebooks/ping_vs_echo.ipynb>ping_vs_echo.ipynb</a> Jupyter Notebook to perform the analysis. It includes regular expressions to parse each type of line output and to aggregate them into the visualizations you saw above.</p><h2 id=local-subnet>Local Subnet<a hidden class=anchor aria-hidden=true href=#local-subnet>#</a></h2><p>There are many reasons that ping could be faster than gRPC, not just the overhead of serializing and deserializing protocol buffers and HTTP transport. For example, ICMP could be given special routing, ICMP is handled closer to the kernel level, or the fact that ICMP frames are much, much smaller. In order to test this I ran the test from two machines on the same subnet; the violin plot for the distribution is below:</p><p><img loading=lazy src=/images/2016-11-02-ping-vs-echo-local-violinplot.png alt="Local Area Distribution"></p><p>Both ping and echo latencies are much smaller, by approximately the same amount. Because the gap between them is approximately the same percentage (though not fixed), I think this graph identifies clearly what is overhead and what is network latency. However, because the gap is also smaller, it shows that bandwidth and other message traffic may be having an influence in the disparity as well (e.g. that ping has preferential routes through wide area networks).</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://bbengfort.github.io/2016/11/svg-timer-vertex/><span class=title>« Prev</span><br><span>SVG Vertex with a Timer</span></a>
<a class=next href=https://bbengfort.github.io/2016/10/reading-speed/><span class=title>Next »</span><br><span>Computing Reading Speed</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://bbengfort.github.io>Libelli</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>