<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | Libelli</title>
<meta name=keywords content><meta name=description content="Posts - Libelli"><meta name=author content="Benjamin Bengfort"><link rel=canonical href=https://bbengfort.github.io/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://bbengfort.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://bbengfort.github.io/icon.png><link rel=icon type=image/png sizes=32x32 href=https://bbengfort.github.io/icon.png><link rel=apple-touch-icon href=https://bbengfort.github.io/apple-touch-icon-precomposed.png><link rel=mask-icon href=https://bbengfort.github.io/icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://bbengfort.github.io/posts/index.xml><link rel=alternate hreflang=en href=https://bbengfort.github.io/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-D3BE7EHHVP"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-D3BE7EHHVP")}</script><meta property="og:title" content="Posts"><meta property="og:description" content="The development journal of @bbengfort including notes and ramblings from his various programming activities."><meta property="og:type" content="website"><meta property="og:url" content="https://bbengfort.github.io/posts/"><meta property="og:image" content="https://bbengfort.github.io/bear.png"><meta property="og:site_name" content="Libelli"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://bbengfort.github.io/bear.png"><meta name=twitter:title content="Posts"><meta name=twitter:description content="The development journal of @bbengfort including notes and ramblings from his various programming activities."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://bbengfort.github.io/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bbengfort.github.io/ accesskey=h title="Libelli (Alt + H)"><img src=https://bbengfort.github.io/icon.png alt aria-label=logo height=35>Libelli</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://bbengfort.github.io/archive/ title=archive><span>archive</span></a></li><li><a href=https://bbengfort.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://bbengfort.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://bbengfort.github.io/about/ title=about><span>about</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://bbengfort.github.io/>Home</a></div><h1>Posts
<a href=/posts/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Contributing a Multiprocess Memory Profiler</h2></header><div class=entry-content><p>In this post I wanted to catalog the process of an open source contribution I was a part of, which added a feature to the memory profiler Python library by Fabian Pedregosa and Philippe Gervais. It’s a quick story to tell but took over a year to complete, and I learned a lot from the process. I hope that the story is revealing, particularly to first time contributors and shows that even folks that have been doing this for a long time still have to find ways to positively approach collaboration in an open source environment. I also think it’s a fairly standard example of how contributions work in practice and perhaps this story will help us all think about how to better approach the pull request process.
...</p></div><footer class=entry-footer><span title='2017-03-20 11:42:58 +0000 UTC'>March 20, 2017</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1409 words&nbsp;·&nbsp;Benjamin Bengfort</footer><a class=entry-link aria-label="post link to Contributing a Multiprocess Memory Profiler" href=https://bbengfort.github.io/2017/03/contributing-a-multiprocess-memory-profiler/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Pseudo Merkle Tree</h2></header><div class=entry-content><p>A Merkle tree is a data structure in which every non-leaf node is labeled with the hash of its child nodes. This makes them particular useful for comparing large data structures quickly and efficiently. Given trees a and b, if the root hash of either is different, it means that part of the tree below is different (if they are identical, they are probably also identical). You can then proceed in a a breadth first fashion, pruning nodes with identical hashes to directly identify the differences.
...</p></div><footer class=entry-footer><span title='2017-03-16 12:23:21 +0000 UTC'>March 16, 2017</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;485 words&nbsp;·&nbsp;Benjamin Bengfort</footer><a class=entry-link aria-label="post link to Pseudo Merkle Tree" href=https://bbengfort.github.io/2017/03/pseudo-merkle-tree/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Using Select in Go</h2></header><div class=entry-content><p>Ask a Go programmer what makes Go special and they will immediately say “concurrency is baked into the language”. Go’s concurrency model is one of communication (as opposed to locks) and so concurrency primitives are implemented using channels. In order to synchronize across multiple channels, go provides the select statement.
A common pattern for me has become to use a select to manage broadcasted work (either in a publisher/subscriber model or a fanout model) by initializing go routines and passing them directional channels for synchronization and communication. In the example below, I create a buffered channel for output (so that the workers don’t block waiting for the receiver to collect data), a channel for errors (first error kills the program) and a timer to update the state of my process on a routine basis. The select waits for the first channel to receive a message and then continues processing. By keeping the select in a for loop, I can continually read of the channels until I’m done.
...</p></div><footer class=entry-footer><span title='2017-03-08 10:52:39 +0000 UTC'>March 8, 2017</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;386 words&nbsp;·&nbsp;Benjamin Bengfort</footer><a class=entry-link aria-label="post link to Using Select in Go" href=https://bbengfort.github.io/2017/03/channel-select/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Benchmarking Secure gRPC</h2></header><div class=entry-content><p>A natural question to ask after the previous post is “how much overhead does security add?” So I’ve benchmarked the three methods discussed; mutual TLS, server-side TLS, and no encryption. The results are below:
Here are the numeric results for one of the runs:
BenchmarkMutualTLS-8 200 9331850 ns/op BenchmarkServerTLS-8 300 5004505 ns/op BenchmarkInsecure-8 2000 1179252 ns/op PASS ok github.com/bbengfort/sping 7.364s Here is the code for the benchmarking for reference:
...</p></div><footer class=entry-footer><span title='2017-03-05 17:26:24 +0000 UTC'>March 5, 2017</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;162 words&nbsp;·&nbsp;Benjamin Bengfort</footer><a class=entry-link aria-label="post link to Benchmarking Secure gRPC" href=https://bbengfort.github.io/2017/03/tls-grpc-benchmarks/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Secure gRPC with TLS/SSL</h2></header><div class=entry-content><p>One of the primary requirements for the systems we build is something we call the “minimum security requirement”. Although our systems are not designed specifically for high security applications, they must use minimum standards of encryption and authentication. For example, it seems obvious to me that a web application that stores passwords or credit card information would encrypt their data on disk on a per-record basis with a salted hash. In the same way, a distributed system must be able to handle encrypted blobs, encrypt all inter-node communication, and authenticate and sign all messages. This adds some overhead to the system but the cost of overhead is far smaller than the cost of a breach, and if minimum security is the baseline then the overhead is just an accepted part of doing business.
...</p></div><footer class=entry-footer><span title='2017-03-03 09:41:39 +0000 UTC'>March 3, 2017</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;2128 words&nbsp;·&nbsp;Benjamin Bengfort</footer><a class=entry-link aria-label="post link to Secure gRPC with TLS/SSL" href=https://bbengfort.github.io/2017/03/secure-grpc/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Synchronizing Structs for Safe Concurrency in Go</h2></header><div class=entry-content><p>Go is built for concurrency by providing language features that allow developers to embed complex concurrency patterns into their applications. These language features can be intuitive and a lot of safety is built in (for example a race detector) but developers still need to be aware of the interactions between various threads in their programs.
In any shared memory system the biggest concern is synchronization: ensuring that separate go routines operate in the correct order and that no race conditions occur. The primary way to handle synchronization is the use of channels. Channels synchronize execution by forcing sends on the channel to block until the value on the channel is received. In this way, channels act as a barrier since the go routine can not progress while being blocked by the channel and enforce a specific ordering to execution, the ordering of routines arriving at the barrier.
...</p></div><footer class=entry-footer><span title='2017-02-21 10:48:24 +0000 UTC'>February 21, 2017</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;852 words&nbsp;·&nbsp;Benjamin Bengfort</footer><a class=entry-link aria-label="post link to Synchronizing Structs for Safe Concurrency in Go" href=https://bbengfort.github.io/2017/02/synchronizing-structs/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Fixed vs. Variable Length Chunking</h2></header><div class=entry-content><p>FluidFS and other file systems break large files into recipes of hash-identified blobs of binary data. Blobs can then be replicated with far more ease than a single file, as well as streamed from disk in a memory safe manner. Blobs are treated as single, independent units so the underlying data store doesn’t grow as files are duplicated. Finally, blobs can be encrypted individually and provide more opportunities for privacy.
...</p></div><footer class=entry-footer><span title='2017-02-08 19:51:28 +0000 UTC'>February 8, 2017</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;443 words&nbsp;·&nbsp;Benjamin Bengfort</footer><a class=entry-link aria-label="post link to Fixed vs. Variable Length Chunking" href=https://bbengfort.github.io/2017/02/chunking/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://bbengfort.github.io/posts/page/8/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://bbengfort.github.io/posts/page/10/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2024 <a href=https://bbengfort.github.io/>Libelli</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>