<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Git-Style File Editing in CLI | Libelli</title>
<meta name=keywords content><meta name=description content="A recent application I was working on required the management of several configuration and list files that needed to be validated. Rather than have the user find and edit these files directly, I wanted to create an editing  workflow similar to crontab -e or git commit — the user would call the application, which would redirect to a text editor like vim, then when editing was complete, the application would take over again."><meta name=author content="Benjamin Bengfort"><link rel=canonical href=https://bbengfort.github.io/2018/01/cli-editor-app/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://bbengfort.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://bbengfort.github.io/icon.png><link rel=icon type=image/png sizes=32x32 href=https://bbengfort.github.io/icon.png><link rel=apple-touch-icon href=https://bbengfort.github.io/apple-touch-icon-precomposed.png><link rel=mask-icon href=https://bbengfort.github.io/icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://bbengfort.github.io/2018/01/cli-editor-app/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-D3BE7EHHVP"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-D3BE7EHHVP")}</script><meta property="og:title" content="Git-Style File Editing in CLI"><meta property="og:description" content="A recent application I was working on required the management of several configuration and list files that needed to be validated. Rather than have the user find and edit these files directly, I wanted to create an editing  workflow similar to crontab -e or git commit — the user would call the application, which would redirect to a text editor like vim, then when editing was complete, the application would take over again."><meta property="og:type" content="article"><meta property="og:url" content="https://bbengfort.github.io/2018/01/cli-editor-app/"><meta property="og:image" content="https://bbengfort.github.io/bear.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-01-06T09:30:58+00:00"><meta property="article:modified_time" content="2018-01-06T09:30:58+00:00"><meta property="og:site_name" content="Libelli"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://bbengfort.github.io/bear.png"><meta name=twitter:title content="Git-Style File Editing in CLI"><meta name=twitter:description content="A recent application I was working on required the management of several configuration and list files that needed to be validated. Rather than have the user find and edit these files directly, I wanted to create an editing  workflow similar to crontab -e or git commit — the user would call the application, which would redirect to a text editor like vim, then when editing was complete, the application would take over again."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://bbengfort.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Git-Style File Editing in CLI","item":"https://bbengfort.github.io/2018/01/cli-editor-app/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Git-Style File Editing in CLI","name":"Git-Style File Editing in CLI","description":"A recent application I was working on required the management of several configuration and list files that needed to be validated. Rather than have the user find and edit these files directly, I wanted to create an editing workflow similar to crontab -e or git commit — the user would call the application, which would redirect to a text editor like vim, then when editing was complete, the application would take over again.\n","keywords":[],"articleBody":"A recent application I was working on required the management of several configuration and list files that needed to be validated. Rather than have the user find and edit these files directly, I wanted to create an editing workflow similar to crontab -e or git commit — the user would call the application, which would redirect to a text editor like vim, then when editing was complete, the application would take over again.\nThis happened to be a Go app, so the following code is in Go, but it would work with any programming language. The workflow is as follows:\nFind an editor executable Copy the original to a temporary file Exec the editor on the temporary file Wait for the editor to be done Validate the temporary file Copy the temporary file to the original location This worked surprisingly well especially for things like YAML files which are structured enough to be validated easily, but human readable enough to edit.\nFirst up, finding an editor executable. I used a three part strategy; first the user could specify the path to an editor in the configuration file (like git), second, the user could set the $EDITOR environment variable, and third, I look for common editors. Here’s the code:\nvar editors = [4]string{\"vim\", \"emacs\", \"nano\"} func findEditor() (string, error) { config, err := LoadConfig() if err != nil { return \"\", err } if config.Editor != \"\" { return config.Editor, nil } if editor := os.Getenv(\"EDITOR\"); editor != \"\" { return editor, nil } for _, name := range editors { path, err := exec.LookPath(name) if err == nil { return path, nil } } return \"\", errors.New(\"no editor found\") } The crucial part of this is exec.LookPath which searches the $PATH for editor and returns the full path to exec it. Next up is copying the file:\nfunc copyFile(src, dst string) error { in, err := os.Open(src) if err != nil { return err } defer in.Close() out, err := os.Create(dst) if err != nil { return err } defer out.Close() if _, err = io.Copy(out, in); err != nil { return err } return nil } Finally the full editor workflow:\nfunc EditFile(path string) error { // Find the editor to use editor, err := findEditor() if err != nil { return err } // Create the temporary directory and ensure we clean up when done. tmpDir := os.TempDir() defer os.RemoveAll(tmpDir) // Get the temporary file location tmpFile := filepath.Join(tmpDir, filepath.Base(path)) // Copy the original file to the tmpFile if err = copyFile(path, tmpFile); err != nil { return err } // Create the editor command cmd := exec.Command(editor, tmpFile) cmd.Stdin = os.Stdin cmd.Stdout = os.Stdout cmd.Stderr = os.Stderr // Start the editor command and wait for it to finish if err = cmd.Start(); err != nil { return err } if err = cmd.Wait(); err != nil { return err } // Copy the tmp file back to the original file return copyFile(tmpFile, path) } This workflow assumes that the file being edited already exists, but of course you could modify it any number of ways. For example, you could use a template to populate the temporary file (similar to what git does for a commit message), or you could add more validation around input and output.\n","wordCount":"549","inLanguage":"en","image":"https://bbengfort.github.io/bear.png","datePublished":"2018-01-06T09:30:58Z","dateModified":"2018-01-06T09:30:58Z","author":{"@type":"Person","name":"Benjamin Bengfort"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://bbengfort.github.io/2018/01/cli-editor-app/"},"publisher":{"@type":"Organization","name":"Libelli","logo":{"@type":"ImageObject","url":"https://bbengfort.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bbengfort.github.io/ accesskey=h title="Libelli (Alt + H)"><img src=https://bbengfort.github.io/icon.png alt aria-label=logo height=35>Libelli</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://bbengfort.github.io/archive/ title=archive><span>archive</span></a></li><li><a href=https://bbengfort.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://bbengfort.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://bbengfort.github.io/about/ title=about><span>about</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://bbengfort.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://bbengfort.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Git-Style File Editing in CLI</h1><div class=post-meta><span title='2018-01-06 09:30:58 +0000 UTC'>January 6, 2018</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;549 words&nbsp;·&nbsp;Benjamin Bengfort&nbsp;|&nbsp;<a href=https://github.com/bbengfort/bbengfort.github.io/tree/main/content/posts/2018-01-06-cli-editor-app.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>A recent application I was working on required the management of several configuration and list files that needed to be validated. Rather than have the user find and edit these files directly, I wanted to create an editing workflow similar to <code>crontab -e</code> or <code>git commit</code> — the user would call the application, which would redirect to a text editor like vim, then when editing was complete, the application would take over again.</p><p>This happened to be a Go app, so the following code is in Go, but it would work with any programming language. The workflow is as follows:</p><ol><li>Find an editor executable</li><li>Copy the original to a temporary file</li><li>Exec the editor on the temporary file</li><li>Wait for the editor to be done</li><li>Validate the temporary file</li><li>Copy the temporary file to the original location</li></ol><p>This worked surprisingly well especially for things like YAML files which are structured enough to be validated easily, but human readable enough to edit.</p><p>First up, finding an editor executable. I used a three part strategy; first the user could specify the path to an editor in the configuration file (like git), second, the user could set the <code>$EDITOR</code> environment variable, and third, I look for common editors. Here&rsquo;s the code:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>editors</span> <span class=p>=</span> <span class=p>[</span><span class=mi>4</span><span class=p>]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;vim&#34;</span><span class=p>,</span> <span class=s>&#34;emacs&#34;</span><span class=p>,</span> <span class=s>&#34;nano&#34;</span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>findEditor</span><span class=p>()</span> <span class=p>(</span><span class=kt>string</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>config</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nf>LoadConfig</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=s>&#34;&#34;</span><span class=p>,</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>config</span><span class=p>.</span><span class=nx>Editor</span> <span class=o>!=</span> <span class=s>&#34;&#34;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>config</span><span class=p>.</span><span class=nx>Editor</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>editor</span> <span class=o>:=</span> <span class=nx>os</span><span class=p>.</span><span class=nf>Getenv</span><span class=p>(</span><span class=s>&#34;EDITOR&#34;</span><span class=p>);</span> <span class=nx>editor</span> <span class=o>!=</span> <span class=s>&#34;&#34;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>editor</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>name</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>editors</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>path</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>exec</span><span class=p>.</span><span class=nf>LookPath</span><span class=p>(</span><span class=nx>name</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>err</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=nx>path</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=s>&#34;&#34;</span><span class=p>,</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=s>&#34;no editor found&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The crucial part of this is <code>exec.LookPath</code> which searches the <code>$PATH</code> for editor and returns the full path to exec it. Next up is copying the file:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>copyFile</span><span class=p>(</span><span class=nx>src</span><span class=p>,</span> <span class=nx>dst</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>in</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>os</span><span class=p>.</span><span class=nf>Open</span><span class=p>(</span><span class=nx>src</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=nx>in</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>out</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>os</span><span class=p>.</span><span class=nf>Create</span><span class=p>(</span><span class=nx>dst</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=nx>out</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=p>=</span> <span class=nx>io</span><span class=p>.</span><span class=nf>Copy</span><span class=p>(</span><span class=nx>out</span><span class=p>,</span> <span class=nx>in</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Finally the full editor workflow:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>EditFile</span><span class=p>(</span><span class=nx>path</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// Find the editor to use
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>editor</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nf>findEditor</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Create the temporary directory and ensure we clean up when done.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>tmpDir</span> <span class=o>:=</span> <span class=nx>os</span><span class=p>.</span><span class=nf>TempDir</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=nx>os</span><span class=p>.</span><span class=nf>RemoveAll</span><span class=p>(</span><span class=nx>tmpDir</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Get the temporary file location
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>tmpFile</span> <span class=o>:=</span> <span class=nx>filepath</span><span class=p>.</span><span class=nf>Join</span><span class=p>(</span><span class=nx>tmpDir</span><span class=p>,</span> <span class=nx>filepath</span><span class=p>.</span><span class=nf>Base</span><span class=p>(</span><span class=nx>path</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Copy the original file to the tmpFile
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>err</span> <span class=p>=</span> <span class=nf>copyFile</span><span class=p>(</span><span class=nx>path</span><span class=p>,</span> <span class=nx>tmpFile</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Create the editor command
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>cmd</span> <span class=o>:=</span> <span class=nx>exec</span><span class=p>.</span><span class=nf>Command</span><span class=p>(</span><span class=nx>editor</span><span class=p>,</span> <span class=nx>tmpFile</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>cmd</span><span class=p>.</span><span class=nx>Stdin</span> <span class=p>=</span> <span class=nx>os</span><span class=p>.</span><span class=nx>Stdin</span>
</span></span><span class=line><span class=cl>	<span class=nx>cmd</span><span class=p>.</span><span class=nx>Stdout</span> <span class=p>=</span> <span class=nx>os</span><span class=p>.</span><span class=nx>Stdout</span>
</span></span><span class=line><span class=cl>	<span class=nx>cmd</span><span class=p>.</span><span class=nx>Stderr</span> <span class=p>=</span> <span class=nx>os</span><span class=p>.</span><span class=nx>Stderr</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Start the editor command and wait for it to finish
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=nx>err</span> <span class=p>=</span> <span class=nx>cmd</span><span class=p>.</span><span class=nf>Start</span><span class=p>();</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=p>=</span> <span class=nx>cmd</span><span class=p>.</span><span class=nf>Wait</span><span class=p>();</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// Copy the tmp file back to the original file
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>return</span> <span class=nf>copyFile</span><span class=p>(</span><span class=nx>tmpFile</span><span class=p>,</span> <span class=nx>path</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This workflow assumes that the file being edited already exists, but of course you could modify it any number of ways. For example, you could use a template to populate the temporary file (similar to what git does for a commit message), or you could add more validation around input and output.</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://bbengfort.github.io/2018/01/go-set/><span class=title>« Prev</span><br><span>Thread and Non-Thread Safe Go Set</span>
</a><a class=next href=https://bbengfort.github.io/2017/12/psycopg2-transactions/><span class=title>Next »</span><br><span>Transaction Handling with Psycopg2</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://bbengfort.github.io/>Libelli</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>