<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Aggregating Reads from a Go Channel | Libelli</title>
<meta name=keywords content><meta name=description content="Here&rsquo;s the scenario: we have a buffered channel that&rsquo;s being read by a single Go routine and is written to by multiple go routines. For simplicity, we&rsquo;ll say that the channel accepts events and that the other routines generate events of specific types, A, B, and C. If there are more of one type of event generator (or some producers are faster than others) we may end up in the situation where there are a series of the same events on the buffered channel. What we would like to do is read all of the same type of event that is on the buffered channel at once, handling them all simultaneously; e.g. aggregating the read of our events."><meta name=author content="Benjamin Bengfort"><link rel=canonical href=https://bbengfort.github.io/2018/08/aggregating-go-channels/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://bbengfort.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://bbengfort.github.io/icon.png><link rel=icon type=image/png sizes=32x32 href=https://bbengfort.github.io/icon.png><link rel=apple-touch-icon href=https://bbengfort.github.io/apple-touch-icon-precomposed.png><link rel=mask-icon href=https://bbengfort.github.io/icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://bbengfort.github.io/2018/08/aggregating-go-channels/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-D3BE7EHHVP"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-D3BE7EHHVP")}</script><meta property="og:title" content="Aggregating Reads from a Go Channel"><meta property="og:description" content="Here&rsquo;s the scenario: we have a buffered channel that&rsquo;s being read by a single Go routine and is written to by multiple go routines. For simplicity, we&rsquo;ll say that the channel accepts events and that the other routines generate events of specific types, A, B, and C. If there are more of one type of event generator (or some producers are faster than others) we may end up in the situation where there are a series of the same events on the buffered channel. What we would like to do is read all of the same type of event that is on the buffered channel at once, handling them all simultaneously; e.g. aggregating the read of our events."><meta property="og:type" content="article"><meta property="og:url" content="https://bbengfort.github.io/2018/08/aggregating-go-channels/"><meta property="og:image" content="https://bbengfort.github.io/bear.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-08-25T08:28:59+00:00"><meta property="article:modified_time" content="2018-08-25T08:28:59+00:00"><meta property="og:site_name" content="Libelli"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://bbengfort.github.io/bear.png"><meta name=twitter:title content="Aggregating Reads from a Go Channel"><meta name=twitter:description content="Here&rsquo;s the scenario: we have a buffered channel that&rsquo;s being read by a single Go routine and is written to by multiple go routines. For simplicity, we&rsquo;ll say that the channel accepts events and that the other routines generate events of specific types, A, B, and C. If there are more of one type of event generator (or some producers are faster than others) we may end up in the situation where there are a series of the same events on the buffered channel. What we would like to do is read all of the same type of event that is on the buffered channel at once, handling them all simultaneously; e.g. aggregating the read of our events."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://bbengfort.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Aggregating Reads from a Go Channel","item":"https://bbengfort.github.io/2018/08/aggregating-go-channels/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Aggregating Reads from a Go Channel","name":"Aggregating Reads from a Go Channel","description":"Here\u0026rsquo;s the scenario: we have a buffered channel that\u0026rsquo;s being read by a single Go routine and is written to by multiple go routines. For simplicity, we\u0026rsquo;ll say that the channel accepts events and that the other routines generate events of specific types, A, B, and C. If there are more of one type of event generator (or some producers are faster than others) we may end up in the situation where there are a series of the same events on the buffered channel. What we would like to do is read all of the same type of event that is on the buffered channel at once, handling them all simultaneously; e.g. aggregating the read of our events.\n","keywords":[],"articleBody":"Here’s the scenario: we have a buffered channel that’s being read by a single Go routine and is written to by multiple go routines. For simplicity, we’ll say that the channel accepts events and that the other routines generate events of specific types, A, B, and C. If there are more of one type of event generator (or some producers are faster than others) we may end up in the situation where there are a series of the same events on the buffered channel. What we would like to do is read all of the same type of event that is on the buffered channel at once, handling them all simultaneously; e.g. aggregating the read of our events.\nAn initial solution is composed of two loops; the first loop has a select that performs a blocking read of either the msgs or a done channel to determine when to exit the go routine. If a msg is received a second loop labeled grouper is initiated with a non blocking read of the msgs channel. The loop keeps track of a current and next value. If next and current are the same, it continues reading off the channel, until they are different or there is nothing to read at which point it handles both next and current.\nfunc consumeAggregate(msgs \u003c-chan string, done \u003c-chan bool) { var current, next string var count int for { // Outer select does a blocking read on both channels select { case current = \u003c-msgs: // count our current event ecount = 1 grouper: // continue reading events off the msgs channel for { select { case next = \u003c-msgs: if next != current { // exit grouper loop and handle next and current break grouper } else { // keep track of the number of similar events count++ } default: // nothing is on the channel, break grouper and // only handle current by setting next to empty next = \"\" break grouper } } case \u003c-done: // done consuming exit go routine return } // This section happens after select is complete // handle the current messages with the aggregate count handle(current, count) // handle next if one exists if next != \"\" { handle(next, 1) } } } This solution does have one obvious problem; the next value is not aggregated with similar values that happen after. E.g. in the event stream aaaabbb, the calls to handle will be (a, 4), (b, 1), (b, 2). The good news though is that testing with the race and deadlock detector show that this method is correct. Possible improvements for a future post include:\nAggregate the next value Read val, ok from the channel to detect if it’s closed to exit convert the outer loop to a range to complete when the channel is closed Here is the Aggregating Channel Gist that contains the complete code and tests.\n","wordCount":"482","inLanguage":"en","image":"https://bbengfort.github.io/bear.png","datePublished":"2018-08-25T08:28:59Z","dateModified":"2018-08-25T08:28:59Z","author":{"@type":"Person","name":"Benjamin Bengfort"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://bbengfort.github.io/2018/08/aggregating-go-channels/"},"publisher":{"@type":"Organization","name":"Libelli","logo":{"@type":"ImageObject","url":"https://bbengfort.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bbengfort.github.io/ accesskey=h title="Libelli (Alt + H)"><img src=https://bbengfort.github.io/icon.png alt aria-label=logo height=35>Libelli</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://bbengfort.github.io/archive/ title=archive><span>archive</span></a></li><li><a href=https://bbengfort.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://bbengfort.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://bbengfort.github.io/about/ title=about><span>about</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://bbengfort.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://bbengfort.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Aggregating Reads from a Go Channel</h1><div class=post-meta><span title='2018-08-25 08:28:59 +0000 UTC'>August 25, 2018</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;482 words&nbsp;·&nbsp;Benjamin Bengfort&nbsp;|&nbsp;<a href=https://github.com/bbengfort/bbengfort.github.io/tree/main/content/posts/2018-08-25-aggregating-go-channels.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>Here&rsquo;s the scenario: we have a buffered channel that&rsquo;s being read by a single Go routine and is written to by multiple go routines. For simplicity, we&rsquo;ll say that the channel accepts events and that the other routines generate events of specific types, <code>A</code>, <code>B</code>, and <code>C</code>. If there are more of one type of event generator (or some producers are faster than others) we may end up in the situation where there are a series of the same events on the buffered channel. What we would like to do is read <em>all</em> of the same type of event that is on the buffered channel at once, handling them all simultaneously; e.g. aggregating the read of our events.</p><p><img loading=lazy src=/images/2018-08-25-event_channel.png alt="Event Stream"></p><p>An initial solution is composed of two loops; the first loop has a select that performs a blocking read of either the <code>msgs</code> or a <code>done</code> channel to determine when to exit the go routine. If a <code>msg</code> is received a second loop labeled grouper is initiated with a non blocking read of the <code>msgs</code> channel. The loop keeps track of a <code>current</code> and <code>next</code> value. If <code>next</code> and <code>current</code> are the same, it continues reading off the channel, until they are different or there is nothing to read at which point it handles both <code>next</code> and <code>current</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>consumeAggregate</span><span class=p>(</span><span class=nx>msgs</span> <span class=o>&lt;-</span><span class=kd>chan</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>done</span> <span class=o>&lt;-</span><span class=kd>chan</span> <span class=kt>bool</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>current</span><span class=p>,</span> <span class=nx>next</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>count</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Outer select does a blocking read on both channels
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=nx>current</span> <span class=p>=</span> <span class=o>&lt;-</span><span class=nx>msgs</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1>// count our current event
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nx>ecount</span> <span class=p>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=nx>grouper</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1>// continue reading events off the msgs channel
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>case</span> <span class=nx>next</span> <span class=p>=</span> <span class=o>&lt;-</span><span class=nx>msgs</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=k>if</span> <span class=nx>next</span> <span class=o>!=</span> <span class=nx>current</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=c1>// exit grouper loop and handle next and current
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=k>break</span> <span class=nx>grouper</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=c1>// keep track of the number of similar events
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=nx>count</span><span class=o>++</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>                <span class=k>default</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=c1>// nothing is on the channel, break grouper and
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=c1>// only handle current by setting next to empty
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=nx>next</span> <span class=p>=</span> <span class=s>&#34;&#34;</span>
</span></span><span class=line><span class=cl>                    <span class=k>break</span> <span class=nx>grouper</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=o>&lt;-</span><span class=nx>done</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1>// done consuming exit go routine
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>return</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// This section happens after select is complete
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// handle the current messages with the aggregate count
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>handle</span><span class=p>(</span><span class=nx>current</span><span class=p>,</span> <span class=nx>count</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// handle next if one exists
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=nx>next</span> <span class=o>!=</span> <span class=s>&#34;&#34;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>handle</span><span class=p>(</span><span class=nx>next</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This solution does have one obvious problem; the <code>next</code> value is not aggregated with similar values that happen after. E.g. in the event stream <code>aaaabbb</code>, the calls to <code>handle</code> will be <code>(a, 4)</code>, <code>(b, 1)</code>, <code>(b, 2)</code>. The good news though is that testing with the race and deadlock detector show that this method is correct. Possible improvements for a future post include:</p><ul><li>Aggregate the next value</li><li>Read <code>val, ok</code> from the channel to detect if it&rsquo;s closed to exit</li><li>convert the outer loop to a <code>range</code> to complete when the channel is closed</li></ul><p>Here is the <a href=https://gist.github.com/bbengfort/9b152a12a0291c5b5d403cbe6c8202ad>Aggregating Channel Gist</a> that contains the complete code and tests.</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://bbengfort.github.io/2018/09/future-date/><span class=title>« Prev</span><br><span>Future Date Script</span>
</a><a class=next href=https://bbengfort.github.io/2018/08/actor-model/><span class=title>Next »</span><br><span>The Actor Model</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://bbengfort.github.io/>Libelli</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>