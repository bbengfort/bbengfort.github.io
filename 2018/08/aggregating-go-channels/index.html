<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Aggregating Reads from a Go Channel | Libelli</title><meta name=keywords content><meta name=description content="Here&rsquo;s the scenario: we have a buffered channel that&rsquo;s being read by a single Go routine and is written to by multiple go routines. For simplicity, we&rsquo;ll say that the channel accepts events and that the other routines generate events of specific types, A, B, and C. If there are more of one type of event generator (or some producers are faster than others) we may end up in the situation where there are a series of the same events on the buffered channel."><meta name=author content="Benjamin Bengfort"><link rel=canonical href=https://bbengfort.github.io/2018/08/aggregating-go-channels/><link crossorigin=anonymous href=/assets/css/stylesheet.min.2d6dbfc6e0f8a1db1c9d082a76dc11d094328cf63f247bbc2421dfaa7f2bb170.css integrity="sha256-LW2/xuD4odscnQgqdtwR0JQyjPY/JHu8JCHfqn8rsXA=" rel="preload stylesheet" as=style><link rel=preload href=/icon.png as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://bbengfort.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://bbengfort.github.io/icon.png><link rel=icon type=image/png sizes=32x32 href=https://bbengfort.github.io/icon.png><link rel=apple-touch-icon href=https://bbengfort.github.io/apple-touch-icon-precomposed.png><link rel=mask-icon href=https://bbengfort.github.io/icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.105.0"><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-8096804-11","auto"),ga("send","pageview"))</script><meta property="og:title" content="Aggregating Reads from a Go Channel"><meta property="og:description" content="Here&rsquo;s the scenario: we have a buffered channel that&rsquo;s being read by a single Go routine and is written to by multiple go routines. For simplicity, we&rsquo;ll say that the channel accepts events and that the other routines generate events of specific types, A, B, and C. If there are more of one type of event generator (or some producers are faster than others) we may end up in the situation where there are a series of the same events on the buffered channel."><meta property="og:type" content="article"><meta property="og:url" content="https://bbengfort.github.io/2018/08/aggregating-go-channels/"><meta property="og:image" content="https://bbengfort.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-08-25T08:28:59+00:00"><meta property="article:modified_time" content="2018-08-25T08:28:59+00:00"><meta property="og:site_name" content="Libelli"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://bbengfort.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Aggregating Reads from a Go Channel"><meta name=twitter:description content="Here&rsquo;s the scenario: we have a buffered channel that&rsquo;s being read by a single Go routine and is written to by multiple go routines. For simplicity, we&rsquo;ll say that the channel accepts events and that the other routines generate events of specific types, A, B, and C. If there are more of one type of event generator (or some producers are faster than others) we may end up in the situation where there are a series of the same events on the buffered channel."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://bbengfort.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Aggregating Reads from a Go Channel","item":"https://bbengfort.github.io/2018/08/aggregating-go-channels/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Aggregating Reads from a Go Channel","name":"Aggregating Reads from a Go Channel","description":"Here\u0026rsquo;s the scenario: we have a buffered channel that\u0026rsquo;s being read by a single Go routine and is written to by multiple go routines. For simplicity, we\u0026rsquo;ll say that the channel accepts events and that the other routines generate events of specific types, A, B, and C. If there are more of one type of event generator (or some producers are faster than others) we may end up in the situation where there are a series of the same events on the buffered channel.","keywords":[],"articleBody":"Here’s the scenario: we have a buffered channel that’s being read by a single Go routine and is written to by multiple go routines. For simplicity, we’ll say that the channel accepts events and that the other routines generate events of specific types, A, B, and C. If there are more of one type of event generator (or some producers are faster than others) we may end up in the situation where there are a series of the same events on the buffered channel. What we would like to do is read all of the same type of event that is on the buffered channel at once, handling them all simultaneously; e.g. aggregating the read of our events.\nAn initial solution is composed of two loops; the first loop has a select that performs a blocking read of either the msgs or a done channel to determine when to exit the go routine. If a msg is received a second loop labeled grouper is initiated with a non blocking read of the msgs channel. The loop keeps track of a current and next value. If next and current are the same, it continues reading off the channel, until they are different or there is nothing to read at which point it handles both next and current.\nfunc consumeAggregate(msgs \u003c-chan string, done \u003c-chan bool) { var current, next string var count int for { // Outer select does a blocking read on both channels select { case current = \u003c-msgs: // count our current event ecount = 1 grouper: // continue reading events off the msgs channel for { select { case next = \u003c-msgs: if next != current { // exit grouper loop and handle next and current break grouper } else { // keep track of the number of similar events count++ } default: // nothing is on the channel, break grouper and // only handle current by setting next to empty next = \"\" break grouper } } case \u003c-done: // done consuming exit go routine return } // This section happens after select is complete // handle the current messages with the aggregate count handle(current, count) // handle next if one exists if next != \"\" { handle(next, 1) } } } This solution does have one obvious problem; the next value is not aggregated with similar values that happen after. E.g. in the event stream aaaabbb, the calls to handle will be (a, 4), (b, 1), (b, 2). The good news though is that testing with the race and deadlock detector show that this method is correct. Possible improvements for a future post include:\nAggregate the next value Read val, ok from the channel to detect if it’s closed to exit convert the outer loop to a range to complete when the channel is closed Here is the Aggregating Channel Gist that contains the complete code and tests.\n","wordCount":"482","inLanguage":"en","datePublished":"2018-08-25T08:28:59Z","dateModified":"2018-08-25T08:28:59Z","author":{"@type":"Person","name":"Benjamin Bengfort"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://bbengfort.github.io/2018/08/aggregating-go-channels/"},"publisher":{"@type":"Organization","name":"Libelli","logo":{"@type":"ImageObject","url":"https://bbengfort.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://bbengfort.github.io accesskey=h title="Libelli (Alt + H)"><img src=/icon.png alt=logo aria-label=logo height=35>Libelli</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://bbengfort.github.io/archive/ title=archive><span>archive</span></a></li><li><a href=https://bbengfort.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://bbengfort.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://bbengfort.github.io/about/ title=about><span>about</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Aggregating Reads from a Go Channel</h1><div class=post-meta>August 25, 2018&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Benjamin Bengfort</div></header><div class=post-content><p>Here&rsquo;s the scenario: we have a buffered channel that&rsquo;s being read by a single Go routine and is written to by multiple go routines. For simplicity, we&rsquo;ll say that the channel accepts events and that the other routines generate events of specific types, <code>A</code>, <code>B</code>, and <code>C</code>. If there are more of one type of event generator (or some producers are faster than others) we may end up in the situation where there are a series of the same events on the buffered channel. What we would like to do is read <em>all</em> of the same type of event that is on the buffered channel at once, handling them all simultaneously; e.g. aggregating the read of our events.</p><p><img loading=lazy src=/images/2018-08-25-event_channel.png alt="Event Stream"></p><p>An initial solution is composed of two loops; the first loop has a select that performs a blocking read of either the <code>msgs</code> or a <code>done</code> channel to determine when to exit the go routine. If a <code>msg</code> is received a second loop labeled grouper is initiated with a non blocking read of the <code>msgs</code> channel. The loop keeps track of a <code>current</code> and <code>next</code> value. If <code>next</code> and <code>current</code> are the same, it continues reading off the channel, until they are different or there is nothing to read at which point it handles both <code>next</code> and <code>current</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>consumeAggregate</span>(<span style=color:#a6e22e>msgs</span> <span style=color:#f92672>&lt;-</span><span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>done</span> <span style=color:#f92672>&lt;-</span><span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>bool</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>current</span>, <span style=color:#a6e22e>next</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>count</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Outer select does a blocking read on both channels
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>select</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>current</span> = <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>msgs</span>:
</span></span><span style=display:flex><span>            <span style=color:#75715e>// count our current event
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>ecount</span> = <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>grouper</span>:
</span></span><span style=display:flex><span>            <span style=color:#75715e>// continue reading events off the msgs channel
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>select</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>next</span> = <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>msgs</span>:
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>next</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>current</span> {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// exit grouper loop and handle next and current
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>break</span> <span style=color:#a6e22e>grouper</span>
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// keep track of the number of similar events
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#a6e22e>count</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>default</span>:
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// nothing is on the channel, break grouper and
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// only handle current by setting next to empty
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#a6e22e>next</span> = <span style=color:#e6db74>&#34;&#34;</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>break</span> <span style=color:#a6e22e>grouper</span>
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>done</span>:
</span></span><span style=display:flex><span>            <span style=color:#75715e>// done consuming exit go routine
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// This section happens after select is complete
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// handle the current messages with the aggregate count
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>handle</span>(<span style=color:#a6e22e>current</span>, <span style=color:#a6e22e>count</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// handle next if one exists
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>next</span> <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#34;&#34;</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>handle</span>(<span style=color:#a6e22e>next</span>, <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This solution does have one obvious problem; the <code>next</code> value is not aggregated with similar values that happen after. E.g. in the event stream <code>aaaabbb</code>, the calls to <code>handle</code> will be <code>(a, 4)</code>, <code>(b, 1)</code>, <code>(b, 2)</code>. The good news though is that testing with the race and deadlock detector show that this method is correct. Possible improvements for a future post include:</p><ul><li>Aggregate the next value</li><li>Read <code>val, ok</code> from the channel to detect if it&rsquo;s closed to exit</li><li>convert the outer loop to a <code>range</code> to complete when the channel is closed</li></ul><p>Here is the <a href=https://gist.github.com/bbengfort/9b152a12a0291c5b5d403cbe6c8202ad>Aggregating Channel Gist</a> that contains the complete code and tests.</p></div><footer class=post-footer></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://bbengfort.github.io>Libelli</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById("menu");menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>