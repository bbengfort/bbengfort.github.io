<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>The Actor Model | Libelli</title><meta name=keywords content><meta name=description content="Building correct concurrent programs in a distributed system with multiple threads and processes can quickly become very complex to reason about. For performance, we want each thread in a single process to operate as independently as possible; however anytime the shared state of the system is modified synchronization is required. Primitives like mutexes can [ensure structs are thread-safe]({% post_url 2017-02-21-synchronizing-structs %}), however in Go, the strong preference for synchronization is communication."><meta name=author content="Benjamin Bengfort"><link rel=canonical href=https://bbengfort.github.io/2018/08/actor-model/><link crossorigin=anonymous href=/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe+FVUFzPh7U=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://bbengfort.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://bbengfort.github.io/icon.png><link rel=icon type=image/png sizes=32x32 href=https://bbengfort.github.io/icon.png><link rel=apple-touch-icon href=https://bbengfort.github.io/apple-touch-icon-precomposed.png><link rel=mask-icon href=https://bbengfort.github.io/icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-8096804-11","auto"),ga("send","pageview"))</script><meta property="og:title" content="The Actor Model"><meta property="og:description" content="Building correct concurrent programs in a distributed system with multiple threads and processes can quickly become very complex to reason about. For performance, we want each thread in a single process to operate as independently as possible; however anytime the shared state of the system is modified synchronization is required. Primitives like mutexes can [ensure structs are thread-safe]({% post_url 2017-02-21-synchronizing-structs %}), however in Go, the strong preference for synchronization is communication."><meta property="og:type" content="article"><meta property="og:url" content="https://bbengfort.github.io/2018/08/actor-model/"><meta property="og:image" content="https://bbengfort.github.io/bear.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-08-03T07:27:36+00:00"><meta property="article:modified_time" content="2018-08-03T07:27:36+00:00"><meta property="og:site_name" content="Libelli"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://bbengfort.github.io/bear.png"><meta name=twitter:title content="The Actor Model"><meta name=twitter:description content="Building correct concurrent programs in a distributed system with multiple threads and processes can quickly become very complex to reason about. For performance, we want each thread in a single process to operate as independently as possible; however anytime the shared state of the system is modified synchronization is required. Primitives like mutexes can [ensure structs are thread-safe]({% post_url 2017-02-21-synchronizing-structs %}), however in Go, the strong preference for synchronization is communication."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://bbengfort.github.io/posts/"},{"@type":"ListItem","position":3,"name":"The Actor Model","item":"https://bbengfort.github.io/2018/08/actor-model/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"The Actor Model","name":"The Actor Model","description":"Building correct concurrent programs in a distributed system with multiple threads and processes can quickly become very complex to reason about. For performance, we want each thread in a single process to operate as independently as possible; however anytime the shared state of the system is modified synchronization is required. Primitives like mutexes can [ensure structs are thread-safe]({% post_url 2017-02-21-synchronizing-structs %}), however in Go, the strong preference for synchronization is communication.","keywords":[],"articleBody":"Building correct concurrent programs in a distributed system with multiple threads and processes can quickly become very complex to reason about. For performance, we want each thread in a single process to operate as independently as possible; however anytime the shared state of the system is modified synchronization is required. Primitives like mutexes can [ensure structs are thread-safe]({% post_url 2017-02-21-synchronizing-structs %}), however in Go, the strong preference for synchronization is communication. In either case Go programs can quickly become locks upon locks or morasses of channels, incurring performance penalties at each synchronization point.\nThe Actor Model is a solution for reasoning about concurrency in distributed systems that helps eliminate unnecessary synchronization. In the actor model, we consider our system to be composed of actors, computational primitives that have a private state, can send and receive messages, and perform computations based on those messages. The key is that a system is composed of many actors and actors do not share memory, they have to communicate with messaging. Although Go does not provide first class actor primitives like languages such as Akka or Erlang, this does fit in well with the CSP principle.\nIn the next few posts, I’ll explore implementing the Actor model in Go for a simple distributed system that allows clients to make requests and periodically synchronizes its state to its peers. The model is shown below:\nActors An actor is a process or a thread that has the ability to send and receive messages. When an actor receives a message it can do one of three things:\nCreate new actors Send messages to known actors Can designate how you handle the next message At first glance we may think that actors are only created at the beginning of a program, e.g. the “main” actor or the instantiation of a program-long ticker actor that sends periodic messages and can receive start and stop messages. However, anytime a go programmer executes a new go routine, there is the possibility of a new actor being created. In our example, we’ll explore how a server creates temporary actors to handle single requests from clients.\nSending messages to known actors allows an actor to synchronize or share state with other go routines in the same process, other processes on the same machine, or even processes on other machines. As a result, actors are a natural framework for creating distributed systems. In our example we’ll send messages both with channels as well as using gRPC for network communications.\nThe most important thing to understand about actor communication is that although actors run concurrently, they will only process messages sequentially in the order which they are received. Actors send messages asynchronously (e.g. an actor isn’t blocked while waiting for another actor to receive the message). This means that messages need to be stored while the actor is processing other messages; this storage is usually called a “mailbox”. We’ll implement mailboxes with buffered channels in this post.\nDeciding how to handle the next message is a general way for saying that actors “do something” with messages, usually by modifying their state, and that it is something “interesting enough” that it impacts how the next message is handled. This implies a couple of things:\nActors have an internal state and memory Actors mutate their state based on messages How an actor responds depends on the order of messages received Actors can shutdown or stop For the rest of the posts, we’ll consider a simple service that hands out monotonically increasing, unique identities to clients called Ipseity. If the actor receives a next() message, it increments it’s local counter (mutating it’s internal state) ensuring that the next message always returns a monotonically increasing number. If it receives an update(id) message, it updates it’s internal state to specified id if it is larger than its internal id, allowing it to synchronize with remote peers (in an eventually consistent fashion).\nEvent Model In order to reduce confusion between network messages and actor messages, I prefer to use the term “event” when referring to messages sent between actors. This also allows us to reason about actors as implementing an event loop, another common distributed systems design paradigm. It is important to note that “actors are a specialized, opinionated implementation of an event driven architecture”, which means the actor model is a subset of event architectures, such as the [dispatcher model]({% post_url 2017-07-21-event-dispatcher %}) described earlier in this journal.\nI realize this does cause a bit of cognitive overhead, but this pays off when complex systems with many event types can be traced, showing a serial order of events handled by an actor. So for now, we’ll consider an event a message that can be “dispatched” (sent) to other actors, and “handled” (received) by an actor, one at a time.\nEvents are described by their type, which determines what data the event contains and how it should be handled by the actor. In Go, event types can be implemented as an enumeration by extending the uint16 type as follows:\n// Event types represented in Ipseity const ( UnknownEvent EventType = iota IdentityRequest SyncTimeout SyncRequest SyncReply ) // String names of event types var eventTypeStrings = [...]string{ \"unknown\", \"identityRequest\", \"syncTimeout\", \"syncRequest\", \"syncReply\", } // EventType is an enumeration of the kind of events that actors handle type EventType uint16 // String returns the human readable name of the event type func (t EventType) String() string { if int(t) \u003c len(eventTypeStrings) { return eventTypeStrings[t] } return eventTypeStrings[0] } Events themselves are usually represented by an interface to allow for multiple event types with specialized functionality to be created in code. For simplicity here, however, I’ll simply define a single event struct and we’ll use type casting later in the code:\ntype Event struct { Type EventType Source interface{} Value interface{} } The Source of the event is the actor that is dispatching the event, and we’ll primarily use this to store channels so that we can send messages (events) back to the actor. The Value of the event is any associated data that needs to be used by the actor processing the event.\nActor Interface There are a lot of different types of actors including:\nActors that run for the duration of the program Actors that generate events but do not receive them Actors that exist ephemerally to handle one or few events As a result it is difficult to describe an interface that handles all of these types generically. Instead we’ll focus on the central actor of our application (called the “Local Actor” in the diagram above), which fulfills the first role (runs the duration of the program) and most completely describes the actor design.\ntype Actor interface { Listen(addr string) error // Run the actor to listen for messages Dispatch(Event) error // Outside callers dispatch events to actor Handle(Event) error // Handle each event sequentially } As noted in the introduction and throughput appendix below, there are a number of ways to implement the actor interface that ensure events received by the Dispatch method are handled one at a time, in sequential order. Here, we’ll use a a buffered channel as a mailbox of a fixed size, so that other actors that are dispatching events to this actor aren’t blocked while the actor is handling other messages.\ntype ActorServer struct { pid int64 // unique identity of the actor events chan Event // mailbox to receive event dispatches sequence int64 // internal state, monotonically increasing identity } The Listen method starts the actor, (as well as a gRPC server on the specified addr, which we’ll discuss later) and reads messages off the channel one at a time, executing the Handle method for each message before moving to the next message. Listen runs forever until the events channel is closed, e.g. when the program exits.\nfunc (a *ActorServer) Listen(addr string) error { // Initialize the events channel able to buffer 1024 messages a.events = make(chan Event, 1024) // Read events off of the channel sequentially for event := range a.events { if err := a.Handle(event); err != nil { return err } } return nil } The Handle method can create new actors, send messages, and determine how to respond to the next event. Generally it is just a jump table, passing the event to the correct event handling method:\nfunc (a *ActorServer) Handle(e Event) error { switch e.Type() { case IdentityRequest: return a.onIdentityRequest(e) case SyncTimeout: return a.onSyncTimeout(e) case SyncRequest: return a.onSyncRequest(e) case SyncReply: return a.onSyncReply(e) default: return fmt.Errorf(\"no handler identified for event %s\", e.Type()) } } The Dispatch method allows other actors to send events to the actor, by simply putting the event on the channel. When other go routines call Dispatch they won’t be blocked, waiting for the actor to handle the event because of the buffer … unless the actor has been backed up so the buffer is full.\nfunc (a *ActorServer) Dispatch(e Event) error { a.events \u003c- e return nil } Next Steps In the next post (or two) we’ll hook up a gRPC server to the actor so that it can serve identity requests to clients as well as send and respond to synchronization requests for remote actors. We’ll also create a second go routine next to the actor process that issues synchronization timeouts on a periodic interval. Together, the complete system will be able to issue monotonically increasing identities in an eventually consistent fashion.\nOther Resources For any discussion of Actors, it seems obligatory to include this very entertaining video of Carl Hewitt, the inventor of the actor model, describing them on a white board with Erik Meijer and Clemens Szyperski.\nOther blog posts:\nThe actor model in 10 minutes Why has the actor model not succeeded? Understanding reactive architecture through the actor model Appendix: Throughput One of the biggest questions I had was whether or not the actor model introduced any performance issues over a regular mutex by serializing a wrapper event over a channel instead of directly locking the actor state. I tested the throughput for the following types of ipseity servers:\nSimple: locks the whole server to increment the sequence and create the response to the client. Sequence: creates a sequence struct that is locked when incremented, but not when creating the response to the client. Actor: Uses the buffered channel actor model as described in this post. Locker: Implements the actor interface but instead of a buffered channel uses a mutex to serialize events. As you can see from the above benchmark, it does not appear that the actor model described in these posts adds overhead that penalizes performance.\nThe code for both the benchmark and the implementations of the servers above can be found at: https://github.com/bbengfort/ipseity/tree/multiactor\n","wordCount":"1784","inLanguage":"en","datePublished":"2018-08-03T07:27:36Z","dateModified":"2018-08-03T07:27:36Z","author":{"@type":"Person","name":"Benjamin Bengfort"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://bbengfort.github.io/2018/08/actor-model/"},"publisher":{"@type":"Organization","name":"Libelli","logo":{"@type":"ImageObject","url":"https://bbengfort.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bbengfort.github.io accesskey=h title="Libelli (Alt + H)"><img src=https://bbengfort.github.io/icon.png alt aria-label=logo height=35>Libelli</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://bbengfort.github.io/archive/ title=archive><span>archive</span></a></li><li><a href=https://bbengfort.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://bbengfort.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://bbengfort.github.io/about/ title=about><span>about</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://bbengfort.github.io>Home</a>&nbsp;»&nbsp;<a href=https://bbengfort.github.io/posts/>Posts</a></div><h1 class=post-title>The Actor Model</h1><div class=post-meta><span title='2018-08-03 07:27:36 +0000 UTC'>August 3, 2018</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;1784 words&nbsp;·&nbsp;Benjamin Bengfort&nbsp;|&nbsp;<a href=https://github.com/bbengfort/bbengfort.github.io/tree/main/content/posts/2018-08-03-actor-model.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>Building correct concurrent programs in a distributed system with multiple threads and processes can quickly become very complex to reason about. For performance, we want each thread in a single process to operate as independently as possible; however anytime the shared state of the system is modified synchronization is required. Primitives like mutexes can [ensure structs are thread-safe]({% post_url 2017-02-21-synchronizing-structs %}), however in Go, the strong preference for <a href=https://blog.golang.org/share-memory-by-communicating>synchronization is communication</a>. In either case Go programs can quickly become locks upon locks or morasses of channels, incurring performance penalties at each synchronization point.</p><p>The <a href=https://en.wikipedia.org/wiki/Actor_model>Actor Model</a> is a solution for reasoning about concurrency in distributed systems that helps eliminate unnecessary synchronization. In the actor model, we consider our system to be composed of <em>actors</em>, computational primitives that have a private state, can send and receive messages, and perform computations based on those messages. The key is that a system is composed of many actors and actors do not share memory, they have to communicate with messaging. Although Go does not provide first class actor primitives like languages such as Akka or Erlang, this does fit in well with the <a href=http://www.usingcsp.com/>CSP</a> principle.</p><p>In the next few posts, I&rsquo;ll explore implementing the Actor model in Go for a simple distributed system that allows clients to make requests and periodically synchronizes its state to its peers. The model is shown below:</p><p><img loading=lazy src=/images/2018-08-03-actor-model.png alt="The Actor Model"></p><h2 id=actors>Actors<a hidden class=anchor aria-hidden=true href=#actors>#</a></h2><p>An actor is a process or a thread that has the ability to send and receive messages. When an actor receives a message it can do one of three things:</p><ol><li>Create new actors</li><li>Send messages to known actors</li><li>Can designate how you handle the next message</li></ol><p>At first glance we may think that actors are only created at the beginning of a program, e.g. the &ldquo;main&rdquo; actor or the instantiation of a program-long ticker actor that sends periodic messages and can receive start and stop messages. However, anytime a go programmer executes a new go routine, there is the possibility of a new actor being created. In our example, we&rsquo;ll explore how a server creates temporary actors to handle single requests from clients.</p><p>Sending messages to known actors allows an actor to synchronize or share state with other go routines in the same process, other processes on the same machine, or even processes on other machines. As a result, actors are a natural framework for creating distributed systems. In our example we&rsquo;ll send messages both with channels as well as using <a href=https://grpc.io/>gRPC</a> for network communications.</p><p>The most important thing to understand about actor communication is that although actors run concurrently, they will only process messages sequentially in the order which they are received. Actors send messages asynchronously (e.g. an actor isn&rsquo;t blocked while waiting for another actor to receive the message). This means that messages need to be stored while the actor is processing other messages; this storage is usually called a &ldquo;mailbox&rdquo;. We&rsquo;ll implement mailboxes with buffered channels in this post.</p><p>Deciding how to handle the next message is a general way for saying that actors &ldquo;do something&rdquo; with messages, usually by modifying their state, and that it is something &ldquo;interesting enough&rdquo; that it impacts how the next message is handled. This implies a couple of things:</p><ul><li>Actors have an internal state and memory</li><li>Actors mutate their state based on messages</li><li>How an actor responds depends on the order of messages received</li><li>Actors can shutdown or stop</li></ul><p>For the rest of the posts, we&rsquo;ll consider a simple service that hands out monotonically increasing, unique identities to clients called <strong>Ipseity</strong>. If the actor receives a <code>next()</code> message, it increments it&rsquo;s local counter (mutating it&rsquo;s internal state) ensuring that the next message always returns a monotonically increasing number. If it receives an <code>update(id)</code> message, it updates it&rsquo;s internal state to specified id if it is larger than its internal id, allowing it to synchronize with remote peers (in an eventually consistent fashion).</p><h3 id=event-model>Event Model<a hidden class=anchor aria-hidden=true href=#event-model>#</a></h3><p>In order to reduce confusion between network messages and actor messages, I prefer to use the term &ldquo;event&rdquo; when referring to messages sent between actors. This also allows us to reason about actors as implementing an event loop, another common distributed systems design paradigm. It is important to note that <a href=https://www.quora.com/What-are-the-relative-tradeoffs-between-the-actors-model-and-an-event-driven-architecture>“actors are a specialized, opinionated implementation of an event driven architecture”</a>, which means the actor model is a subset of event architectures, such as the [dispatcher model]({% post_url 2017-07-21-event-dispatcher %}) described earlier in this journal.</p><p>I realize this does cause a bit of cognitive overhead, but this pays off when complex systems with many event types can be traced, showing a serial order of events handled by an actor. So for now, we&rsquo;ll consider an event a message that can be &ldquo;dispatched&rdquo; (sent) to other actors, and &ldquo;handled&rdquo; (received) by an actor, one at a time.</p><p>Events are described by their type, which determines what data the event contains and how it should be handled by the actor. In Go, event types can be implemented as an enumeration by extending the <code>uint16</code> type as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Event types represented in Ipseity
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>const</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=nx>UnknownEvent</span> <span class=nx>EventType</span> <span class=p>=</span> <span class=kc>iota</span>
</span></span><span class=line><span class=cl>    <span class=nx>IdentityRequest</span>
</span></span><span class=line><span class=cl>    <span class=nx>SyncTimeout</span>
</span></span><span class=line><span class=cl>    <span class=nx>SyncRequest</span>
</span></span><span class=line><span class=cl>    <span class=nx>SyncReply</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// String names of event types
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>eventTypeStrings</span> <span class=p>=</span> <span class=p>[</span><span class=o>...</span><span class=p>]</span><span class=kt>string</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;unknown&#34;</span><span class=p>,</span> <span class=s>&#34;identityRequest&#34;</span><span class=p>,</span> <span class=s>&#34;syncTimeout&#34;</span><span class=p>,</span> <span class=s>&#34;syncRequest&#34;</span><span class=p>,</span> <span class=s>&#34;syncReply&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// EventType is an enumeration of the kind of events that actors handle
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>EventType</span> <span class=kt>uint16</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// String returns the human readable name of the event type
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>t</span> <span class=nx>EventType</span><span class=p>)</span> <span class=nf>String</span><span class=p>()</span> <span class=kt>string</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>int</span><span class=p>(</span><span class=nx>t</span><span class=p>)</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>eventTypeStrings</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>eventTypeStrings</span><span class=p>[</span><span class=nx>t</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>eventTypeStrings</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Events themselves are usually represented by an interface to allow for multiple event types with specialized functionality to be created in code. For simplicity here, however, I&rsquo;ll simply define a single event <code>struct</code> and we&rsquo;ll use type casting later in the code:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Event</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>Type</span> <span class=nx>EventType</span>
</span></span><span class=line><span class=cl>    <span class=nx>Source</span> <span class=kd>interface</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=nx>Value</span> <span class=kd>interface</span><span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The <code>Source</code> of the event is the actor that is dispatching the event, and we&rsquo;ll primarily use this to store channels so that we can send messages (events) back to the actor. The <code>Value</code> of the event is any associated data that needs to be used by the actor processing the event.</p><h3 id=actor-interface>Actor Interface<a hidden class=anchor aria-hidden=true href=#actor-interface>#</a></h3><p>There are a lot of different types of actors including:</p><ul><li>Actors that run for the duration of the program</li><li>Actors that generate events but do not receive them</li><li>Actors that exist ephemerally to handle one or few events</li></ul><p>As a result it is difficult to describe an interface that handles all of these types generically. Instead we&rsquo;ll focus on the central actor of our application (called the &ldquo;Local Actor&rdquo; in the diagram above), which fulfills the first role (runs the duration of the program) and most completely describes the actor design.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Actor</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>Listen</span><span class=p>(</span><span class=nx>addr</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>error</span> <span class=c1>// Run the actor to listen for messages
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>Dispatch</span><span class=p>(</span><span class=nx>Event</span><span class=p>)</span> <span class=kt>error</span>     <span class=c1>// Outside callers dispatch events to actor
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>Handle</span><span class=p>(</span><span class=nx>Event</span><span class=p>)</span> <span class=kt>error</span>       <span class=c1>// Handle each event sequentially
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>As noted in the introduction and throughput appendix below, there are a number of ways to implement the actor interface that ensure events received by the <code>Dispatch</code> method are handled one at a time, in sequential order. Here, we&rsquo;ll use a a <a href=https://gobyexample.com/channel-buffering>buffered channel</a> as a mailbox of a fixed size, so that other actors that are dispatching events to this actor aren&rsquo;t blocked while the actor is handling other messages.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>ActorServer</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>pid</span>      <span class=kt>int64</span>      <span class=c1>// unique identity of the actor
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>events</span>   <span class=kd>chan</span> <span class=nx>Event</span> <span class=c1>// mailbox to receive event dispatches
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>sequence</span> <span class=kt>int64</span>      <span class=c1>// internal state, monotonically increasing identity
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>The <code>Listen</code> method starts the actor, (as well as a gRPC server on the specified <code>addr</code>, which we&rsquo;ll discuss later) and reads messages off the channel one at a time, executing the <code>Handle</code> method for each message before moving to the next message. <code>Listen</code> runs forever until the events channel is closed, e.g. when the program exits.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>a</span> <span class=o>*</span><span class=nx>ActorServer</span><span class=p>)</span> <span class=nf>Listen</span><span class=p>(</span><span class=nx>addr</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Initialize the events channel able to buffer 1024 messages
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>a</span><span class=p>.</span><span class=nx>events</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=nx>Event</span><span class=p>,</span> <span class=mi>1024</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Read events off of the channel sequentially
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=nx>event</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>a</span><span class=p>.</span><span class=nx>events</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>a</span><span class=p>.</span><span class=nf>Handle</span><span class=p>(</span><span class=nx>event</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The <code>Handle</code> method can create new actors, send messages, and determine how to respond to the next event. Generally it is just a jump table, passing the event to the correct event handling method:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>a</span> <span class=o>*</span><span class=nx>ActorServer</span><span class=p>)</span> <span class=nf>Handle</span><span class=p>(</span><span class=nx>e</span> <span class=nx>Event</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>switch</span> <span class=nx>e</span><span class=p>.</span><span class=nf>Type</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=nx>IdentityRequest</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>a</span><span class=p>.</span><span class=nf>onIdentityRequest</span><span class=p>(</span><span class=nx>e</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=nx>SyncTimeout</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>a</span><span class=p>.</span><span class=nf>onSyncTimeout</span><span class=p>(</span><span class=nx>e</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=nx>SyncRequest</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>a</span><span class=p>.</span><span class=nf>onSyncRequest</span><span class=p>(</span><span class=nx>e</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=nx>SyncReply</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>a</span><span class=p>.</span><span class=nf>onSyncReply</span><span class=p>(</span><span class=nx>e</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>default</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;no handler identified for event %s&#34;</span><span class=p>,</span> <span class=nx>e</span><span class=p>.</span><span class=nf>Type</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The <code>Dispatch</code> method allows other actors to send events to the actor, by simply putting the event on the channel. When other go routines call <code>Dispatch</code> they won&rsquo;t be blocked, waiting for the actor to handle the event because of the buffer … unless the actor has been backed up so the buffer is full.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>a</span> <span class=o>*</span><span class=nx>ActorServer</span><span class=p>)</span> <span class=nf>Dispatch</span><span class=p>(</span><span class=nx>e</span> <span class=nx>Event</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>a</span><span class=p>.</span><span class=nx>events</span> <span class=o>&lt;-</span> <span class=nx>e</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=next-steps>Next Steps<a hidden class=anchor aria-hidden=true href=#next-steps>#</a></h2><p>In the next post (or two) we&rsquo;ll hook up a gRPC server to the actor so that it can serve identity requests to clients as well as send and respond to synchronization requests for remote actors. We&rsquo;ll also create a second go routine next to the actor process that issues synchronization timeouts on a periodic interval. Together, the complete system will be able to issue monotonically increasing identities in an eventually consistent fashion.</p><h2 id=other-resources>Other Resources<a hidden class=anchor aria-hidden=true href=#other-resources>#</a></h2><p>For any discussion of Actors, it seems obligatory to include this very entertaining video of <a href=https://en.wikipedia.org/wiki/Carl_Hewitt>Carl Hewitt</a>, the inventor of the actor model, describing them on a white board with <a href=https://en.wikipedia.org/wiki/Erik_Meijer_(computer_scientist)>Erik Meijer</a> and <a href=https://g.co/kgs/MxoC3d>Clemens Szyperski</a>.</p><p>Other blog posts:</p><ul><li><a href=https://www.brianstorti.com/the-actor-model/>The actor model in 10 minutes</a></li><li><a href=https://www.doc.ic.ac.uk/~nd/surprise_97/journal/vol2/pjm2/>Why has the actor model not succeeded?</a></li><li><a href=https://www.oreilly.com/ideas/understanding-reactive-architecture-through-the-actor-model>Understanding reactive architecture through the actor model</a></li></ul><h2 id=appendix-throughput>Appendix: Throughput<a hidden class=anchor aria-hidden=true href=#appendix-throughput>#</a></h2><p>One of the biggest questions I had was whether or not the actor model introduced any performance issues over a regular mutex by serializing a wrapper event over a channel instead of directly locking the actor state. I tested the throughput for the following types of ipseity servers:</p><ul><li><strong>Simple</strong>: locks the whole server to increment the <code>sequence</code> and create the response to the client.</li><li><strong>Sequence</strong>: creates a sequence struct that is locked when incremented, but not when creating the response to the client.</li><li><strong>Actor</strong>: Uses the buffered channel actor model as described in this post.</li><li><strong>Locker</strong>: Implements the actor interface but instead of a buffered channel uses a mutex to serialize events.</li></ul><p><img loading=lazy src=/images/2018-08-03-actor-throughput.png alt="Actor Throughput"></p><p>As you can see from the above benchmark, it does not appear that the actor model described in these posts adds overhead that penalizes performance.</p><p>The code for both the benchmark and the implementations of the servers above can be found at: <a href=https://github.com/bbengfort/ipseity/tree/multiactor>https://github.com/bbengfort/ipseity/tree/multiactor</a></p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://bbengfort.github.io/2018/08/aggregating-go-channels/><span class=title>« Prev</span><br><span>Aggregating Reads from a Go Channel</span></a>
<a class=next href=https://bbengfort.github.io/2018/06/corenlp-nltk-parses/><span class=title>Next »</span><br><span>Syntax Parsing with CoreNLP and NLTK</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://bbengfort.github.io>Libelli</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>